Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    ASSIGN
    COLON
    FUNCESP
    GTE
    LTE
    NUMPY
    QUOTE

Grammar

Rule 0     S' -> decvar
Rule 1     decvar -> VAR type ID decvarp
Rule 2     decvarp -> SEMICOLON decvarp
Rule 3     decvarp -> LBRACKET INT RBRACKET decvarpp
Rule 4     decvarpp -> SEMICOLON
Rule 5     decvarpp -> LBRACKET INT RBRACKET
Rule 6     type -> INT
Rule 7     type -> FLOAT
Rule 8     type -> CHAR
Rule 9     type -> STRING
Rule 10    function -> FUNCTION type ID LPAREN param RPAREN body
Rule 11    voidfunction -> FUNCTION VOID ID LPAREN param RPAREN body
Rule 12    body -> LBRACE pbody RBRACE
Rule 13    pbody -> decvar statement pbody
Rule 14    pbody -> statement pbody
Rule 15    pbody -> decvar
Rule 16    pbody -> <empty>
Rule 17    param -> <empty>
Rule 18    param -> type paramp
Rule 19    paramp -> ID
Rule 20    paramp -> ID COMMA param
Rule 21    exp -> texp
Rule 22    exp -> texp OR exp
Rule 23    texp -> gexp
Rule 24    texp -> gexp AND texp
Rule 25    gexp -> mexp
Rule 26    gexp -> mexp gexpp mexp
Rule 27    gexpp -> LT
Rule 28    gexpp -> GT
Rule 29    gexpp -> EQUAL
Rule 30    gexpp -> DIFF
Rule 31    mexp -> t
Rule 32    mexp -> t PLUS mexp
Rule 33    mexp -> t MINUS mexp
Rule 34    t -> f
Rule 35    t -> f MULT t
Rule 36    t -> f DIV t
Rule 37    f -> LPAREN exp RPAREN
Rule 38    f -> INT
Rule 39    f -> FLOAT
Rule 40    f -> var
Rule 41    f -> call
Rule 42    statement -> assign
Rule 43    statement -> call
Rule 44    statement -> read
Rule 45    statement -> print
Rule 46    statement -> if
Rule 47    statement -> while
Rule 48    statement -> for
Rule 49    statement -> funcesp
Rule 50    assign -> var EQUAL exp
Rule 51    read -> READ var
Rule 52    print -> PRINT LPAREN printp
Rule 53    printp -> exp RPAREN
Rule 54    printp -> exp COMMA printp
Rule 55    var -> ID
Rule 56    var -> ID LBRACKET exp RBRACKET
Rule 57    var -> ID LBRACKET exp RBRACKET LBRACKET exp RBRACKET
Rule 58    call -> ID LPAREN callp RPAREN
Rule 59    callp -> exp SEMICOLON callp
Rule 60    callp -> exp
Rule 61    if -> IF LPAREN exp RPAREN statement ifp
Rule 62    ifp -> <empty>
Rule 63    ifp -> ELSE statement
Rule 64    while -> WHILE LPAREN exp RPAREN statement whilep
Rule 65    whilep -> SEMICOLON
Rule 66    whilep -> statement whilep
Rule 67    for -> FOR LPAREN var SEMICOLON exp SEMICOLON exp RPAREN LBRACKET statement forp
Rule 68    forp -> RBRACKET
Rule 69    forp -> statement forp
Rule 70    funcesp -> array
Rule 71    funcesp -> matrix
Rule 72    funcesp -> mean
Rule 73    funcesp -> layers
Rule 74    funcesp -> sequential
Rule 75    funcesp -> compile
Rule 76    funcesp -> fit
Rule 77    funcesp -> predict
Rule 78    funcesp -> getweights
Rule 79    array -> ID EQUAL ARRAY LPAREN var arrayp
Rule 80    arrayp -> RPAREN
Rule 81    arrayp -> COMMA var RPAREN
Rule 82    matrix -> ID EQUAL MATRIX LPAREN array matrixp
Rule 83    matrixp -> RPAREN
Rule 84    matrixp -> COMMA array RPAREN
Rule 85    mean -> MEAN LPAREN array RPAREN
Rule 86    layers -> ID EQUAL LAYERS LPAREN UNITS EQUAL INT RPAREN
Rule 87    sequential -> ID EQUAL SEQUENTIAL LPAREN LBRACKET layers sequentialp
Rule 88    sequentialp -> RBRACKET RPAREN
Rule 89    sequentialp -> COMMA layers sequentialp
Rule 90    compile -> sequential DOT COMPILE LPAREN RPAREN
Rule 91    fit -> ID EQUAL sequential DOT FIT LPAREN array COMMA array COMMA EPOCHS EQUAL INT COMMA VERBOSE EQUAL fitp
Rule 92    fitp -> TRUE RPAREN
Rule 93    fitp -> FALSE RPAREN
Rule 94    predict -> ID EQUAL sequential DOT PREDICT LPAREN LBRACKET predictp
Rule 95    predictp -> INT RBRACKET RPAREN
Rule 96    predictp -> FLOAT RBRACKET RPAREN
Rule 97    getweights -> layers DOT GETWEIGHTS LPAREN RPAREN
Rule 98    empty -> <empty>

Terminals, with rules where they appear

AND                  : 24
ARRAY                : 79
ASSIGN               : 
CHAR                 : 8
COLON                : 
COMMA                : 20 54 81 84 89 91 91 91
COMPILE              : 90
DIFF                 : 30
DIV                  : 36
DOT                  : 90 91 94 97
ELSE                 : 63
EPOCHS               : 91
EQUAL                : 29 50 79 82 86 86 87 91 91 91 94
FALSE                : 93
FIT                  : 91
FLOAT                : 7 39 96
FOR                  : 67
FUNCESP              : 
FUNCTION             : 10 11
GETWEIGHTS           : 97
GT                   : 28
GTE                  : 
ID                   : 1 10 11 19 20 55 56 57 58 79 82 86 87 91 94
IF                   : 61
INT                  : 3 5 6 38 86 91 95
LAYERS               : 86
LBRACE               : 12
LBRACKET             : 3 5 56 57 57 67 87 94
LPAREN               : 10 11 37 52 58 61 64 67 79 82 85 86 87 90 91 94 97
LT                   : 27
LTE                  : 
MATRIX               : 82
MEAN                 : 85
MINUS                : 33
MULT                 : 35
NUMPY                : 
OR                   : 22
PLUS                 : 32
PREDICT              : 94
PRINT                : 52
QUOTE                : 
RBRACE               : 12
RBRACKET             : 3 5 56 57 57 68 88 95 96
READ                 : 51
RPAREN               : 10 11 37 53 58 61 64 67 80 81 83 84 85 86 88 90 92 93 95 96 97
SEMICOLON            : 2 4 59 65 67 67
SEQUENTIAL           : 87
STRING               : 9
TRUE                 : 92
UNITS                : 86
VAR                  : 1
VERBOSE              : 91
VOID                 : 11
WHILE                : 64
error                : 

Nonterminals, with rules where they appear

array                : 70 82 84 85 91 91
arrayp               : 79
assign               : 42
body                 : 10 11
call                 : 41 43
callp                : 58 59
compile              : 75
decvar               : 13 15 0
decvarp              : 1 2
decvarpp             : 3
empty                : 
exp                  : 22 37 50 53 54 56 57 57 59 60 61 64 67 67
f                    : 34 35 36
fit                  : 76
fitp                 : 91
for                  : 48
forp                 : 67 69
funcesp              : 49
function             : 
getweights           : 78
gexp                 : 23 24
gexpp                : 26
if                   : 46
ifp                  : 61
layers               : 73 87 89 97
matrix               : 71
matrixp              : 82
mean                 : 72
mexp                 : 25 26 26 32 33
param                : 10 11 20
paramp               : 18
pbody                : 12 13 14
predict              : 77
predictp             : 94
print                : 45
printp               : 52 54
read                 : 44
sequential           : 74 90 91 94
sequentialp          : 87 89
statement            : 13 14 61 63 64 66 67 69
t                    : 31 32 33 35 36
texp                 : 21 22 24
type                 : 1 10 18
var                  : 40 50 51 67 79 81
voidfunction         : 
while                : 47
whilep               : 64 66

Parsing method: LALR

state 0

    (0) S' -> . decvar
    (1) decvar -> . VAR type ID decvarp

    VAR             shift and go to state 2

    decvar                         shift and go to state 1

state 1

    (0) S' -> decvar .



state 2

    (1) decvar -> VAR . type ID decvarp
    (6) type -> . INT
    (7) type -> . FLOAT
    (8) type -> . CHAR
    (9) type -> . STRING

    INT             shift and go to state 4
    FLOAT           shift and go to state 5
    CHAR            shift and go to state 6
    STRING          shift and go to state 7

    type                           shift and go to state 3

state 3

    (1) decvar -> VAR type . ID decvarp

    ID              shift and go to state 8


state 4

    (6) type -> INT .

    ID              reduce using rule 6 (type -> INT .)


state 5

    (7) type -> FLOAT .

    ID              reduce using rule 7 (type -> FLOAT .)


state 6

    (8) type -> CHAR .

    ID              reduce using rule 8 (type -> CHAR .)


state 7

    (9) type -> STRING .

    ID              reduce using rule 9 (type -> STRING .)


state 8

    (1) decvar -> VAR type ID . decvarp
    (2) decvarp -> . SEMICOLON decvarp
    (3) decvarp -> . LBRACKET INT RBRACKET decvarpp

    SEMICOLON       shift and go to state 10
    LBRACKET        shift and go to state 11

    decvarp                        shift and go to state 9

state 9

    (1) decvar -> VAR type ID decvarp .

    $end            reduce using rule 1 (decvar -> VAR type ID decvarp .)


state 10

    (2) decvarp -> SEMICOLON . decvarp
    (2) decvarp -> . SEMICOLON decvarp
    (3) decvarp -> . LBRACKET INT RBRACKET decvarpp

    SEMICOLON       shift and go to state 10
    LBRACKET        shift and go to state 11

    decvarp                        shift and go to state 12

state 11

    (3) decvarp -> LBRACKET . INT RBRACKET decvarpp

    INT             shift and go to state 13


state 12

    (2) decvarp -> SEMICOLON decvarp .

    $end            reduce using rule 2 (decvarp -> SEMICOLON decvarp .)


state 13

    (3) decvarp -> LBRACKET INT . RBRACKET decvarpp

    RBRACKET        shift and go to state 14


state 14

    (3) decvarp -> LBRACKET INT RBRACKET . decvarpp
    (4) decvarpp -> . SEMICOLON
    (5) decvarpp -> . LBRACKET INT RBRACKET

    SEMICOLON       shift and go to state 17
    LBRACKET        shift and go to state 15

    decvarpp                       shift and go to state 16

state 15

    (5) decvarpp -> LBRACKET . INT RBRACKET

    INT             shift and go to state 18


state 16

    (3) decvarp -> LBRACKET INT RBRACKET decvarpp .

    $end            reduce using rule 3 (decvarp -> LBRACKET INT RBRACKET decvarpp .)


state 17

    (4) decvarpp -> SEMICOLON .

    $end            reduce using rule 4 (decvarpp -> SEMICOLON .)


state 18

    (5) decvarpp -> LBRACKET INT . RBRACKET

    RBRACKET        shift and go to state 19


state 19

    (5) decvarpp -> LBRACKET INT RBRACKET .

    $end            reduce using rule 5 (decvarpp -> LBRACKET INT RBRACKET .)

