Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    ASSIGN
    CHAR
    COLON
    DOT
    END
    FALSE
    FUNCESP
    GTE
    LTE
    NUMPY
    QUOTE
    STRING
    TRUE
    VERBOSE

Grammar

Rule 0     S' -> program
Rule 1     program -> PROGRAM gotomain ID SEMICOLON decvar modules mainfunction
Rule 2     gotomain -> <empty>
Rule 3     decvar -> VAR decvarp
Rule 4     decvar -> VAR decvarp decvar
Rule 5     decvar -> <empty>
Rule 6     decvarp -> type decvarpp SEMICOLON
Rule 7     decvarpp -> ID COMMA decvarpp
Rule 8     decvarpp -> ID
Rule 9     type -> INT
Rule 10    type -> FLOAT
Rule 11    function -> FUNCTION decfunctype decfunc LPAREN param RPAREN LBRACE body RETURN exp SEMICOLON RBRACE
Rule 12    decfunctype -> type
Rule 13    decfunc -> ID
Rule 14    voidfunction -> FUNCTION VOID decfunc LPAREN param RPAREN LBRACE body RBRACE
Rule 15    decfuncmain -> <empty>
Rule 16    mainfunction -> MAIN decfuncmain LPAREN RPAREN LBRACE body RBRACE
Rule 17    modules -> function modules
Rule 18    modules -> voidfunction modules
Rule 19    modules -> function
Rule 20    modules -> voidfunction
Rule 21    modules -> <empty>
Rule 22    body -> decvar statements body
Rule 23    body -> statements body
Rule 24    body -> decvar
Rule 25    body -> <empty>
Rule 26    param -> type ID
Rule 27    param -> type ID COMMA param
Rule 28    param -> <empty>
Rule 29    exp -> texp
Rule 30    exp -> texp OR exp
Rule 31    texp -> gexp
Rule 32    texp -> gexp AND texp
Rule 33    gexp -> mexp
Rule 34    gexp -> mexp gexpp mexp
Rule 35    gexpp -> LT
Rule 36    gexpp -> GT
Rule 37    gexpp -> IFEQUAL
Rule 38    gexpp -> DIFF
Rule 39    mexp -> t
Rule 40    mexp -> mexp PLUS t
Rule 41    mexp -> mexp MINUS t
Rule 42    t -> f
Rule 43    t -> t MULT f
Rule 44    t -> t DIV f
Rule 45    f -> LPAREN exp RPAREN
Rule 46    f -> CTI
Rule 47    f -> CTF
Rule 48    f -> var
Rule 49    f -> call
Rule 50    statements -> assign
Rule 51    statements -> function
Rule 52    statements -> voidfunction
Rule 53    statements -> call
Rule 54    statements -> read
Rule 55    statements -> print
Rule 56    statements -> if
Rule 57    statements -> while
Rule 58    statements -> array
Rule 59    statements -> matrix
Rule 60    statements -> mean
Rule 61    statements -> layers
Rule 62    statements -> sequential
Rule 63    statements -> compile
Rule 64    statements -> fit
Rule 65    statements -> predict
Rule 66    statements -> getweights
Rule 67    statements -> fibonacci
Rule 68    statements -> factorial
Rule 69    statements -> mmult
Rule 70    assign -> var EQUAL exp SEMICOLON
Rule 71    read -> READ LPAREN var RPAREN SEMICOLON
Rule 72    print -> PRINT LPAREN printp SEMICOLON
Rule 73    printp -> exp RPAREN
Rule 74    printp -> exp COMMA printp
Rule 75    var -> ID
Rule 76    call -> ID LPAREN callp RPAREN
Rule 77    callp -> exp COMMA callp
Rule 78    callp -> exp
Rule 79    callp -> <empty>
Rule 80    if -> IF LPAREN ifexp RPAREN quadsIf LBRACE body RBRACE ifelse jumpsIf SEMICOLON
Rule 81    ifexp -> exp
Rule 82    ifelse -> <empty>
Rule 83    ifelse -> ELSE quadsElse LBRACE body RBRACE
Rule 84    quadsIf -> <empty>
Rule 85    jumpsIf -> <empty>
Rule 86    quadsElse -> <empty>
Rule 87    while -> WHILE saveJumps LPAREN whilexp RPAREN quadsWhile LBRACE body RBRACE jumpsWhile SEMICOLON
Rule 88    whilexp -> exp
Rule 89    saveJumps -> <empty>
Rule 90    quadsWhile -> <empty>
Rule 91    jumpsWhile -> <empty>
Rule 92    funcesp -> array
Rule 93    funcesp -> mean
Rule 94    funcesp -> layers
Rule 95    funcesp -> sequential
Rule 96    funcesp -> compile
Rule 97    funcesp -> fit
Rule 98    funcesp -> predict
Rule 99    funcesp -> getweights
Rule 100   array -> ARRAY ID LBRACKET exp RBRACKET EQUAL LBRACKET arrvalues RBRACKET SEMICOLON
Rule 101   arrvalues -> exp
Rule 102   arrvalues -> exp COMMA arrvalues
Rule 103   matrix -> MATRIX ID LBRACKET exp RBRACKET LBRACKET exp RBRACKET EQUAL LBRACKET matvalues RBRACKET SEMICOLON
Rule 104   matvalues -> exp
Rule 105   matvalues -> exp COMMA matvalues
Rule 106   mean -> MEAN LPAREN ID RPAREN SEMICOLON
Rule 107   layers -> LAYERS LPAREN UNITS EQUAL CTI RPAREN SEMICOLON
Rule 108   sequential -> SEQUENTIAL LPAREN RPAREN SEMICOLON
Rule 109   compile -> COMPILE LPAREN CTF RPAREN SEMICOLON
Rule 110   fit -> FIT LPAREN ID COMMA ID COMMA EPOCHS EQUAL CTI RPAREN SEMICOLON
Rule 111   predict -> PREDICT LPAREN CTF RPAREN SEMICOLON
Rule 112   getweights -> GETWEIGHTS LPAREN RPAREN SEMICOLON
Rule 113   fibonacci -> FIBONACCI LPAREN exp RPAREN SEMICOLON
Rule 114   factorial -> FACTORIAL LPAREN exp RPAREN SEMICOLON
Rule 115   mmult -> MMULT LPAREN ID COMMA ID RPAREN SEMICOLON
Rule 116   empty -> <empty>

Terminals, with rules where they appear

AND                  : 32
ARRAY                : 100
ASSIGN               : 
CHAR                 : 
COLON                : 
COMMA                : 7 27 74 77 102 105 110 110 115
COMPILE              : 109
CTF                  : 47 109 111
CTI                  : 46 107 110
DIFF                 : 38
DIV                  : 44
DOT                  : 
ELSE                 : 83
END                  : 
EPOCHS               : 110
EQUAL                : 70 100 103 107 110
FACTORIAL            : 114
FALSE                : 
FIBONACCI            : 113
FIT                  : 110
FLOAT                : 10
FUNCESP              : 
FUNCTION             : 11 14
GETWEIGHTS           : 112
GT                   : 36
GTE                  : 
ID                   : 1 7 8 13 26 27 75 76 100 103 106 110 110 115 115
IF                   : 80
IFEQUAL              : 37
INT                  : 9
LAYERS               : 107
LBRACE               : 11 14 16 80 83 87
LBRACKET             : 100 100 103 103 103
LPAREN               : 11 14 16 45 71 72 76 80 87 106 107 108 109 110 111 112 113 114 115
LT                   : 35
LTE                  : 
MAIN                 : 16
MATRIX               : 103
MEAN                 : 106
MINUS                : 41
MMULT                : 115
MULT                 : 43
NUMPY                : 
OR                   : 30
PLUS                 : 40
PREDICT              : 111
PRINT                : 72
PROGRAM              : 1
QUOTE                : 
RBRACE               : 11 14 16 80 83 87
RBRACKET             : 100 100 103 103 103
READ                 : 71
RETURN               : 11
RPAREN               : 11 14 16 45 71 73 76 80 87 106 107 108 109 110 111 112 113 114 115
SEMICOLON            : 1 6 11 70 71 72 80 87 100 103 106 107 108 109 110 111 112 113 114 115
SEQUENTIAL           : 108
STRING               : 
TRUE                 : 
UNITS                : 107
VAR                  : 3 4
VERBOSE              : 
VOID                 : 14
WHILE                : 87
error                : 

Nonterminals, with rules where they appear

array                : 58 92
arrvalues            : 100 102
assign               : 50
body                 : 11 14 16 22 23 80 83 87
call                 : 49 53
callp                : 76 77
compile              : 63 96
decfunc              : 11 14
decfuncmain          : 16
decfunctype          : 11
decvar               : 1 4 22 24
decvarp              : 3 4
decvarpp             : 6 7
empty                : 
exp                  : 11 30 45 70 73 74 77 78 81 88 100 101 102 103 103 104 105 113 114
f                    : 42 43 44
factorial            : 68
fibonacci            : 67
fit                  : 64 97
funcesp              : 
function             : 17 19 51
getweights           : 66 99
gexp                 : 31 32
gexpp                : 34
gotomain             : 1
if                   : 56
ifelse               : 80
ifexp                : 80
jumpsIf              : 80
jumpsWhile           : 87
layers               : 61 94
mainfunction         : 1
matrix               : 59
matvalues            : 103 105
mean                 : 60 93
mexp                 : 33 34 34 40 41
mmult                : 69
modules              : 1 17 18
param                : 11 14 27
predict              : 65 98
print                : 55
printp               : 72 74
program              : 0
quadsElse            : 83
quadsIf              : 80
quadsWhile           : 87
read                 : 54
saveJumps            : 87
sequential           : 62 95
statements           : 22 23
t                    : 39 40 41 43 44
texp                 : 29 30 32
type                 : 6 12 26 27
var                  : 48 70 71
voidfunction         : 18 20 52
while                : 57
whilexp              : 87

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . PROGRAM gotomain ID SEMICOLON decvar modules mainfunction

    PROGRAM         shift and go to state 2

    program                        shift and go to state 1

state 1

    (0) S' -> program .



state 2

    (1) program -> PROGRAM . gotomain ID SEMICOLON decvar modules mainfunction
    (2) gotomain -> .

    ID              reduce using rule 2 (gotomain -> .)

    gotomain                       shift and go to state 3

state 3

    (1) program -> PROGRAM gotomain . ID SEMICOLON decvar modules mainfunction

    ID              shift and go to state 4


state 4

    (1) program -> PROGRAM gotomain ID . SEMICOLON decvar modules mainfunction

    SEMICOLON       shift and go to state 5


state 5

    (1) program -> PROGRAM gotomain ID SEMICOLON . decvar modules mainfunction
    (3) decvar -> . VAR decvarp
    (4) decvar -> . VAR decvarp decvar
    (5) decvar -> .

    VAR             shift and go to state 7
    FUNCTION        reduce using rule 5 (decvar -> .)
    MAIN            reduce using rule 5 (decvar -> .)

    decvar                         shift and go to state 6

state 6

    (1) program -> PROGRAM gotomain ID SEMICOLON decvar . modules mainfunction
    (17) modules -> . function modules
    (18) modules -> . voidfunction modules
    (19) modules -> . function
    (20) modules -> . voidfunction
    (21) modules -> .
    (11) function -> . FUNCTION decfunctype decfunc LPAREN param RPAREN LBRACE body RETURN exp SEMICOLON RBRACE
    (14) voidfunction -> . FUNCTION VOID decfunc LPAREN param RPAREN LBRACE body RBRACE

    MAIN            reduce using rule 21 (modules -> .)
    FUNCTION        shift and go to state 11

    modules                        shift and go to state 8
    function                       shift and go to state 9
    voidfunction                   shift and go to state 10

state 7

    (3) decvar -> VAR . decvarp
    (4) decvar -> VAR . decvarp decvar
    (6) decvarp -> . type decvarpp SEMICOLON
    (9) type -> . INT
    (10) type -> . FLOAT

    INT             shift and go to state 14
    FLOAT           shift and go to state 15

    decvarp                        shift and go to state 12
    type                           shift and go to state 13

state 8

    (1) program -> PROGRAM gotomain ID SEMICOLON decvar modules . mainfunction
    (16) mainfunction -> . MAIN decfuncmain LPAREN RPAREN LBRACE body RBRACE

    MAIN            shift and go to state 17

    mainfunction                   shift and go to state 16

state 9

    (17) modules -> function . modules
    (19) modules -> function .
    (17) modules -> . function modules
    (18) modules -> . voidfunction modules
    (19) modules -> . function
    (20) modules -> . voidfunction
    (21) modules -> .
    (11) function -> . FUNCTION decfunctype decfunc LPAREN param RPAREN LBRACE body RETURN exp SEMICOLON RBRACE
    (14) voidfunction -> . FUNCTION VOID decfunc LPAREN param RPAREN LBRACE body RBRACE

  ! reduce/reduce conflict for MAIN resolved using rule 19 (modules -> function .)
    MAIN            reduce using rule 19 (modules -> function .)
    FUNCTION        shift and go to state 11

  ! MAIN            [ reduce using rule 21 (modules -> .) ]

    function                       shift and go to state 9
    modules                        shift and go to state 18
    voidfunction                   shift and go to state 10

state 10

    (18) modules -> voidfunction . modules
    (20) modules -> voidfunction .
    (17) modules -> . function modules
    (18) modules -> . voidfunction modules
    (19) modules -> . function
    (20) modules -> . voidfunction
    (21) modules -> .
    (11) function -> . FUNCTION decfunctype decfunc LPAREN param RPAREN LBRACE body RETURN exp SEMICOLON RBRACE
    (14) voidfunction -> . FUNCTION VOID decfunc LPAREN param RPAREN LBRACE body RBRACE

  ! reduce/reduce conflict for MAIN resolved using rule 20 (modules -> voidfunction .)
    MAIN            reduce using rule 20 (modules -> voidfunction .)
    FUNCTION        shift and go to state 11

  ! MAIN            [ reduce using rule 21 (modules -> .) ]

    voidfunction                   shift and go to state 10
    modules                        shift and go to state 19
    function                       shift and go to state 9

state 11

    (11) function -> FUNCTION . decfunctype decfunc LPAREN param RPAREN LBRACE body RETURN exp SEMICOLON RBRACE
    (14) voidfunction -> FUNCTION . VOID decfunc LPAREN param RPAREN LBRACE body RBRACE
    (12) decfunctype -> . type
    (9) type -> . INT
    (10) type -> . FLOAT

    VOID            shift and go to state 21
    INT             shift and go to state 14
    FLOAT           shift and go to state 15

    decfunctype                    shift and go to state 20
    type                           shift and go to state 22

state 12

    (3) decvar -> VAR decvarp .
    (4) decvar -> VAR decvarp . decvar
    (3) decvar -> . VAR decvarp
    (4) decvar -> . VAR decvarp decvar
    (5) decvar -> .

  ! reduce/reduce conflict for FUNCTION resolved using rule 3 (decvar -> VAR decvarp .)
  ! reduce/reduce conflict for MAIN resolved using rule 3 (decvar -> VAR decvarp .)
  ! reduce/reduce conflict for ID resolved using rule 3 (decvar -> VAR decvarp .)
  ! reduce/reduce conflict for READ resolved using rule 3 (decvar -> VAR decvarp .)
  ! reduce/reduce conflict for PRINT resolved using rule 3 (decvar -> VAR decvarp .)
  ! reduce/reduce conflict for IF resolved using rule 3 (decvar -> VAR decvarp .)
  ! reduce/reduce conflict for WHILE resolved using rule 3 (decvar -> VAR decvarp .)
  ! reduce/reduce conflict for ARRAY resolved using rule 3 (decvar -> VAR decvarp .)
  ! reduce/reduce conflict for MATRIX resolved using rule 3 (decvar -> VAR decvarp .)
  ! reduce/reduce conflict for MEAN resolved using rule 3 (decvar -> VAR decvarp .)
  ! reduce/reduce conflict for LAYERS resolved using rule 3 (decvar -> VAR decvarp .)
  ! reduce/reduce conflict for SEQUENTIAL resolved using rule 3 (decvar -> VAR decvarp .)
  ! reduce/reduce conflict for COMPILE resolved using rule 3 (decvar -> VAR decvarp .)
  ! reduce/reduce conflict for FIT resolved using rule 3 (decvar -> VAR decvarp .)
  ! reduce/reduce conflict for PREDICT resolved using rule 3 (decvar -> VAR decvarp .)
  ! reduce/reduce conflict for GETWEIGHTS resolved using rule 3 (decvar -> VAR decvarp .)
  ! reduce/reduce conflict for FIBONACCI resolved using rule 3 (decvar -> VAR decvarp .)
  ! reduce/reduce conflict for FACTORIAL resolved using rule 3 (decvar -> VAR decvarp .)
  ! reduce/reduce conflict for MMULT resolved using rule 3 (decvar -> VAR decvarp .)
  ! reduce/reduce conflict for RBRACE resolved using rule 3 (decvar -> VAR decvarp .)
  ! reduce/reduce conflict for RETURN resolved using rule 3 (decvar -> VAR decvarp .)
    FUNCTION        reduce using rule 3 (decvar -> VAR decvarp .)
    MAIN            reduce using rule 3 (decvar -> VAR decvarp .)
    ID              reduce using rule 3 (decvar -> VAR decvarp .)
    READ            reduce using rule 3 (decvar -> VAR decvarp .)
    PRINT           reduce using rule 3 (decvar -> VAR decvarp .)
    IF              reduce using rule 3 (decvar -> VAR decvarp .)
    WHILE           reduce using rule 3 (decvar -> VAR decvarp .)
    ARRAY           reduce using rule 3 (decvar -> VAR decvarp .)
    MATRIX          reduce using rule 3 (decvar -> VAR decvarp .)
    MEAN            reduce using rule 3 (decvar -> VAR decvarp .)
    LAYERS          reduce using rule 3 (decvar -> VAR decvarp .)
    SEQUENTIAL      reduce using rule 3 (decvar -> VAR decvarp .)
    COMPILE         reduce using rule 3 (decvar -> VAR decvarp .)
    FIT             reduce using rule 3 (decvar -> VAR decvarp .)
    PREDICT         reduce using rule 3 (decvar -> VAR decvarp .)
    GETWEIGHTS      reduce using rule 3 (decvar -> VAR decvarp .)
    FIBONACCI       reduce using rule 3 (decvar -> VAR decvarp .)
    FACTORIAL       reduce using rule 3 (decvar -> VAR decvarp .)
    MMULT           reduce using rule 3 (decvar -> VAR decvarp .)
    RBRACE          reduce using rule 3 (decvar -> VAR decvarp .)
    RETURN          reduce using rule 3 (decvar -> VAR decvarp .)
    VAR             shift and go to state 7

  ! FUNCTION        [ reduce using rule 5 (decvar -> .) ]
  ! MAIN            [ reduce using rule 5 (decvar -> .) ]
  ! ID              [ reduce using rule 5 (decvar -> .) ]
  ! READ            [ reduce using rule 5 (decvar -> .) ]
  ! PRINT           [ reduce using rule 5 (decvar -> .) ]
  ! IF              [ reduce using rule 5 (decvar -> .) ]
  ! WHILE           [ reduce using rule 5 (decvar -> .) ]
  ! ARRAY           [ reduce using rule 5 (decvar -> .) ]
  ! MATRIX          [ reduce using rule 5 (decvar -> .) ]
  ! MEAN            [ reduce using rule 5 (decvar -> .) ]
  ! LAYERS          [ reduce using rule 5 (decvar -> .) ]
  ! SEQUENTIAL      [ reduce using rule 5 (decvar -> .) ]
  ! COMPILE         [ reduce using rule 5 (decvar -> .) ]
  ! FIT             [ reduce using rule 5 (decvar -> .) ]
  ! PREDICT         [ reduce using rule 5 (decvar -> .) ]
  ! GETWEIGHTS      [ reduce using rule 5 (decvar -> .) ]
  ! FIBONACCI       [ reduce using rule 5 (decvar -> .) ]
  ! FACTORIAL       [ reduce using rule 5 (decvar -> .) ]
  ! MMULT           [ reduce using rule 5 (decvar -> .) ]
  ! RBRACE          [ reduce using rule 5 (decvar -> .) ]
  ! RETURN          [ reduce using rule 5 (decvar -> .) ]

    decvar                         shift and go to state 23

state 13

    (6) decvarp -> type . decvarpp SEMICOLON
    (7) decvarpp -> . ID COMMA decvarpp
    (8) decvarpp -> . ID

    ID              shift and go to state 25

    decvarpp                       shift and go to state 24

state 14

    (9) type -> INT .

    ID              reduce using rule 9 (type -> INT .)


state 15

    (10) type -> FLOAT .

    ID              reduce using rule 10 (type -> FLOAT .)


state 16

    (1) program -> PROGRAM gotomain ID SEMICOLON decvar modules mainfunction .

    $end            reduce using rule 1 (program -> PROGRAM gotomain ID SEMICOLON decvar modules mainfunction .)


state 17

    (16) mainfunction -> MAIN . decfuncmain LPAREN RPAREN LBRACE body RBRACE
    (15) decfuncmain -> .

    LPAREN          reduce using rule 15 (decfuncmain -> .)

    decfuncmain                    shift and go to state 26

state 18

    (17) modules -> function modules .

    MAIN            reduce using rule 17 (modules -> function modules .)


state 19

    (18) modules -> voidfunction modules .

    MAIN            reduce using rule 18 (modules -> voidfunction modules .)


state 20

    (11) function -> FUNCTION decfunctype . decfunc LPAREN param RPAREN LBRACE body RETURN exp SEMICOLON RBRACE
    (13) decfunc -> . ID

    ID              shift and go to state 28

    decfunc                        shift and go to state 27

state 21

    (14) voidfunction -> FUNCTION VOID . decfunc LPAREN param RPAREN LBRACE body RBRACE
    (13) decfunc -> . ID

    ID              shift and go to state 28

    decfunc                        shift and go to state 29

state 22

    (12) decfunctype -> type .

    ID              reduce using rule 12 (decfunctype -> type .)


state 23

    (4) decvar -> VAR decvarp decvar .

    FUNCTION        reduce using rule 4 (decvar -> VAR decvarp decvar .)
    MAIN            reduce using rule 4 (decvar -> VAR decvarp decvar .)
    ID              reduce using rule 4 (decvar -> VAR decvarp decvar .)
    READ            reduce using rule 4 (decvar -> VAR decvarp decvar .)
    PRINT           reduce using rule 4 (decvar -> VAR decvarp decvar .)
    IF              reduce using rule 4 (decvar -> VAR decvarp decvar .)
    WHILE           reduce using rule 4 (decvar -> VAR decvarp decvar .)
    ARRAY           reduce using rule 4 (decvar -> VAR decvarp decvar .)
    MATRIX          reduce using rule 4 (decvar -> VAR decvarp decvar .)
    MEAN            reduce using rule 4 (decvar -> VAR decvarp decvar .)
    LAYERS          reduce using rule 4 (decvar -> VAR decvarp decvar .)
    SEQUENTIAL      reduce using rule 4 (decvar -> VAR decvarp decvar .)
    COMPILE         reduce using rule 4 (decvar -> VAR decvarp decvar .)
    FIT             reduce using rule 4 (decvar -> VAR decvarp decvar .)
    PREDICT         reduce using rule 4 (decvar -> VAR decvarp decvar .)
    GETWEIGHTS      reduce using rule 4 (decvar -> VAR decvarp decvar .)
    FIBONACCI       reduce using rule 4 (decvar -> VAR decvarp decvar .)
    FACTORIAL       reduce using rule 4 (decvar -> VAR decvarp decvar .)
    MMULT           reduce using rule 4 (decvar -> VAR decvarp decvar .)
    RBRACE          reduce using rule 4 (decvar -> VAR decvarp decvar .)
    RETURN          reduce using rule 4 (decvar -> VAR decvarp decvar .)


state 24

    (6) decvarp -> type decvarpp . SEMICOLON

    SEMICOLON       shift and go to state 30


state 25

    (7) decvarpp -> ID . COMMA decvarpp
    (8) decvarpp -> ID .

    COMMA           shift and go to state 31
    SEMICOLON       reduce using rule 8 (decvarpp -> ID .)


state 26

    (16) mainfunction -> MAIN decfuncmain . LPAREN RPAREN LBRACE body RBRACE

    LPAREN          shift and go to state 32


state 27

    (11) function -> FUNCTION decfunctype decfunc . LPAREN param RPAREN LBRACE body RETURN exp SEMICOLON RBRACE

    LPAREN          shift and go to state 33


state 28

    (13) decfunc -> ID .

    LPAREN          reduce using rule 13 (decfunc -> ID .)


state 29

    (14) voidfunction -> FUNCTION VOID decfunc . LPAREN param RPAREN LBRACE body RBRACE

    LPAREN          shift and go to state 34


state 30

    (6) decvarp -> type decvarpp SEMICOLON .

    VAR             reduce using rule 6 (decvarp -> type decvarpp SEMICOLON .)
    FUNCTION        reduce using rule 6 (decvarp -> type decvarpp SEMICOLON .)
    MAIN            reduce using rule 6 (decvarp -> type decvarpp SEMICOLON .)
    ID              reduce using rule 6 (decvarp -> type decvarpp SEMICOLON .)
    READ            reduce using rule 6 (decvarp -> type decvarpp SEMICOLON .)
    PRINT           reduce using rule 6 (decvarp -> type decvarpp SEMICOLON .)
    IF              reduce using rule 6 (decvarp -> type decvarpp SEMICOLON .)
    WHILE           reduce using rule 6 (decvarp -> type decvarpp SEMICOLON .)
    ARRAY           reduce using rule 6 (decvarp -> type decvarpp SEMICOLON .)
    MATRIX          reduce using rule 6 (decvarp -> type decvarpp SEMICOLON .)
    MEAN            reduce using rule 6 (decvarp -> type decvarpp SEMICOLON .)
    LAYERS          reduce using rule 6 (decvarp -> type decvarpp SEMICOLON .)
    SEQUENTIAL      reduce using rule 6 (decvarp -> type decvarpp SEMICOLON .)
    COMPILE         reduce using rule 6 (decvarp -> type decvarpp SEMICOLON .)
    FIT             reduce using rule 6 (decvarp -> type decvarpp SEMICOLON .)
    PREDICT         reduce using rule 6 (decvarp -> type decvarpp SEMICOLON .)
    GETWEIGHTS      reduce using rule 6 (decvarp -> type decvarpp SEMICOLON .)
    FIBONACCI       reduce using rule 6 (decvarp -> type decvarpp SEMICOLON .)
    FACTORIAL       reduce using rule 6 (decvarp -> type decvarpp SEMICOLON .)
    MMULT           reduce using rule 6 (decvarp -> type decvarpp SEMICOLON .)
    RBRACE          reduce using rule 6 (decvarp -> type decvarpp SEMICOLON .)
    RETURN          reduce using rule 6 (decvarp -> type decvarpp SEMICOLON .)


state 31

    (7) decvarpp -> ID COMMA . decvarpp
    (7) decvarpp -> . ID COMMA decvarpp
    (8) decvarpp -> . ID

    ID              shift and go to state 25

    decvarpp                       shift and go to state 35

state 32

    (16) mainfunction -> MAIN decfuncmain LPAREN . RPAREN LBRACE body RBRACE

    RPAREN          shift and go to state 36


state 33

    (11) function -> FUNCTION decfunctype decfunc LPAREN . param RPAREN LBRACE body RETURN exp SEMICOLON RBRACE
    (26) param -> . type ID
    (27) param -> . type ID COMMA param
    (28) param -> .
    (9) type -> . INT
    (10) type -> . FLOAT

    RPAREN          reduce using rule 28 (param -> .)
    INT             shift and go to state 14
    FLOAT           shift and go to state 15

    param                          shift and go to state 37
    type                           shift and go to state 38

state 34

    (14) voidfunction -> FUNCTION VOID decfunc LPAREN . param RPAREN LBRACE body RBRACE
    (26) param -> . type ID
    (27) param -> . type ID COMMA param
    (28) param -> .
    (9) type -> . INT
    (10) type -> . FLOAT

    RPAREN          reduce using rule 28 (param -> .)
    INT             shift and go to state 14
    FLOAT           shift and go to state 15

    param                          shift and go to state 39
    type                           shift and go to state 38

state 35

    (7) decvarpp -> ID COMMA decvarpp .

    SEMICOLON       reduce using rule 7 (decvarpp -> ID COMMA decvarpp .)


state 36

    (16) mainfunction -> MAIN decfuncmain LPAREN RPAREN . LBRACE body RBRACE

    LBRACE          shift and go to state 40


state 37

    (11) function -> FUNCTION decfunctype decfunc LPAREN param . RPAREN LBRACE body RETURN exp SEMICOLON RBRACE

    RPAREN          shift and go to state 41


state 38

    (26) param -> type . ID
    (27) param -> type . ID COMMA param

    ID              shift and go to state 42


state 39

    (14) voidfunction -> FUNCTION VOID decfunc LPAREN param . RPAREN LBRACE body RBRACE

    RPAREN          shift and go to state 43


state 40

    (16) mainfunction -> MAIN decfuncmain LPAREN RPAREN LBRACE . body RBRACE
    (22) body -> . decvar statements body
    (23) body -> . statements body
    (24) body -> . decvar
    (25) body -> .
    (3) decvar -> . VAR decvarp
    (4) decvar -> . VAR decvarp decvar
    (5) decvar -> .
    (50) statements -> . assign
    (51) statements -> . function
    (52) statements -> . voidfunction
    (53) statements -> . call
    (54) statements -> . read
    (55) statements -> . print
    (56) statements -> . if
    (57) statements -> . while
    (58) statements -> . array
    (59) statements -> . matrix
    (60) statements -> . mean
    (61) statements -> . layers
    (62) statements -> . sequential
    (63) statements -> . compile
    (64) statements -> . fit
    (65) statements -> . predict
    (66) statements -> . getweights
    (67) statements -> . fibonacci
    (68) statements -> . factorial
    (69) statements -> . mmult
    (70) assign -> . var EQUAL exp SEMICOLON
    (11) function -> . FUNCTION decfunctype decfunc LPAREN param RPAREN LBRACE body RETURN exp SEMICOLON RBRACE
    (14) voidfunction -> . FUNCTION VOID decfunc LPAREN param RPAREN LBRACE body RBRACE
    (76) call -> . ID LPAREN callp RPAREN
    (71) read -> . READ LPAREN var RPAREN SEMICOLON
    (72) print -> . PRINT LPAREN printp SEMICOLON
    (80) if -> . IF LPAREN ifexp RPAREN quadsIf LBRACE body RBRACE ifelse jumpsIf SEMICOLON
    (87) while -> . WHILE saveJumps LPAREN whilexp RPAREN quadsWhile LBRACE body RBRACE jumpsWhile SEMICOLON
    (100) array -> . ARRAY ID LBRACKET exp RBRACKET EQUAL LBRACKET arrvalues RBRACKET SEMICOLON
    (103) matrix -> . MATRIX ID LBRACKET exp RBRACKET LBRACKET exp RBRACKET EQUAL LBRACKET matvalues RBRACKET SEMICOLON
    (106) mean -> . MEAN LPAREN ID RPAREN SEMICOLON
    (107) layers -> . LAYERS LPAREN UNITS EQUAL CTI RPAREN SEMICOLON
    (108) sequential -> . SEQUENTIAL LPAREN RPAREN SEMICOLON
    (109) compile -> . COMPILE LPAREN CTF RPAREN SEMICOLON
    (110) fit -> . FIT LPAREN ID COMMA ID COMMA EPOCHS EQUAL CTI RPAREN SEMICOLON
    (111) predict -> . PREDICT LPAREN CTF RPAREN SEMICOLON
    (112) getweights -> . GETWEIGHTS LPAREN RPAREN SEMICOLON
    (113) fibonacci -> . FIBONACCI LPAREN exp RPAREN SEMICOLON
    (114) factorial -> . FACTORIAL LPAREN exp RPAREN SEMICOLON
    (115) mmult -> . MMULT LPAREN ID COMMA ID RPAREN SEMICOLON
    (75) var -> . ID

  ! reduce/reduce conflict for RBRACE resolved using rule 5 (decvar -> .)
  ! shift/reduce conflict for FUNCTION resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for READ resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for ARRAY resolved as shift
  ! shift/reduce conflict for MATRIX resolved as shift
  ! shift/reduce conflict for MEAN resolved as shift
  ! shift/reduce conflict for LAYERS resolved as shift
  ! shift/reduce conflict for SEQUENTIAL resolved as shift
  ! shift/reduce conflict for COMPILE resolved as shift
  ! shift/reduce conflict for FIT resolved as shift
  ! shift/reduce conflict for PREDICT resolved as shift
  ! shift/reduce conflict for GETWEIGHTS resolved as shift
  ! shift/reduce conflict for FIBONACCI resolved as shift
  ! shift/reduce conflict for FACTORIAL resolved as shift
  ! shift/reduce conflict for MMULT resolved as shift
    VAR             shift and go to state 7
    RBRACE          reduce using rule 5 (decvar -> .)
    FUNCTION        shift and go to state 11
    ID              shift and go to state 68
    READ            shift and go to state 69
    PRINT           shift and go to state 70
    IF              shift and go to state 71
    WHILE           shift and go to state 72
    ARRAY           shift and go to state 73
    MATRIX          shift and go to state 74
    MEAN            shift and go to state 75
    LAYERS          shift and go to state 76
    SEQUENTIAL      shift and go to state 77
    COMPILE         shift and go to state 78
    FIT             shift and go to state 79
    PREDICT         shift and go to state 80
    GETWEIGHTS      shift and go to state 81
    FIBONACCI       shift and go to state 82
    FACTORIAL       shift and go to state 83
    MMULT           shift and go to state 84

  ! RBRACE          [ reduce using rule 25 (body -> .) ]
  ! FUNCTION        [ reduce using rule 5 (decvar -> .) ]
  ! ID              [ reduce using rule 5 (decvar -> .) ]
  ! READ            [ reduce using rule 5 (decvar -> .) ]
  ! PRINT           [ reduce using rule 5 (decvar -> .) ]
  ! IF              [ reduce using rule 5 (decvar -> .) ]
  ! WHILE           [ reduce using rule 5 (decvar -> .) ]
  ! ARRAY           [ reduce using rule 5 (decvar -> .) ]
  ! MATRIX          [ reduce using rule 5 (decvar -> .) ]
  ! MEAN            [ reduce using rule 5 (decvar -> .) ]
  ! LAYERS          [ reduce using rule 5 (decvar -> .) ]
  ! SEQUENTIAL      [ reduce using rule 5 (decvar -> .) ]
  ! COMPILE         [ reduce using rule 5 (decvar -> .) ]
  ! FIT             [ reduce using rule 5 (decvar -> .) ]
  ! PREDICT         [ reduce using rule 5 (decvar -> .) ]
  ! GETWEIGHTS      [ reduce using rule 5 (decvar -> .) ]
  ! FIBONACCI       [ reduce using rule 5 (decvar -> .) ]
  ! FACTORIAL       [ reduce using rule 5 (decvar -> .) ]
  ! MMULT           [ reduce using rule 5 (decvar -> .) ]

    body                           shift and go to state 44
    decvar                         shift and go to state 45
    statements                     shift and go to state 46
    assign                         shift and go to state 47
    function                       shift and go to state 48
    voidfunction                   shift and go to state 49
    call                           shift and go to state 50
    read                           shift and go to state 51
    print                          shift and go to state 52
    if                             shift and go to state 53
    while                          shift and go to state 54
    array                          shift and go to state 55
    matrix                         shift and go to state 56
    mean                           shift and go to state 57
    layers                         shift and go to state 58
    sequential                     shift and go to state 59
    compile                        shift and go to state 60
    fit                            shift and go to state 61
    predict                        shift and go to state 62
    getweights                     shift and go to state 63
    fibonacci                      shift and go to state 64
    factorial                      shift and go to state 65
    mmult                          shift and go to state 66
    var                            shift and go to state 67

state 41

    (11) function -> FUNCTION decfunctype decfunc LPAREN param RPAREN . LBRACE body RETURN exp SEMICOLON RBRACE

    LBRACE          shift and go to state 85


state 42

    (26) param -> type ID .
    (27) param -> type ID . COMMA param

    RPAREN          reduce using rule 26 (param -> type ID .)
    COMMA           shift and go to state 86


state 43

    (14) voidfunction -> FUNCTION VOID decfunc LPAREN param RPAREN . LBRACE body RBRACE

    LBRACE          shift and go to state 87


state 44

    (16) mainfunction -> MAIN decfuncmain LPAREN RPAREN LBRACE body . RBRACE

    RBRACE          shift and go to state 88


state 45

    (22) body -> decvar . statements body
    (24) body -> decvar .
    (50) statements -> . assign
    (51) statements -> . function
    (52) statements -> . voidfunction
    (53) statements -> . call
    (54) statements -> . read
    (55) statements -> . print
    (56) statements -> . if
    (57) statements -> . while
    (58) statements -> . array
    (59) statements -> . matrix
    (60) statements -> . mean
    (61) statements -> . layers
    (62) statements -> . sequential
    (63) statements -> . compile
    (64) statements -> . fit
    (65) statements -> . predict
    (66) statements -> . getweights
    (67) statements -> . fibonacci
    (68) statements -> . factorial
    (69) statements -> . mmult
    (70) assign -> . var EQUAL exp SEMICOLON
    (11) function -> . FUNCTION decfunctype decfunc LPAREN param RPAREN LBRACE body RETURN exp SEMICOLON RBRACE
    (14) voidfunction -> . FUNCTION VOID decfunc LPAREN param RPAREN LBRACE body RBRACE
    (76) call -> . ID LPAREN callp RPAREN
    (71) read -> . READ LPAREN var RPAREN SEMICOLON
    (72) print -> . PRINT LPAREN printp SEMICOLON
    (80) if -> . IF LPAREN ifexp RPAREN quadsIf LBRACE body RBRACE ifelse jumpsIf SEMICOLON
    (87) while -> . WHILE saveJumps LPAREN whilexp RPAREN quadsWhile LBRACE body RBRACE jumpsWhile SEMICOLON
    (100) array -> . ARRAY ID LBRACKET exp RBRACKET EQUAL LBRACKET arrvalues RBRACKET SEMICOLON
    (103) matrix -> . MATRIX ID LBRACKET exp RBRACKET LBRACKET exp RBRACKET EQUAL LBRACKET matvalues RBRACKET SEMICOLON
    (106) mean -> . MEAN LPAREN ID RPAREN SEMICOLON
    (107) layers -> . LAYERS LPAREN UNITS EQUAL CTI RPAREN SEMICOLON
    (108) sequential -> . SEQUENTIAL LPAREN RPAREN SEMICOLON
    (109) compile -> . COMPILE LPAREN CTF RPAREN SEMICOLON
    (110) fit -> . FIT LPAREN ID COMMA ID COMMA EPOCHS EQUAL CTI RPAREN SEMICOLON
    (111) predict -> . PREDICT LPAREN CTF RPAREN SEMICOLON
    (112) getweights -> . GETWEIGHTS LPAREN RPAREN SEMICOLON
    (113) fibonacci -> . FIBONACCI LPAREN exp RPAREN SEMICOLON
    (114) factorial -> . FACTORIAL LPAREN exp RPAREN SEMICOLON
    (115) mmult -> . MMULT LPAREN ID COMMA ID RPAREN SEMICOLON
    (75) var -> . ID

    RBRACE          reduce using rule 24 (body -> decvar .)
    RETURN          reduce using rule 24 (body -> decvar .)
    FUNCTION        shift and go to state 11
    ID              shift and go to state 68
    READ            shift and go to state 69
    PRINT           shift and go to state 70
    IF              shift and go to state 71
    WHILE           shift and go to state 72
    ARRAY           shift and go to state 73
    MATRIX          shift and go to state 74
    MEAN            shift and go to state 75
    LAYERS          shift and go to state 76
    SEQUENTIAL      shift and go to state 77
    COMPILE         shift and go to state 78
    FIT             shift and go to state 79
    PREDICT         shift and go to state 80
    GETWEIGHTS      shift and go to state 81
    FIBONACCI       shift and go to state 82
    FACTORIAL       shift and go to state 83
    MMULT           shift and go to state 84

    statements                     shift and go to state 89
    assign                         shift and go to state 47
    function                       shift and go to state 48
    voidfunction                   shift and go to state 49
    call                           shift and go to state 50
    read                           shift and go to state 51
    print                          shift and go to state 52
    if                             shift and go to state 53
    while                          shift and go to state 54
    array                          shift and go to state 55
    matrix                         shift and go to state 56
    mean                           shift and go to state 57
    layers                         shift and go to state 58
    sequential                     shift and go to state 59
    compile                        shift and go to state 60
    fit                            shift and go to state 61
    predict                        shift and go to state 62
    getweights                     shift and go to state 63
    fibonacci                      shift and go to state 64
    factorial                      shift and go to state 65
    mmult                          shift and go to state 66
    var                            shift and go to state 67

state 46

    (23) body -> statements . body
    (22) body -> . decvar statements body
    (23) body -> . statements body
    (24) body -> . decvar
    (25) body -> .
    (3) decvar -> . VAR decvarp
    (4) decvar -> . VAR decvarp decvar
    (5) decvar -> .
    (50) statements -> . assign
    (51) statements -> . function
    (52) statements -> . voidfunction
    (53) statements -> . call
    (54) statements -> . read
    (55) statements -> . print
    (56) statements -> . if
    (57) statements -> . while
    (58) statements -> . array
    (59) statements -> . matrix
    (60) statements -> . mean
    (61) statements -> . layers
    (62) statements -> . sequential
    (63) statements -> . compile
    (64) statements -> . fit
    (65) statements -> . predict
    (66) statements -> . getweights
    (67) statements -> . fibonacci
    (68) statements -> . factorial
    (69) statements -> . mmult
    (70) assign -> . var EQUAL exp SEMICOLON
    (11) function -> . FUNCTION decfunctype decfunc LPAREN param RPAREN LBRACE body RETURN exp SEMICOLON RBRACE
    (14) voidfunction -> . FUNCTION VOID decfunc LPAREN param RPAREN LBRACE body RBRACE
    (76) call -> . ID LPAREN callp RPAREN
    (71) read -> . READ LPAREN var RPAREN SEMICOLON
    (72) print -> . PRINT LPAREN printp SEMICOLON
    (80) if -> . IF LPAREN ifexp RPAREN quadsIf LBRACE body RBRACE ifelse jumpsIf SEMICOLON
    (87) while -> . WHILE saveJumps LPAREN whilexp RPAREN quadsWhile LBRACE body RBRACE jumpsWhile SEMICOLON
    (100) array -> . ARRAY ID LBRACKET exp RBRACKET EQUAL LBRACKET arrvalues RBRACKET SEMICOLON
    (103) matrix -> . MATRIX ID LBRACKET exp RBRACKET LBRACKET exp RBRACKET EQUAL LBRACKET matvalues RBRACKET SEMICOLON
    (106) mean -> . MEAN LPAREN ID RPAREN SEMICOLON
    (107) layers -> . LAYERS LPAREN UNITS EQUAL CTI RPAREN SEMICOLON
    (108) sequential -> . SEQUENTIAL LPAREN RPAREN SEMICOLON
    (109) compile -> . COMPILE LPAREN CTF RPAREN SEMICOLON
    (110) fit -> . FIT LPAREN ID COMMA ID COMMA EPOCHS EQUAL CTI RPAREN SEMICOLON
    (111) predict -> . PREDICT LPAREN CTF RPAREN SEMICOLON
    (112) getweights -> . GETWEIGHTS LPAREN RPAREN SEMICOLON
    (113) fibonacci -> . FIBONACCI LPAREN exp RPAREN SEMICOLON
    (114) factorial -> . FACTORIAL LPAREN exp RPAREN SEMICOLON
    (115) mmult -> . MMULT LPAREN ID COMMA ID RPAREN SEMICOLON
    (75) var -> . ID

  ! reduce/reduce conflict for RBRACE resolved using rule 5 (decvar -> .)
  ! reduce/reduce conflict for RETURN resolved using rule 5 (decvar -> .)
  ! shift/reduce conflict for FUNCTION resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for READ resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for ARRAY resolved as shift
  ! shift/reduce conflict for MATRIX resolved as shift
  ! shift/reduce conflict for MEAN resolved as shift
  ! shift/reduce conflict for LAYERS resolved as shift
  ! shift/reduce conflict for SEQUENTIAL resolved as shift
  ! shift/reduce conflict for COMPILE resolved as shift
  ! shift/reduce conflict for FIT resolved as shift
  ! shift/reduce conflict for PREDICT resolved as shift
  ! shift/reduce conflict for GETWEIGHTS resolved as shift
  ! shift/reduce conflict for FIBONACCI resolved as shift
  ! shift/reduce conflict for FACTORIAL resolved as shift
  ! shift/reduce conflict for MMULT resolved as shift
    VAR             shift and go to state 7
    RBRACE          reduce using rule 5 (decvar -> .)
    RETURN          reduce using rule 5 (decvar -> .)
    FUNCTION        shift and go to state 11
    ID              shift and go to state 68
    READ            shift and go to state 69
    PRINT           shift and go to state 70
    IF              shift and go to state 71
    WHILE           shift and go to state 72
    ARRAY           shift and go to state 73
    MATRIX          shift and go to state 74
    MEAN            shift and go to state 75
    LAYERS          shift and go to state 76
    SEQUENTIAL      shift and go to state 77
    COMPILE         shift and go to state 78
    FIT             shift and go to state 79
    PREDICT         shift and go to state 80
    GETWEIGHTS      shift and go to state 81
    FIBONACCI       shift and go to state 82
    FACTORIAL       shift and go to state 83
    MMULT           shift and go to state 84

  ! RBRACE          [ reduce using rule 25 (body -> .) ]
  ! RETURN          [ reduce using rule 25 (body -> .) ]
  ! FUNCTION        [ reduce using rule 5 (decvar -> .) ]
  ! ID              [ reduce using rule 5 (decvar -> .) ]
  ! READ            [ reduce using rule 5 (decvar -> .) ]
  ! PRINT           [ reduce using rule 5 (decvar -> .) ]
  ! IF              [ reduce using rule 5 (decvar -> .) ]
  ! WHILE           [ reduce using rule 5 (decvar -> .) ]
  ! ARRAY           [ reduce using rule 5 (decvar -> .) ]
  ! MATRIX          [ reduce using rule 5 (decvar -> .) ]
  ! MEAN            [ reduce using rule 5 (decvar -> .) ]
  ! LAYERS          [ reduce using rule 5 (decvar -> .) ]
  ! SEQUENTIAL      [ reduce using rule 5 (decvar -> .) ]
  ! COMPILE         [ reduce using rule 5 (decvar -> .) ]
  ! FIT             [ reduce using rule 5 (decvar -> .) ]
  ! PREDICT         [ reduce using rule 5 (decvar -> .) ]
  ! GETWEIGHTS      [ reduce using rule 5 (decvar -> .) ]
  ! FIBONACCI       [ reduce using rule 5 (decvar -> .) ]
  ! FACTORIAL       [ reduce using rule 5 (decvar -> .) ]
  ! MMULT           [ reduce using rule 5 (decvar -> .) ]

    statements                     shift and go to state 46
    body                           shift and go to state 90
    decvar                         shift and go to state 45
    assign                         shift and go to state 47
    function                       shift and go to state 48
    voidfunction                   shift and go to state 49
    call                           shift and go to state 50
    read                           shift and go to state 51
    print                          shift and go to state 52
    if                             shift and go to state 53
    while                          shift and go to state 54
    array                          shift and go to state 55
    matrix                         shift and go to state 56
    mean                           shift and go to state 57
    layers                         shift and go to state 58
    sequential                     shift and go to state 59
    compile                        shift and go to state 60
    fit                            shift and go to state 61
    predict                        shift and go to state 62
    getweights                     shift and go to state 63
    fibonacci                      shift and go to state 64
    factorial                      shift and go to state 65
    mmult                          shift and go to state 66
    var                            shift and go to state 67

state 47

    (50) statements -> assign .

    VAR             reduce using rule 50 (statements -> assign .)
    FUNCTION        reduce using rule 50 (statements -> assign .)
    ID              reduce using rule 50 (statements -> assign .)
    READ            reduce using rule 50 (statements -> assign .)
    PRINT           reduce using rule 50 (statements -> assign .)
    IF              reduce using rule 50 (statements -> assign .)
    WHILE           reduce using rule 50 (statements -> assign .)
    ARRAY           reduce using rule 50 (statements -> assign .)
    MATRIX          reduce using rule 50 (statements -> assign .)
    MEAN            reduce using rule 50 (statements -> assign .)
    LAYERS          reduce using rule 50 (statements -> assign .)
    SEQUENTIAL      reduce using rule 50 (statements -> assign .)
    COMPILE         reduce using rule 50 (statements -> assign .)
    FIT             reduce using rule 50 (statements -> assign .)
    PREDICT         reduce using rule 50 (statements -> assign .)
    GETWEIGHTS      reduce using rule 50 (statements -> assign .)
    FIBONACCI       reduce using rule 50 (statements -> assign .)
    FACTORIAL       reduce using rule 50 (statements -> assign .)
    MMULT           reduce using rule 50 (statements -> assign .)
    RBRACE          reduce using rule 50 (statements -> assign .)
    RETURN          reduce using rule 50 (statements -> assign .)


state 48

    (51) statements -> function .

    VAR             reduce using rule 51 (statements -> function .)
    FUNCTION        reduce using rule 51 (statements -> function .)
    ID              reduce using rule 51 (statements -> function .)
    READ            reduce using rule 51 (statements -> function .)
    PRINT           reduce using rule 51 (statements -> function .)
    IF              reduce using rule 51 (statements -> function .)
    WHILE           reduce using rule 51 (statements -> function .)
    ARRAY           reduce using rule 51 (statements -> function .)
    MATRIX          reduce using rule 51 (statements -> function .)
    MEAN            reduce using rule 51 (statements -> function .)
    LAYERS          reduce using rule 51 (statements -> function .)
    SEQUENTIAL      reduce using rule 51 (statements -> function .)
    COMPILE         reduce using rule 51 (statements -> function .)
    FIT             reduce using rule 51 (statements -> function .)
    PREDICT         reduce using rule 51 (statements -> function .)
    GETWEIGHTS      reduce using rule 51 (statements -> function .)
    FIBONACCI       reduce using rule 51 (statements -> function .)
    FACTORIAL       reduce using rule 51 (statements -> function .)
    MMULT           reduce using rule 51 (statements -> function .)
    RBRACE          reduce using rule 51 (statements -> function .)
    RETURN          reduce using rule 51 (statements -> function .)


state 49

    (52) statements -> voidfunction .

    VAR             reduce using rule 52 (statements -> voidfunction .)
    FUNCTION        reduce using rule 52 (statements -> voidfunction .)
    ID              reduce using rule 52 (statements -> voidfunction .)
    READ            reduce using rule 52 (statements -> voidfunction .)
    PRINT           reduce using rule 52 (statements -> voidfunction .)
    IF              reduce using rule 52 (statements -> voidfunction .)
    WHILE           reduce using rule 52 (statements -> voidfunction .)
    ARRAY           reduce using rule 52 (statements -> voidfunction .)
    MATRIX          reduce using rule 52 (statements -> voidfunction .)
    MEAN            reduce using rule 52 (statements -> voidfunction .)
    LAYERS          reduce using rule 52 (statements -> voidfunction .)
    SEQUENTIAL      reduce using rule 52 (statements -> voidfunction .)
    COMPILE         reduce using rule 52 (statements -> voidfunction .)
    FIT             reduce using rule 52 (statements -> voidfunction .)
    PREDICT         reduce using rule 52 (statements -> voidfunction .)
    GETWEIGHTS      reduce using rule 52 (statements -> voidfunction .)
    FIBONACCI       reduce using rule 52 (statements -> voidfunction .)
    FACTORIAL       reduce using rule 52 (statements -> voidfunction .)
    MMULT           reduce using rule 52 (statements -> voidfunction .)
    RBRACE          reduce using rule 52 (statements -> voidfunction .)
    RETURN          reduce using rule 52 (statements -> voidfunction .)


state 50

    (53) statements -> call .

    VAR             reduce using rule 53 (statements -> call .)
    FUNCTION        reduce using rule 53 (statements -> call .)
    ID              reduce using rule 53 (statements -> call .)
    READ            reduce using rule 53 (statements -> call .)
    PRINT           reduce using rule 53 (statements -> call .)
    IF              reduce using rule 53 (statements -> call .)
    WHILE           reduce using rule 53 (statements -> call .)
    ARRAY           reduce using rule 53 (statements -> call .)
    MATRIX          reduce using rule 53 (statements -> call .)
    MEAN            reduce using rule 53 (statements -> call .)
    LAYERS          reduce using rule 53 (statements -> call .)
    SEQUENTIAL      reduce using rule 53 (statements -> call .)
    COMPILE         reduce using rule 53 (statements -> call .)
    FIT             reduce using rule 53 (statements -> call .)
    PREDICT         reduce using rule 53 (statements -> call .)
    GETWEIGHTS      reduce using rule 53 (statements -> call .)
    FIBONACCI       reduce using rule 53 (statements -> call .)
    FACTORIAL       reduce using rule 53 (statements -> call .)
    MMULT           reduce using rule 53 (statements -> call .)
    RBRACE          reduce using rule 53 (statements -> call .)
    RETURN          reduce using rule 53 (statements -> call .)


state 51

    (54) statements -> read .

    VAR             reduce using rule 54 (statements -> read .)
    FUNCTION        reduce using rule 54 (statements -> read .)
    ID              reduce using rule 54 (statements -> read .)
    READ            reduce using rule 54 (statements -> read .)
    PRINT           reduce using rule 54 (statements -> read .)
    IF              reduce using rule 54 (statements -> read .)
    WHILE           reduce using rule 54 (statements -> read .)
    ARRAY           reduce using rule 54 (statements -> read .)
    MATRIX          reduce using rule 54 (statements -> read .)
    MEAN            reduce using rule 54 (statements -> read .)
    LAYERS          reduce using rule 54 (statements -> read .)
    SEQUENTIAL      reduce using rule 54 (statements -> read .)
    COMPILE         reduce using rule 54 (statements -> read .)
    FIT             reduce using rule 54 (statements -> read .)
    PREDICT         reduce using rule 54 (statements -> read .)
    GETWEIGHTS      reduce using rule 54 (statements -> read .)
    FIBONACCI       reduce using rule 54 (statements -> read .)
    FACTORIAL       reduce using rule 54 (statements -> read .)
    MMULT           reduce using rule 54 (statements -> read .)
    RBRACE          reduce using rule 54 (statements -> read .)
    RETURN          reduce using rule 54 (statements -> read .)


state 52

    (55) statements -> print .

    VAR             reduce using rule 55 (statements -> print .)
    FUNCTION        reduce using rule 55 (statements -> print .)
    ID              reduce using rule 55 (statements -> print .)
    READ            reduce using rule 55 (statements -> print .)
    PRINT           reduce using rule 55 (statements -> print .)
    IF              reduce using rule 55 (statements -> print .)
    WHILE           reduce using rule 55 (statements -> print .)
    ARRAY           reduce using rule 55 (statements -> print .)
    MATRIX          reduce using rule 55 (statements -> print .)
    MEAN            reduce using rule 55 (statements -> print .)
    LAYERS          reduce using rule 55 (statements -> print .)
    SEQUENTIAL      reduce using rule 55 (statements -> print .)
    COMPILE         reduce using rule 55 (statements -> print .)
    FIT             reduce using rule 55 (statements -> print .)
    PREDICT         reduce using rule 55 (statements -> print .)
    GETWEIGHTS      reduce using rule 55 (statements -> print .)
    FIBONACCI       reduce using rule 55 (statements -> print .)
    FACTORIAL       reduce using rule 55 (statements -> print .)
    MMULT           reduce using rule 55 (statements -> print .)
    RBRACE          reduce using rule 55 (statements -> print .)
    RETURN          reduce using rule 55 (statements -> print .)


state 53

    (56) statements -> if .

    VAR             reduce using rule 56 (statements -> if .)
    FUNCTION        reduce using rule 56 (statements -> if .)
    ID              reduce using rule 56 (statements -> if .)
    READ            reduce using rule 56 (statements -> if .)
    PRINT           reduce using rule 56 (statements -> if .)
    IF              reduce using rule 56 (statements -> if .)
    WHILE           reduce using rule 56 (statements -> if .)
    ARRAY           reduce using rule 56 (statements -> if .)
    MATRIX          reduce using rule 56 (statements -> if .)
    MEAN            reduce using rule 56 (statements -> if .)
    LAYERS          reduce using rule 56 (statements -> if .)
    SEQUENTIAL      reduce using rule 56 (statements -> if .)
    COMPILE         reduce using rule 56 (statements -> if .)
    FIT             reduce using rule 56 (statements -> if .)
    PREDICT         reduce using rule 56 (statements -> if .)
    GETWEIGHTS      reduce using rule 56 (statements -> if .)
    FIBONACCI       reduce using rule 56 (statements -> if .)
    FACTORIAL       reduce using rule 56 (statements -> if .)
    MMULT           reduce using rule 56 (statements -> if .)
    RBRACE          reduce using rule 56 (statements -> if .)
    RETURN          reduce using rule 56 (statements -> if .)


state 54

    (57) statements -> while .

    VAR             reduce using rule 57 (statements -> while .)
    FUNCTION        reduce using rule 57 (statements -> while .)
    ID              reduce using rule 57 (statements -> while .)
    READ            reduce using rule 57 (statements -> while .)
    PRINT           reduce using rule 57 (statements -> while .)
    IF              reduce using rule 57 (statements -> while .)
    WHILE           reduce using rule 57 (statements -> while .)
    ARRAY           reduce using rule 57 (statements -> while .)
    MATRIX          reduce using rule 57 (statements -> while .)
    MEAN            reduce using rule 57 (statements -> while .)
    LAYERS          reduce using rule 57 (statements -> while .)
    SEQUENTIAL      reduce using rule 57 (statements -> while .)
    COMPILE         reduce using rule 57 (statements -> while .)
    FIT             reduce using rule 57 (statements -> while .)
    PREDICT         reduce using rule 57 (statements -> while .)
    GETWEIGHTS      reduce using rule 57 (statements -> while .)
    FIBONACCI       reduce using rule 57 (statements -> while .)
    FACTORIAL       reduce using rule 57 (statements -> while .)
    MMULT           reduce using rule 57 (statements -> while .)
    RBRACE          reduce using rule 57 (statements -> while .)
    RETURN          reduce using rule 57 (statements -> while .)


state 55

    (58) statements -> array .

    VAR             reduce using rule 58 (statements -> array .)
    FUNCTION        reduce using rule 58 (statements -> array .)
    ID              reduce using rule 58 (statements -> array .)
    READ            reduce using rule 58 (statements -> array .)
    PRINT           reduce using rule 58 (statements -> array .)
    IF              reduce using rule 58 (statements -> array .)
    WHILE           reduce using rule 58 (statements -> array .)
    ARRAY           reduce using rule 58 (statements -> array .)
    MATRIX          reduce using rule 58 (statements -> array .)
    MEAN            reduce using rule 58 (statements -> array .)
    LAYERS          reduce using rule 58 (statements -> array .)
    SEQUENTIAL      reduce using rule 58 (statements -> array .)
    COMPILE         reduce using rule 58 (statements -> array .)
    FIT             reduce using rule 58 (statements -> array .)
    PREDICT         reduce using rule 58 (statements -> array .)
    GETWEIGHTS      reduce using rule 58 (statements -> array .)
    FIBONACCI       reduce using rule 58 (statements -> array .)
    FACTORIAL       reduce using rule 58 (statements -> array .)
    MMULT           reduce using rule 58 (statements -> array .)
    RBRACE          reduce using rule 58 (statements -> array .)
    RETURN          reduce using rule 58 (statements -> array .)


state 56

    (59) statements -> matrix .

    VAR             reduce using rule 59 (statements -> matrix .)
    FUNCTION        reduce using rule 59 (statements -> matrix .)
    ID              reduce using rule 59 (statements -> matrix .)
    READ            reduce using rule 59 (statements -> matrix .)
    PRINT           reduce using rule 59 (statements -> matrix .)
    IF              reduce using rule 59 (statements -> matrix .)
    WHILE           reduce using rule 59 (statements -> matrix .)
    ARRAY           reduce using rule 59 (statements -> matrix .)
    MATRIX          reduce using rule 59 (statements -> matrix .)
    MEAN            reduce using rule 59 (statements -> matrix .)
    LAYERS          reduce using rule 59 (statements -> matrix .)
    SEQUENTIAL      reduce using rule 59 (statements -> matrix .)
    COMPILE         reduce using rule 59 (statements -> matrix .)
    FIT             reduce using rule 59 (statements -> matrix .)
    PREDICT         reduce using rule 59 (statements -> matrix .)
    GETWEIGHTS      reduce using rule 59 (statements -> matrix .)
    FIBONACCI       reduce using rule 59 (statements -> matrix .)
    FACTORIAL       reduce using rule 59 (statements -> matrix .)
    MMULT           reduce using rule 59 (statements -> matrix .)
    RBRACE          reduce using rule 59 (statements -> matrix .)
    RETURN          reduce using rule 59 (statements -> matrix .)


state 57

    (60) statements -> mean .

    VAR             reduce using rule 60 (statements -> mean .)
    FUNCTION        reduce using rule 60 (statements -> mean .)
    ID              reduce using rule 60 (statements -> mean .)
    READ            reduce using rule 60 (statements -> mean .)
    PRINT           reduce using rule 60 (statements -> mean .)
    IF              reduce using rule 60 (statements -> mean .)
    WHILE           reduce using rule 60 (statements -> mean .)
    ARRAY           reduce using rule 60 (statements -> mean .)
    MATRIX          reduce using rule 60 (statements -> mean .)
    MEAN            reduce using rule 60 (statements -> mean .)
    LAYERS          reduce using rule 60 (statements -> mean .)
    SEQUENTIAL      reduce using rule 60 (statements -> mean .)
    COMPILE         reduce using rule 60 (statements -> mean .)
    FIT             reduce using rule 60 (statements -> mean .)
    PREDICT         reduce using rule 60 (statements -> mean .)
    GETWEIGHTS      reduce using rule 60 (statements -> mean .)
    FIBONACCI       reduce using rule 60 (statements -> mean .)
    FACTORIAL       reduce using rule 60 (statements -> mean .)
    MMULT           reduce using rule 60 (statements -> mean .)
    RBRACE          reduce using rule 60 (statements -> mean .)
    RETURN          reduce using rule 60 (statements -> mean .)


state 58

    (61) statements -> layers .

    VAR             reduce using rule 61 (statements -> layers .)
    FUNCTION        reduce using rule 61 (statements -> layers .)
    ID              reduce using rule 61 (statements -> layers .)
    READ            reduce using rule 61 (statements -> layers .)
    PRINT           reduce using rule 61 (statements -> layers .)
    IF              reduce using rule 61 (statements -> layers .)
    WHILE           reduce using rule 61 (statements -> layers .)
    ARRAY           reduce using rule 61 (statements -> layers .)
    MATRIX          reduce using rule 61 (statements -> layers .)
    MEAN            reduce using rule 61 (statements -> layers .)
    LAYERS          reduce using rule 61 (statements -> layers .)
    SEQUENTIAL      reduce using rule 61 (statements -> layers .)
    COMPILE         reduce using rule 61 (statements -> layers .)
    FIT             reduce using rule 61 (statements -> layers .)
    PREDICT         reduce using rule 61 (statements -> layers .)
    GETWEIGHTS      reduce using rule 61 (statements -> layers .)
    FIBONACCI       reduce using rule 61 (statements -> layers .)
    FACTORIAL       reduce using rule 61 (statements -> layers .)
    MMULT           reduce using rule 61 (statements -> layers .)
    RBRACE          reduce using rule 61 (statements -> layers .)
    RETURN          reduce using rule 61 (statements -> layers .)


state 59

    (62) statements -> sequential .

    VAR             reduce using rule 62 (statements -> sequential .)
    FUNCTION        reduce using rule 62 (statements -> sequential .)
    ID              reduce using rule 62 (statements -> sequential .)
    READ            reduce using rule 62 (statements -> sequential .)
    PRINT           reduce using rule 62 (statements -> sequential .)
    IF              reduce using rule 62 (statements -> sequential .)
    WHILE           reduce using rule 62 (statements -> sequential .)
    ARRAY           reduce using rule 62 (statements -> sequential .)
    MATRIX          reduce using rule 62 (statements -> sequential .)
    MEAN            reduce using rule 62 (statements -> sequential .)
    LAYERS          reduce using rule 62 (statements -> sequential .)
    SEQUENTIAL      reduce using rule 62 (statements -> sequential .)
    COMPILE         reduce using rule 62 (statements -> sequential .)
    FIT             reduce using rule 62 (statements -> sequential .)
    PREDICT         reduce using rule 62 (statements -> sequential .)
    GETWEIGHTS      reduce using rule 62 (statements -> sequential .)
    FIBONACCI       reduce using rule 62 (statements -> sequential .)
    FACTORIAL       reduce using rule 62 (statements -> sequential .)
    MMULT           reduce using rule 62 (statements -> sequential .)
    RBRACE          reduce using rule 62 (statements -> sequential .)
    RETURN          reduce using rule 62 (statements -> sequential .)


state 60

    (63) statements -> compile .

    VAR             reduce using rule 63 (statements -> compile .)
    FUNCTION        reduce using rule 63 (statements -> compile .)
    ID              reduce using rule 63 (statements -> compile .)
    READ            reduce using rule 63 (statements -> compile .)
    PRINT           reduce using rule 63 (statements -> compile .)
    IF              reduce using rule 63 (statements -> compile .)
    WHILE           reduce using rule 63 (statements -> compile .)
    ARRAY           reduce using rule 63 (statements -> compile .)
    MATRIX          reduce using rule 63 (statements -> compile .)
    MEAN            reduce using rule 63 (statements -> compile .)
    LAYERS          reduce using rule 63 (statements -> compile .)
    SEQUENTIAL      reduce using rule 63 (statements -> compile .)
    COMPILE         reduce using rule 63 (statements -> compile .)
    FIT             reduce using rule 63 (statements -> compile .)
    PREDICT         reduce using rule 63 (statements -> compile .)
    GETWEIGHTS      reduce using rule 63 (statements -> compile .)
    FIBONACCI       reduce using rule 63 (statements -> compile .)
    FACTORIAL       reduce using rule 63 (statements -> compile .)
    MMULT           reduce using rule 63 (statements -> compile .)
    RBRACE          reduce using rule 63 (statements -> compile .)
    RETURN          reduce using rule 63 (statements -> compile .)


state 61

    (64) statements -> fit .

    VAR             reduce using rule 64 (statements -> fit .)
    FUNCTION        reduce using rule 64 (statements -> fit .)
    ID              reduce using rule 64 (statements -> fit .)
    READ            reduce using rule 64 (statements -> fit .)
    PRINT           reduce using rule 64 (statements -> fit .)
    IF              reduce using rule 64 (statements -> fit .)
    WHILE           reduce using rule 64 (statements -> fit .)
    ARRAY           reduce using rule 64 (statements -> fit .)
    MATRIX          reduce using rule 64 (statements -> fit .)
    MEAN            reduce using rule 64 (statements -> fit .)
    LAYERS          reduce using rule 64 (statements -> fit .)
    SEQUENTIAL      reduce using rule 64 (statements -> fit .)
    COMPILE         reduce using rule 64 (statements -> fit .)
    FIT             reduce using rule 64 (statements -> fit .)
    PREDICT         reduce using rule 64 (statements -> fit .)
    GETWEIGHTS      reduce using rule 64 (statements -> fit .)
    FIBONACCI       reduce using rule 64 (statements -> fit .)
    FACTORIAL       reduce using rule 64 (statements -> fit .)
    MMULT           reduce using rule 64 (statements -> fit .)
    RBRACE          reduce using rule 64 (statements -> fit .)
    RETURN          reduce using rule 64 (statements -> fit .)


state 62

    (65) statements -> predict .

    VAR             reduce using rule 65 (statements -> predict .)
    FUNCTION        reduce using rule 65 (statements -> predict .)
    ID              reduce using rule 65 (statements -> predict .)
    READ            reduce using rule 65 (statements -> predict .)
    PRINT           reduce using rule 65 (statements -> predict .)
    IF              reduce using rule 65 (statements -> predict .)
    WHILE           reduce using rule 65 (statements -> predict .)
    ARRAY           reduce using rule 65 (statements -> predict .)
    MATRIX          reduce using rule 65 (statements -> predict .)
    MEAN            reduce using rule 65 (statements -> predict .)
    LAYERS          reduce using rule 65 (statements -> predict .)
    SEQUENTIAL      reduce using rule 65 (statements -> predict .)
    COMPILE         reduce using rule 65 (statements -> predict .)
    FIT             reduce using rule 65 (statements -> predict .)
    PREDICT         reduce using rule 65 (statements -> predict .)
    GETWEIGHTS      reduce using rule 65 (statements -> predict .)
    FIBONACCI       reduce using rule 65 (statements -> predict .)
    FACTORIAL       reduce using rule 65 (statements -> predict .)
    MMULT           reduce using rule 65 (statements -> predict .)
    RBRACE          reduce using rule 65 (statements -> predict .)
    RETURN          reduce using rule 65 (statements -> predict .)


state 63

    (66) statements -> getweights .

    VAR             reduce using rule 66 (statements -> getweights .)
    FUNCTION        reduce using rule 66 (statements -> getweights .)
    ID              reduce using rule 66 (statements -> getweights .)
    READ            reduce using rule 66 (statements -> getweights .)
    PRINT           reduce using rule 66 (statements -> getweights .)
    IF              reduce using rule 66 (statements -> getweights .)
    WHILE           reduce using rule 66 (statements -> getweights .)
    ARRAY           reduce using rule 66 (statements -> getweights .)
    MATRIX          reduce using rule 66 (statements -> getweights .)
    MEAN            reduce using rule 66 (statements -> getweights .)
    LAYERS          reduce using rule 66 (statements -> getweights .)
    SEQUENTIAL      reduce using rule 66 (statements -> getweights .)
    COMPILE         reduce using rule 66 (statements -> getweights .)
    FIT             reduce using rule 66 (statements -> getweights .)
    PREDICT         reduce using rule 66 (statements -> getweights .)
    GETWEIGHTS      reduce using rule 66 (statements -> getweights .)
    FIBONACCI       reduce using rule 66 (statements -> getweights .)
    FACTORIAL       reduce using rule 66 (statements -> getweights .)
    MMULT           reduce using rule 66 (statements -> getweights .)
    RBRACE          reduce using rule 66 (statements -> getweights .)
    RETURN          reduce using rule 66 (statements -> getweights .)


state 64

    (67) statements -> fibonacci .

    VAR             reduce using rule 67 (statements -> fibonacci .)
    FUNCTION        reduce using rule 67 (statements -> fibonacci .)
    ID              reduce using rule 67 (statements -> fibonacci .)
    READ            reduce using rule 67 (statements -> fibonacci .)
    PRINT           reduce using rule 67 (statements -> fibonacci .)
    IF              reduce using rule 67 (statements -> fibonacci .)
    WHILE           reduce using rule 67 (statements -> fibonacci .)
    ARRAY           reduce using rule 67 (statements -> fibonacci .)
    MATRIX          reduce using rule 67 (statements -> fibonacci .)
    MEAN            reduce using rule 67 (statements -> fibonacci .)
    LAYERS          reduce using rule 67 (statements -> fibonacci .)
    SEQUENTIAL      reduce using rule 67 (statements -> fibonacci .)
    COMPILE         reduce using rule 67 (statements -> fibonacci .)
    FIT             reduce using rule 67 (statements -> fibonacci .)
    PREDICT         reduce using rule 67 (statements -> fibonacci .)
    GETWEIGHTS      reduce using rule 67 (statements -> fibonacci .)
    FIBONACCI       reduce using rule 67 (statements -> fibonacci .)
    FACTORIAL       reduce using rule 67 (statements -> fibonacci .)
    MMULT           reduce using rule 67 (statements -> fibonacci .)
    RBRACE          reduce using rule 67 (statements -> fibonacci .)
    RETURN          reduce using rule 67 (statements -> fibonacci .)


state 65

    (68) statements -> factorial .

    VAR             reduce using rule 68 (statements -> factorial .)
    FUNCTION        reduce using rule 68 (statements -> factorial .)
    ID              reduce using rule 68 (statements -> factorial .)
    READ            reduce using rule 68 (statements -> factorial .)
    PRINT           reduce using rule 68 (statements -> factorial .)
    IF              reduce using rule 68 (statements -> factorial .)
    WHILE           reduce using rule 68 (statements -> factorial .)
    ARRAY           reduce using rule 68 (statements -> factorial .)
    MATRIX          reduce using rule 68 (statements -> factorial .)
    MEAN            reduce using rule 68 (statements -> factorial .)
    LAYERS          reduce using rule 68 (statements -> factorial .)
    SEQUENTIAL      reduce using rule 68 (statements -> factorial .)
    COMPILE         reduce using rule 68 (statements -> factorial .)
    FIT             reduce using rule 68 (statements -> factorial .)
    PREDICT         reduce using rule 68 (statements -> factorial .)
    GETWEIGHTS      reduce using rule 68 (statements -> factorial .)
    FIBONACCI       reduce using rule 68 (statements -> factorial .)
    FACTORIAL       reduce using rule 68 (statements -> factorial .)
    MMULT           reduce using rule 68 (statements -> factorial .)
    RBRACE          reduce using rule 68 (statements -> factorial .)
    RETURN          reduce using rule 68 (statements -> factorial .)


state 66

    (69) statements -> mmult .

    VAR             reduce using rule 69 (statements -> mmult .)
    FUNCTION        reduce using rule 69 (statements -> mmult .)
    ID              reduce using rule 69 (statements -> mmult .)
    READ            reduce using rule 69 (statements -> mmult .)
    PRINT           reduce using rule 69 (statements -> mmult .)
    IF              reduce using rule 69 (statements -> mmult .)
    WHILE           reduce using rule 69 (statements -> mmult .)
    ARRAY           reduce using rule 69 (statements -> mmult .)
    MATRIX          reduce using rule 69 (statements -> mmult .)
    MEAN            reduce using rule 69 (statements -> mmult .)
    LAYERS          reduce using rule 69 (statements -> mmult .)
    SEQUENTIAL      reduce using rule 69 (statements -> mmult .)
    COMPILE         reduce using rule 69 (statements -> mmult .)
    FIT             reduce using rule 69 (statements -> mmult .)
    PREDICT         reduce using rule 69 (statements -> mmult .)
    GETWEIGHTS      reduce using rule 69 (statements -> mmult .)
    FIBONACCI       reduce using rule 69 (statements -> mmult .)
    FACTORIAL       reduce using rule 69 (statements -> mmult .)
    MMULT           reduce using rule 69 (statements -> mmult .)
    RBRACE          reduce using rule 69 (statements -> mmult .)
    RETURN          reduce using rule 69 (statements -> mmult .)


state 67

    (70) assign -> var . EQUAL exp SEMICOLON

    EQUAL           shift and go to state 91


state 68

    (76) call -> ID . LPAREN callp RPAREN
    (75) var -> ID .

    LPAREN          shift and go to state 92
    EQUAL           reduce using rule 75 (var -> ID .)


state 69

    (71) read -> READ . LPAREN var RPAREN SEMICOLON

    LPAREN          shift and go to state 93


state 70

    (72) print -> PRINT . LPAREN printp SEMICOLON

    LPAREN          shift and go to state 94


state 71

    (80) if -> IF . LPAREN ifexp RPAREN quadsIf LBRACE body RBRACE ifelse jumpsIf SEMICOLON

    LPAREN          shift and go to state 95


state 72

    (87) while -> WHILE . saveJumps LPAREN whilexp RPAREN quadsWhile LBRACE body RBRACE jumpsWhile SEMICOLON
    (89) saveJumps -> .

    LPAREN          reduce using rule 89 (saveJumps -> .)

    saveJumps                      shift and go to state 96

state 73

    (100) array -> ARRAY . ID LBRACKET exp RBRACKET EQUAL LBRACKET arrvalues RBRACKET SEMICOLON

    ID              shift and go to state 97


state 74

    (103) matrix -> MATRIX . ID LBRACKET exp RBRACKET LBRACKET exp RBRACKET EQUAL LBRACKET matvalues RBRACKET SEMICOLON

    ID              shift and go to state 98


state 75

    (106) mean -> MEAN . LPAREN ID RPAREN SEMICOLON

    LPAREN          shift and go to state 99


state 76

    (107) layers -> LAYERS . LPAREN UNITS EQUAL CTI RPAREN SEMICOLON

    LPAREN          shift and go to state 100


state 77

    (108) sequential -> SEQUENTIAL . LPAREN RPAREN SEMICOLON

    LPAREN          shift and go to state 101


state 78

    (109) compile -> COMPILE . LPAREN CTF RPAREN SEMICOLON

    LPAREN          shift and go to state 102


state 79

    (110) fit -> FIT . LPAREN ID COMMA ID COMMA EPOCHS EQUAL CTI RPAREN SEMICOLON

    LPAREN          shift and go to state 103


state 80

    (111) predict -> PREDICT . LPAREN CTF RPAREN SEMICOLON

    LPAREN          shift and go to state 104


state 81

    (112) getweights -> GETWEIGHTS . LPAREN RPAREN SEMICOLON

    LPAREN          shift and go to state 105


state 82

    (113) fibonacci -> FIBONACCI . LPAREN exp RPAREN SEMICOLON

    LPAREN          shift and go to state 106


state 83

    (114) factorial -> FACTORIAL . LPAREN exp RPAREN SEMICOLON

    LPAREN          shift and go to state 107


state 84

    (115) mmult -> MMULT . LPAREN ID COMMA ID RPAREN SEMICOLON

    LPAREN          shift and go to state 108


state 85

    (11) function -> FUNCTION decfunctype decfunc LPAREN param RPAREN LBRACE . body RETURN exp SEMICOLON RBRACE
    (22) body -> . decvar statements body
    (23) body -> . statements body
    (24) body -> . decvar
    (25) body -> .
    (3) decvar -> . VAR decvarp
    (4) decvar -> . VAR decvarp decvar
    (5) decvar -> .
    (50) statements -> . assign
    (51) statements -> . function
    (52) statements -> . voidfunction
    (53) statements -> . call
    (54) statements -> . read
    (55) statements -> . print
    (56) statements -> . if
    (57) statements -> . while
    (58) statements -> . array
    (59) statements -> . matrix
    (60) statements -> . mean
    (61) statements -> . layers
    (62) statements -> . sequential
    (63) statements -> . compile
    (64) statements -> . fit
    (65) statements -> . predict
    (66) statements -> . getweights
    (67) statements -> . fibonacci
    (68) statements -> . factorial
    (69) statements -> . mmult
    (70) assign -> . var EQUAL exp SEMICOLON
    (11) function -> . FUNCTION decfunctype decfunc LPAREN param RPAREN LBRACE body RETURN exp SEMICOLON RBRACE
    (14) voidfunction -> . FUNCTION VOID decfunc LPAREN param RPAREN LBRACE body RBRACE
    (76) call -> . ID LPAREN callp RPAREN
    (71) read -> . READ LPAREN var RPAREN SEMICOLON
    (72) print -> . PRINT LPAREN printp SEMICOLON
    (80) if -> . IF LPAREN ifexp RPAREN quadsIf LBRACE body RBRACE ifelse jumpsIf SEMICOLON
    (87) while -> . WHILE saveJumps LPAREN whilexp RPAREN quadsWhile LBRACE body RBRACE jumpsWhile SEMICOLON
    (100) array -> . ARRAY ID LBRACKET exp RBRACKET EQUAL LBRACKET arrvalues RBRACKET SEMICOLON
    (103) matrix -> . MATRIX ID LBRACKET exp RBRACKET LBRACKET exp RBRACKET EQUAL LBRACKET matvalues RBRACKET SEMICOLON
    (106) mean -> . MEAN LPAREN ID RPAREN SEMICOLON
    (107) layers -> . LAYERS LPAREN UNITS EQUAL CTI RPAREN SEMICOLON
    (108) sequential -> . SEQUENTIAL LPAREN RPAREN SEMICOLON
    (109) compile -> . COMPILE LPAREN CTF RPAREN SEMICOLON
    (110) fit -> . FIT LPAREN ID COMMA ID COMMA EPOCHS EQUAL CTI RPAREN SEMICOLON
    (111) predict -> . PREDICT LPAREN CTF RPAREN SEMICOLON
    (112) getweights -> . GETWEIGHTS LPAREN RPAREN SEMICOLON
    (113) fibonacci -> . FIBONACCI LPAREN exp RPAREN SEMICOLON
    (114) factorial -> . FACTORIAL LPAREN exp RPAREN SEMICOLON
    (115) mmult -> . MMULT LPAREN ID COMMA ID RPAREN SEMICOLON
    (75) var -> . ID

  ! reduce/reduce conflict for RETURN resolved using rule 5 (decvar -> .)
  ! shift/reduce conflict for FUNCTION resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for READ resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for ARRAY resolved as shift
  ! shift/reduce conflict for MATRIX resolved as shift
  ! shift/reduce conflict for MEAN resolved as shift
  ! shift/reduce conflict for LAYERS resolved as shift
  ! shift/reduce conflict for SEQUENTIAL resolved as shift
  ! shift/reduce conflict for COMPILE resolved as shift
  ! shift/reduce conflict for FIT resolved as shift
  ! shift/reduce conflict for PREDICT resolved as shift
  ! shift/reduce conflict for GETWEIGHTS resolved as shift
  ! shift/reduce conflict for FIBONACCI resolved as shift
  ! shift/reduce conflict for FACTORIAL resolved as shift
  ! shift/reduce conflict for MMULT resolved as shift
    VAR             shift and go to state 7
    RETURN          reduce using rule 5 (decvar -> .)
    FUNCTION        shift and go to state 11
    ID              shift and go to state 68
    READ            shift and go to state 69
    PRINT           shift and go to state 70
    IF              shift and go to state 71
    WHILE           shift and go to state 72
    ARRAY           shift and go to state 73
    MATRIX          shift and go to state 74
    MEAN            shift and go to state 75
    LAYERS          shift and go to state 76
    SEQUENTIAL      shift and go to state 77
    COMPILE         shift and go to state 78
    FIT             shift and go to state 79
    PREDICT         shift and go to state 80
    GETWEIGHTS      shift and go to state 81
    FIBONACCI       shift and go to state 82
    FACTORIAL       shift and go to state 83
    MMULT           shift and go to state 84

  ! RETURN          [ reduce using rule 25 (body -> .) ]
  ! FUNCTION        [ reduce using rule 5 (decvar -> .) ]
  ! ID              [ reduce using rule 5 (decvar -> .) ]
  ! READ            [ reduce using rule 5 (decvar -> .) ]
  ! PRINT           [ reduce using rule 5 (decvar -> .) ]
  ! IF              [ reduce using rule 5 (decvar -> .) ]
  ! WHILE           [ reduce using rule 5 (decvar -> .) ]
  ! ARRAY           [ reduce using rule 5 (decvar -> .) ]
  ! MATRIX          [ reduce using rule 5 (decvar -> .) ]
  ! MEAN            [ reduce using rule 5 (decvar -> .) ]
  ! LAYERS          [ reduce using rule 5 (decvar -> .) ]
  ! SEQUENTIAL      [ reduce using rule 5 (decvar -> .) ]
  ! COMPILE         [ reduce using rule 5 (decvar -> .) ]
  ! FIT             [ reduce using rule 5 (decvar -> .) ]
  ! PREDICT         [ reduce using rule 5 (decvar -> .) ]
  ! GETWEIGHTS      [ reduce using rule 5 (decvar -> .) ]
  ! FIBONACCI       [ reduce using rule 5 (decvar -> .) ]
  ! FACTORIAL       [ reduce using rule 5 (decvar -> .) ]
  ! MMULT           [ reduce using rule 5 (decvar -> .) ]

    body                           shift and go to state 109
    decvar                         shift and go to state 45
    statements                     shift and go to state 46
    assign                         shift and go to state 47
    function                       shift and go to state 48
    voidfunction                   shift and go to state 49
    call                           shift and go to state 50
    read                           shift and go to state 51
    print                          shift and go to state 52
    if                             shift and go to state 53
    while                          shift and go to state 54
    array                          shift and go to state 55
    matrix                         shift and go to state 56
    mean                           shift and go to state 57
    layers                         shift and go to state 58
    sequential                     shift and go to state 59
    compile                        shift and go to state 60
    fit                            shift and go to state 61
    predict                        shift and go to state 62
    getweights                     shift and go to state 63
    fibonacci                      shift and go to state 64
    factorial                      shift and go to state 65
    mmult                          shift and go to state 66
    var                            shift and go to state 67

state 86

    (27) param -> type ID COMMA . param
    (26) param -> . type ID
    (27) param -> . type ID COMMA param
    (28) param -> .
    (9) type -> . INT
    (10) type -> . FLOAT

    RPAREN          reduce using rule 28 (param -> .)
    INT             shift and go to state 14
    FLOAT           shift and go to state 15

    type                           shift and go to state 38
    param                          shift and go to state 110

state 87

    (14) voidfunction -> FUNCTION VOID decfunc LPAREN param RPAREN LBRACE . body RBRACE
    (22) body -> . decvar statements body
    (23) body -> . statements body
    (24) body -> . decvar
    (25) body -> .
    (3) decvar -> . VAR decvarp
    (4) decvar -> . VAR decvarp decvar
    (5) decvar -> .
    (50) statements -> . assign
    (51) statements -> . function
    (52) statements -> . voidfunction
    (53) statements -> . call
    (54) statements -> . read
    (55) statements -> . print
    (56) statements -> . if
    (57) statements -> . while
    (58) statements -> . array
    (59) statements -> . matrix
    (60) statements -> . mean
    (61) statements -> . layers
    (62) statements -> . sequential
    (63) statements -> . compile
    (64) statements -> . fit
    (65) statements -> . predict
    (66) statements -> . getweights
    (67) statements -> . fibonacci
    (68) statements -> . factorial
    (69) statements -> . mmult
    (70) assign -> . var EQUAL exp SEMICOLON
    (11) function -> . FUNCTION decfunctype decfunc LPAREN param RPAREN LBRACE body RETURN exp SEMICOLON RBRACE
    (14) voidfunction -> . FUNCTION VOID decfunc LPAREN param RPAREN LBRACE body RBRACE
    (76) call -> . ID LPAREN callp RPAREN
    (71) read -> . READ LPAREN var RPAREN SEMICOLON
    (72) print -> . PRINT LPAREN printp SEMICOLON
    (80) if -> . IF LPAREN ifexp RPAREN quadsIf LBRACE body RBRACE ifelse jumpsIf SEMICOLON
    (87) while -> . WHILE saveJumps LPAREN whilexp RPAREN quadsWhile LBRACE body RBRACE jumpsWhile SEMICOLON
    (100) array -> . ARRAY ID LBRACKET exp RBRACKET EQUAL LBRACKET arrvalues RBRACKET SEMICOLON
    (103) matrix -> . MATRIX ID LBRACKET exp RBRACKET LBRACKET exp RBRACKET EQUAL LBRACKET matvalues RBRACKET SEMICOLON
    (106) mean -> . MEAN LPAREN ID RPAREN SEMICOLON
    (107) layers -> . LAYERS LPAREN UNITS EQUAL CTI RPAREN SEMICOLON
    (108) sequential -> . SEQUENTIAL LPAREN RPAREN SEMICOLON
    (109) compile -> . COMPILE LPAREN CTF RPAREN SEMICOLON
    (110) fit -> . FIT LPAREN ID COMMA ID COMMA EPOCHS EQUAL CTI RPAREN SEMICOLON
    (111) predict -> . PREDICT LPAREN CTF RPAREN SEMICOLON
    (112) getweights -> . GETWEIGHTS LPAREN RPAREN SEMICOLON
    (113) fibonacci -> . FIBONACCI LPAREN exp RPAREN SEMICOLON
    (114) factorial -> . FACTORIAL LPAREN exp RPAREN SEMICOLON
    (115) mmult -> . MMULT LPAREN ID COMMA ID RPAREN SEMICOLON
    (75) var -> . ID

  ! reduce/reduce conflict for RBRACE resolved using rule 5 (decvar -> .)
  ! shift/reduce conflict for FUNCTION resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for READ resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for ARRAY resolved as shift
  ! shift/reduce conflict for MATRIX resolved as shift
  ! shift/reduce conflict for MEAN resolved as shift
  ! shift/reduce conflict for LAYERS resolved as shift
  ! shift/reduce conflict for SEQUENTIAL resolved as shift
  ! shift/reduce conflict for COMPILE resolved as shift
  ! shift/reduce conflict for FIT resolved as shift
  ! shift/reduce conflict for PREDICT resolved as shift
  ! shift/reduce conflict for GETWEIGHTS resolved as shift
  ! shift/reduce conflict for FIBONACCI resolved as shift
  ! shift/reduce conflict for FACTORIAL resolved as shift
  ! shift/reduce conflict for MMULT resolved as shift
    VAR             shift and go to state 7
    RBRACE          reduce using rule 5 (decvar -> .)
    FUNCTION        shift and go to state 11
    ID              shift and go to state 68
    READ            shift and go to state 69
    PRINT           shift and go to state 70
    IF              shift and go to state 71
    WHILE           shift and go to state 72
    ARRAY           shift and go to state 73
    MATRIX          shift and go to state 74
    MEAN            shift and go to state 75
    LAYERS          shift and go to state 76
    SEQUENTIAL      shift and go to state 77
    COMPILE         shift and go to state 78
    FIT             shift and go to state 79
    PREDICT         shift and go to state 80
    GETWEIGHTS      shift and go to state 81
    FIBONACCI       shift and go to state 82
    FACTORIAL       shift and go to state 83
    MMULT           shift and go to state 84

  ! RBRACE          [ reduce using rule 25 (body -> .) ]
  ! FUNCTION        [ reduce using rule 5 (decvar -> .) ]
  ! ID              [ reduce using rule 5 (decvar -> .) ]
  ! READ            [ reduce using rule 5 (decvar -> .) ]
  ! PRINT           [ reduce using rule 5 (decvar -> .) ]
  ! IF              [ reduce using rule 5 (decvar -> .) ]
  ! WHILE           [ reduce using rule 5 (decvar -> .) ]
  ! ARRAY           [ reduce using rule 5 (decvar -> .) ]
  ! MATRIX          [ reduce using rule 5 (decvar -> .) ]
  ! MEAN            [ reduce using rule 5 (decvar -> .) ]
  ! LAYERS          [ reduce using rule 5 (decvar -> .) ]
  ! SEQUENTIAL      [ reduce using rule 5 (decvar -> .) ]
  ! COMPILE         [ reduce using rule 5 (decvar -> .) ]
  ! FIT             [ reduce using rule 5 (decvar -> .) ]
  ! PREDICT         [ reduce using rule 5 (decvar -> .) ]
  ! GETWEIGHTS      [ reduce using rule 5 (decvar -> .) ]
  ! FIBONACCI       [ reduce using rule 5 (decvar -> .) ]
  ! FACTORIAL       [ reduce using rule 5 (decvar -> .) ]
  ! MMULT           [ reduce using rule 5 (decvar -> .) ]

    body                           shift and go to state 111
    decvar                         shift and go to state 45
    statements                     shift and go to state 46
    assign                         shift and go to state 47
    function                       shift and go to state 48
    voidfunction                   shift and go to state 49
    call                           shift and go to state 50
    read                           shift and go to state 51
    print                          shift and go to state 52
    if                             shift and go to state 53
    while                          shift and go to state 54
    array                          shift and go to state 55
    matrix                         shift and go to state 56
    mean                           shift and go to state 57
    layers                         shift and go to state 58
    sequential                     shift and go to state 59
    compile                        shift and go to state 60
    fit                            shift and go to state 61
    predict                        shift and go to state 62
    getweights                     shift and go to state 63
    fibonacci                      shift and go to state 64
    factorial                      shift and go to state 65
    mmult                          shift and go to state 66
    var                            shift and go to state 67

state 88

    (16) mainfunction -> MAIN decfuncmain LPAREN RPAREN LBRACE body RBRACE .

    $end            reduce using rule 16 (mainfunction -> MAIN decfuncmain LPAREN RPAREN LBRACE body RBRACE .)


state 89

    (22) body -> decvar statements . body
    (22) body -> . decvar statements body
    (23) body -> . statements body
    (24) body -> . decvar
    (25) body -> .
    (3) decvar -> . VAR decvarp
    (4) decvar -> . VAR decvarp decvar
    (5) decvar -> .
    (50) statements -> . assign
    (51) statements -> . function
    (52) statements -> . voidfunction
    (53) statements -> . call
    (54) statements -> . read
    (55) statements -> . print
    (56) statements -> . if
    (57) statements -> . while
    (58) statements -> . array
    (59) statements -> . matrix
    (60) statements -> . mean
    (61) statements -> . layers
    (62) statements -> . sequential
    (63) statements -> . compile
    (64) statements -> . fit
    (65) statements -> . predict
    (66) statements -> . getweights
    (67) statements -> . fibonacci
    (68) statements -> . factorial
    (69) statements -> . mmult
    (70) assign -> . var EQUAL exp SEMICOLON
    (11) function -> . FUNCTION decfunctype decfunc LPAREN param RPAREN LBRACE body RETURN exp SEMICOLON RBRACE
    (14) voidfunction -> . FUNCTION VOID decfunc LPAREN param RPAREN LBRACE body RBRACE
    (76) call -> . ID LPAREN callp RPAREN
    (71) read -> . READ LPAREN var RPAREN SEMICOLON
    (72) print -> . PRINT LPAREN printp SEMICOLON
    (80) if -> . IF LPAREN ifexp RPAREN quadsIf LBRACE body RBRACE ifelse jumpsIf SEMICOLON
    (87) while -> . WHILE saveJumps LPAREN whilexp RPAREN quadsWhile LBRACE body RBRACE jumpsWhile SEMICOLON
    (100) array -> . ARRAY ID LBRACKET exp RBRACKET EQUAL LBRACKET arrvalues RBRACKET SEMICOLON
    (103) matrix -> . MATRIX ID LBRACKET exp RBRACKET LBRACKET exp RBRACKET EQUAL LBRACKET matvalues RBRACKET SEMICOLON
    (106) mean -> . MEAN LPAREN ID RPAREN SEMICOLON
    (107) layers -> . LAYERS LPAREN UNITS EQUAL CTI RPAREN SEMICOLON
    (108) sequential -> . SEQUENTIAL LPAREN RPAREN SEMICOLON
    (109) compile -> . COMPILE LPAREN CTF RPAREN SEMICOLON
    (110) fit -> . FIT LPAREN ID COMMA ID COMMA EPOCHS EQUAL CTI RPAREN SEMICOLON
    (111) predict -> . PREDICT LPAREN CTF RPAREN SEMICOLON
    (112) getweights -> . GETWEIGHTS LPAREN RPAREN SEMICOLON
    (113) fibonacci -> . FIBONACCI LPAREN exp RPAREN SEMICOLON
    (114) factorial -> . FACTORIAL LPAREN exp RPAREN SEMICOLON
    (115) mmult -> . MMULT LPAREN ID COMMA ID RPAREN SEMICOLON
    (75) var -> . ID

  ! reduce/reduce conflict for RBRACE resolved using rule 5 (decvar -> .)
  ! reduce/reduce conflict for RETURN resolved using rule 5 (decvar -> .)
  ! shift/reduce conflict for FUNCTION resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for READ resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for ARRAY resolved as shift
  ! shift/reduce conflict for MATRIX resolved as shift
  ! shift/reduce conflict for MEAN resolved as shift
  ! shift/reduce conflict for LAYERS resolved as shift
  ! shift/reduce conflict for SEQUENTIAL resolved as shift
  ! shift/reduce conflict for COMPILE resolved as shift
  ! shift/reduce conflict for FIT resolved as shift
  ! shift/reduce conflict for PREDICT resolved as shift
  ! shift/reduce conflict for GETWEIGHTS resolved as shift
  ! shift/reduce conflict for FIBONACCI resolved as shift
  ! shift/reduce conflict for FACTORIAL resolved as shift
  ! shift/reduce conflict for MMULT resolved as shift
    VAR             shift and go to state 7
    RBRACE          reduce using rule 5 (decvar -> .)
    RETURN          reduce using rule 5 (decvar -> .)
    FUNCTION        shift and go to state 11
    ID              shift and go to state 68
    READ            shift and go to state 69
    PRINT           shift and go to state 70
    IF              shift and go to state 71
    WHILE           shift and go to state 72
    ARRAY           shift and go to state 73
    MATRIX          shift and go to state 74
    MEAN            shift and go to state 75
    LAYERS          shift and go to state 76
    SEQUENTIAL      shift and go to state 77
    COMPILE         shift and go to state 78
    FIT             shift and go to state 79
    PREDICT         shift and go to state 80
    GETWEIGHTS      shift and go to state 81
    FIBONACCI       shift and go to state 82
    FACTORIAL       shift and go to state 83
    MMULT           shift and go to state 84

  ! RBRACE          [ reduce using rule 25 (body -> .) ]
  ! RETURN          [ reduce using rule 25 (body -> .) ]
  ! FUNCTION        [ reduce using rule 5 (decvar -> .) ]
  ! ID              [ reduce using rule 5 (decvar -> .) ]
  ! READ            [ reduce using rule 5 (decvar -> .) ]
  ! PRINT           [ reduce using rule 5 (decvar -> .) ]
  ! IF              [ reduce using rule 5 (decvar -> .) ]
  ! WHILE           [ reduce using rule 5 (decvar -> .) ]
  ! ARRAY           [ reduce using rule 5 (decvar -> .) ]
  ! MATRIX          [ reduce using rule 5 (decvar -> .) ]
  ! MEAN            [ reduce using rule 5 (decvar -> .) ]
  ! LAYERS          [ reduce using rule 5 (decvar -> .) ]
  ! SEQUENTIAL      [ reduce using rule 5 (decvar -> .) ]
  ! COMPILE         [ reduce using rule 5 (decvar -> .) ]
  ! FIT             [ reduce using rule 5 (decvar -> .) ]
  ! PREDICT         [ reduce using rule 5 (decvar -> .) ]
  ! GETWEIGHTS      [ reduce using rule 5 (decvar -> .) ]
  ! FIBONACCI       [ reduce using rule 5 (decvar -> .) ]
  ! FACTORIAL       [ reduce using rule 5 (decvar -> .) ]
  ! MMULT           [ reduce using rule 5 (decvar -> .) ]

    decvar                         shift and go to state 45
    statements                     shift and go to state 46
    body                           shift and go to state 112
    assign                         shift and go to state 47
    function                       shift and go to state 48
    voidfunction                   shift and go to state 49
    call                           shift and go to state 50
    read                           shift and go to state 51
    print                          shift and go to state 52
    if                             shift and go to state 53
    while                          shift and go to state 54
    array                          shift and go to state 55
    matrix                         shift and go to state 56
    mean                           shift and go to state 57
    layers                         shift and go to state 58
    sequential                     shift and go to state 59
    compile                        shift and go to state 60
    fit                            shift and go to state 61
    predict                        shift and go to state 62
    getweights                     shift and go to state 63
    fibonacci                      shift and go to state 64
    factorial                      shift and go to state 65
    mmult                          shift and go to state 66
    var                            shift and go to state 67

state 90

    (23) body -> statements body .

    RBRACE          reduce using rule 23 (body -> statements body .)
    RETURN          reduce using rule 23 (body -> statements body .)


state 91

    (70) assign -> var EQUAL . exp SEMICOLON
    (29) exp -> . texp
    (30) exp -> . texp OR exp
    (31) texp -> . gexp
    (32) texp -> . gexp AND texp
    (33) gexp -> . mexp
    (34) gexp -> . mexp gexpp mexp
    (39) mexp -> . t
    (40) mexp -> . mexp PLUS t
    (41) mexp -> . mexp MINUS t
    (42) t -> . f
    (43) t -> . t MULT f
    (44) t -> . t DIV f
    (45) f -> . LPAREN exp RPAREN
    (46) f -> . CTI
    (47) f -> . CTF
    (48) f -> . var
    (49) f -> . call
    (75) var -> . ID
    (76) call -> . ID LPAREN callp RPAREN

    LPAREN          shift and go to state 120
    CTI             shift and go to state 121
    CTF             shift and go to state 122
    ID              shift and go to state 124

    var                            shift and go to state 113
    exp                            shift and go to state 114
    texp                           shift and go to state 115
    gexp                           shift and go to state 116
    mexp                           shift and go to state 117
    t                              shift and go to state 118
    f                              shift and go to state 119
    call                           shift and go to state 123

state 92

    (76) call -> ID LPAREN . callp RPAREN
    (77) callp -> . exp COMMA callp
    (78) callp -> . exp
    (79) callp -> .
    (29) exp -> . texp
    (30) exp -> . texp OR exp
    (31) texp -> . gexp
    (32) texp -> . gexp AND texp
    (33) gexp -> . mexp
    (34) gexp -> . mexp gexpp mexp
    (39) mexp -> . t
    (40) mexp -> . mexp PLUS t
    (41) mexp -> . mexp MINUS t
    (42) t -> . f
    (43) t -> . t MULT f
    (44) t -> . t DIV f
    (45) f -> . LPAREN exp RPAREN
    (46) f -> . CTI
    (47) f -> . CTF
    (48) f -> . var
    (49) f -> . call
    (75) var -> . ID
    (76) call -> . ID LPAREN callp RPAREN

    RPAREN          reduce using rule 79 (callp -> .)
    LPAREN          shift and go to state 120
    CTI             shift and go to state 121
    CTF             shift and go to state 122
    ID              shift and go to state 124

    callp                          shift and go to state 125
    exp                            shift and go to state 126
    texp                           shift and go to state 115
    gexp                           shift and go to state 116
    mexp                           shift and go to state 117
    t                              shift and go to state 118
    f                              shift and go to state 119
    var                            shift and go to state 113
    call                           shift and go to state 123

state 93

    (71) read -> READ LPAREN . var RPAREN SEMICOLON
    (75) var -> . ID

    ID              shift and go to state 128

    var                            shift and go to state 127

state 94

    (72) print -> PRINT LPAREN . printp SEMICOLON
    (73) printp -> . exp RPAREN
    (74) printp -> . exp COMMA printp
    (29) exp -> . texp
    (30) exp -> . texp OR exp
    (31) texp -> . gexp
    (32) texp -> . gexp AND texp
    (33) gexp -> . mexp
    (34) gexp -> . mexp gexpp mexp
    (39) mexp -> . t
    (40) mexp -> . mexp PLUS t
    (41) mexp -> . mexp MINUS t
    (42) t -> . f
    (43) t -> . t MULT f
    (44) t -> . t DIV f
    (45) f -> . LPAREN exp RPAREN
    (46) f -> . CTI
    (47) f -> . CTF
    (48) f -> . var
    (49) f -> . call
    (75) var -> . ID
    (76) call -> . ID LPAREN callp RPAREN

    LPAREN          shift and go to state 120
    CTI             shift and go to state 121
    CTF             shift and go to state 122
    ID              shift and go to state 124

    printp                         shift and go to state 129
    exp                            shift and go to state 130
    texp                           shift and go to state 115
    gexp                           shift and go to state 116
    mexp                           shift and go to state 117
    t                              shift and go to state 118
    f                              shift and go to state 119
    var                            shift and go to state 113
    call                           shift and go to state 123

state 95

    (80) if -> IF LPAREN . ifexp RPAREN quadsIf LBRACE body RBRACE ifelse jumpsIf SEMICOLON
    (81) ifexp -> . exp
    (29) exp -> . texp
    (30) exp -> . texp OR exp
    (31) texp -> . gexp
    (32) texp -> . gexp AND texp
    (33) gexp -> . mexp
    (34) gexp -> . mexp gexpp mexp
    (39) mexp -> . t
    (40) mexp -> . mexp PLUS t
    (41) mexp -> . mexp MINUS t
    (42) t -> . f
    (43) t -> . t MULT f
    (44) t -> . t DIV f
    (45) f -> . LPAREN exp RPAREN
    (46) f -> . CTI
    (47) f -> . CTF
    (48) f -> . var
    (49) f -> . call
    (75) var -> . ID
    (76) call -> . ID LPAREN callp RPAREN

    LPAREN          shift and go to state 120
    CTI             shift and go to state 121
    CTF             shift and go to state 122
    ID              shift and go to state 124

    ifexp                          shift and go to state 131
    exp                            shift and go to state 132
    texp                           shift and go to state 115
    gexp                           shift and go to state 116
    mexp                           shift and go to state 117
    t                              shift and go to state 118
    f                              shift and go to state 119
    var                            shift and go to state 113
    call                           shift and go to state 123

state 96

    (87) while -> WHILE saveJumps . LPAREN whilexp RPAREN quadsWhile LBRACE body RBRACE jumpsWhile SEMICOLON

    LPAREN          shift and go to state 133


state 97

    (100) array -> ARRAY ID . LBRACKET exp RBRACKET EQUAL LBRACKET arrvalues RBRACKET SEMICOLON

    LBRACKET        shift and go to state 134


state 98

    (103) matrix -> MATRIX ID . LBRACKET exp RBRACKET LBRACKET exp RBRACKET EQUAL LBRACKET matvalues RBRACKET SEMICOLON

    LBRACKET        shift and go to state 135


state 99

    (106) mean -> MEAN LPAREN . ID RPAREN SEMICOLON

    ID              shift and go to state 136


state 100

    (107) layers -> LAYERS LPAREN . UNITS EQUAL CTI RPAREN SEMICOLON

    UNITS           shift and go to state 137


state 101

    (108) sequential -> SEQUENTIAL LPAREN . RPAREN SEMICOLON

    RPAREN          shift and go to state 138


state 102

    (109) compile -> COMPILE LPAREN . CTF RPAREN SEMICOLON

    CTF             shift and go to state 139


state 103

    (110) fit -> FIT LPAREN . ID COMMA ID COMMA EPOCHS EQUAL CTI RPAREN SEMICOLON

    ID              shift and go to state 140


state 104

    (111) predict -> PREDICT LPAREN . CTF RPAREN SEMICOLON

    CTF             shift and go to state 141


state 105

    (112) getweights -> GETWEIGHTS LPAREN . RPAREN SEMICOLON

    RPAREN          shift and go to state 142


state 106

    (113) fibonacci -> FIBONACCI LPAREN . exp RPAREN SEMICOLON
    (29) exp -> . texp
    (30) exp -> . texp OR exp
    (31) texp -> . gexp
    (32) texp -> . gexp AND texp
    (33) gexp -> . mexp
    (34) gexp -> . mexp gexpp mexp
    (39) mexp -> . t
    (40) mexp -> . mexp PLUS t
    (41) mexp -> . mexp MINUS t
    (42) t -> . f
    (43) t -> . t MULT f
    (44) t -> . t DIV f
    (45) f -> . LPAREN exp RPAREN
    (46) f -> . CTI
    (47) f -> . CTF
    (48) f -> . var
    (49) f -> . call
    (75) var -> . ID
    (76) call -> . ID LPAREN callp RPAREN

    LPAREN          shift and go to state 120
    CTI             shift and go to state 121
    CTF             shift and go to state 122
    ID              shift and go to state 124

    exp                            shift and go to state 143
    texp                           shift and go to state 115
    gexp                           shift and go to state 116
    mexp                           shift and go to state 117
    t                              shift and go to state 118
    f                              shift and go to state 119
    var                            shift and go to state 113
    call                           shift and go to state 123

state 107

    (114) factorial -> FACTORIAL LPAREN . exp RPAREN SEMICOLON
    (29) exp -> . texp
    (30) exp -> . texp OR exp
    (31) texp -> . gexp
    (32) texp -> . gexp AND texp
    (33) gexp -> . mexp
    (34) gexp -> . mexp gexpp mexp
    (39) mexp -> . t
    (40) mexp -> . mexp PLUS t
    (41) mexp -> . mexp MINUS t
    (42) t -> . f
    (43) t -> . t MULT f
    (44) t -> . t DIV f
    (45) f -> . LPAREN exp RPAREN
    (46) f -> . CTI
    (47) f -> . CTF
    (48) f -> . var
    (49) f -> . call
    (75) var -> . ID
    (76) call -> . ID LPAREN callp RPAREN

    LPAREN          shift and go to state 120
    CTI             shift and go to state 121
    CTF             shift and go to state 122
    ID              shift and go to state 124

    exp                            shift and go to state 144
    texp                           shift and go to state 115
    gexp                           shift and go to state 116
    mexp                           shift and go to state 117
    t                              shift and go to state 118
    f                              shift and go to state 119
    var                            shift and go to state 113
    call                           shift and go to state 123

state 108

    (115) mmult -> MMULT LPAREN . ID COMMA ID RPAREN SEMICOLON

    ID              shift and go to state 145


state 109

    (11) function -> FUNCTION decfunctype decfunc LPAREN param RPAREN LBRACE body . RETURN exp SEMICOLON RBRACE

    RETURN          shift and go to state 146


state 110

    (27) param -> type ID COMMA param .

    RPAREN          reduce using rule 27 (param -> type ID COMMA param .)


state 111

    (14) voidfunction -> FUNCTION VOID decfunc LPAREN param RPAREN LBRACE body . RBRACE

    RBRACE          shift and go to state 147


state 112

    (22) body -> decvar statements body .

    RBRACE          reduce using rule 22 (body -> decvar statements body .)
    RETURN          reduce using rule 22 (body -> decvar statements body .)


state 113

    (48) f -> var .

    MULT            reduce using rule 48 (f -> var .)
    DIV             reduce using rule 48 (f -> var .)
    PLUS            reduce using rule 48 (f -> var .)
    MINUS           reduce using rule 48 (f -> var .)
    LT              reduce using rule 48 (f -> var .)
    GT              reduce using rule 48 (f -> var .)
    IFEQUAL         reduce using rule 48 (f -> var .)
    DIFF            reduce using rule 48 (f -> var .)
    AND             reduce using rule 48 (f -> var .)
    OR              reduce using rule 48 (f -> var .)
    SEMICOLON       reduce using rule 48 (f -> var .)
    COMMA           reduce using rule 48 (f -> var .)
    RPAREN          reduce using rule 48 (f -> var .)
    RBRACKET        reduce using rule 48 (f -> var .)


state 114

    (70) assign -> var EQUAL exp . SEMICOLON

    SEMICOLON       shift and go to state 148


state 115

    (29) exp -> texp .
    (30) exp -> texp . OR exp

    SEMICOLON       reduce using rule 29 (exp -> texp .)
    COMMA           reduce using rule 29 (exp -> texp .)
    RPAREN          reduce using rule 29 (exp -> texp .)
    RBRACKET        reduce using rule 29 (exp -> texp .)
    OR              shift and go to state 149


state 116

    (31) texp -> gexp .
    (32) texp -> gexp . AND texp

    OR              reduce using rule 31 (texp -> gexp .)
    SEMICOLON       reduce using rule 31 (texp -> gexp .)
    COMMA           reduce using rule 31 (texp -> gexp .)
    RPAREN          reduce using rule 31 (texp -> gexp .)
    RBRACKET        reduce using rule 31 (texp -> gexp .)
    AND             shift and go to state 150


state 117

    (33) gexp -> mexp .
    (34) gexp -> mexp . gexpp mexp
    (40) mexp -> mexp . PLUS t
    (41) mexp -> mexp . MINUS t
    (35) gexpp -> . LT
    (36) gexpp -> . GT
    (37) gexpp -> . IFEQUAL
    (38) gexpp -> . DIFF

    AND             reduce using rule 33 (gexp -> mexp .)
    OR              reduce using rule 33 (gexp -> mexp .)
    SEMICOLON       reduce using rule 33 (gexp -> mexp .)
    COMMA           reduce using rule 33 (gexp -> mexp .)
    RPAREN          reduce using rule 33 (gexp -> mexp .)
    RBRACKET        reduce using rule 33 (gexp -> mexp .)
    PLUS            shift and go to state 152
    MINUS           shift and go to state 153
    LT              shift and go to state 154
    GT              shift and go to state 155
    IFEQUAL         shift and go to state 156
    DIFF            shift and go to state 157

    gexpp                          shift and go to state 151

state 118

    (39) mexp -> t .
    (43) t -> t . MULT f
    (44) t -> t . DIV f

    PLUS            reduce using rule 39 (mexp -> t .)
    MINUS           reduce using rule 39 (mexp -> t .)
    LT              reduce using rule 39 (mexp -> t .)
    GT              reduce using rule 39 (mexp -> t .)
    IFEQUAL         reduce using rule 39 (mexp -> t .)
    DIFF            reduce using rule 39 (mexp -> t .)
    AND             reduce using rule 39 (mexp -> t .)
    OR              reduce using rule 39 (mexp -> t .)
    SEMICOLON       reduce using rule 39 (mexp -> t .)
    COMMA           reduce using rule 39 (mexp -> t .)
    RPAREN          reduce using rule 39 (mexp -> t .)
    RBRACKET        reduce using rule 39 (mexp -> t .)
    MULT            shift and go to state 158
    DIV             shift and go to state 159


state 119

    (42) t -> f .

    MULT            reduce using rule 42 (t -> f .)
    DIV             reduce using rule 42 (t -> f .)
    PLUS            reduce using rule 42 (t -> f .)
    MINUS           reduce using rule 42 (t -> f .)
    LT              reduce using rule 42 (t -> f .)
    GT              reduce using rule 42 (t -> f .)
    IFEQUAL         reduce using rule 42 (t -> f .)
    DIFF            reduce using rule 42 (t -> f .)
    AND             reduce using rule 42 (t -> f .)
    OR              reduce using rule 42 (t -> f .)
    SEMICOLON       reduce using rule 42 (t -> f .)
    COMMA           reduce using rule 42 (t -> f .)
    RPAREN          reduce using rule 42 (t -> f .)
    RBRACKET        reduce using rule 42 (t -> f .)


state 120

    (45) f -> LPAREN . exp RPAREN
    (29) exp -> . texp
    (30) exp -> . texp OR exp
    (31) texp -> . gexp
    (32) texp -> . gexp AND texp
    (33) gexp -> . mexp
    (34) gexp -> . mexp gexpp mexp
    (39) mexp -> . t
    (40) mexp -> . mexp PLUS t
    (41) mexp -> . mexp MINUS t
    (42) t -> . f
    (43) t -> . t MULT f
    (44) t -> . t DIV f
    (45) f -> . LPAREN exp RPAREN
    (46) f -> . CTI
    (47) f -> . CTF
    (48) f -> . var
    (49) f -> . call
    (75) var -> . ID
    (76) call -> . ID LPAREN callp RPAREN

    LPAREN          shift and go to state 120
    CTI             shift and go to state 121
    CTF             shift and go to state 122
    ID              shift and go to state 124

    exp                            shift and go to state 160
    texp                           shift and go to state 115
    gexp                           shift and go to state 116
    mexp                           shift and go to state 117
    t                              shift and go to state 118
    f                              shift and go to state 119
    var                            shift and go to state 113
    call                           shift and go to state 123

state 121

    (46) f -> CTI .

    MULT            reduce using rule 46 (f -> CTI .)
    DIV             reduce using rule 46 (f -> CTI .)
    PLUS            reduce using rule 46 (f -> CTI .)
    MINUS           reduce using rule 46 (f -> CTI .)
    LT              reduce using rule 46 (f -> CTI .)
    GT              reduce using rule 46 (f -> CTI .)
    IFEQUAL         reduce using rule 46 (f -> CTI .)
    DIFF            reduce using rule 46 (f -> CTI .)
    AND             reduce using rule 46 (f -> CTI .)
    OR              reduce using rule 46 (f -> CTI .)
    SEMICOLON       reduce using rule 46 (f -> CTI .)
    COMMA           reduce using rule 46 (f -> CTI .)
    RPAREN          reduce using rule 46 (f -> CTI .)
    RBRACKET        reduce using rule 46 (f -> CTI .)


state 122

    (47) f -> CTF .

    MULT            reduce using rule 47 (f -> CTF .)
    DIV             reduce using rule 47 (f -> CTF .)
    PLUS            reduce using rule 47 (f -> CTF .)
    MINUS           reduce using rule 47 (f -> CTF .)
    LT              reduce using rule 47 (f -> CTF .)
    GT              reduce using rule 47 (f -> CTF .)
    IFEQUAL         reduce using rule 47 (f -> CTF .)
    DIFF            reduce using rule 47 (f -> CTF .)
    AND             reduce using rule 47 (f -> CTF .)
    OR              reduce using rule 47 (f -> CTF .)
    SEMICOLON       reduce using rule 47 (f -> CTF .)
    COMMA           reduce using rule 47 (f -> CTF .)
    RPAREN          reduce using rule 47 (f -> CTF .)
    RBRACKET        reduce using rule 47 (f -> CTF .)


state 123

    (49) f -> call .

    MULT            reduce using rule 49 (f -> call .)
    DIV             reduce using rule 49 (f -> call .)
    PLUS            reduce using rule 49 (f -> call .)
    MINUS           reduce using rule 49 (f -> call .)
    LT              reduce using rule 49 (f -> call .)
    GT              reduce using rule 49 (f -> call .)
    IFEQUAL         reduce using rule 49 (f -> call .)
    DIFF            reduce using rule 49 (f -> call .)
    AND             reduce using rule 49 (f -> call .)
    OR              reduce using rule 49 (f -> call .)
    SEMICOLON       reduce using rule 49 (f -> call .)
    COMMA           reduce using rule 49 (f -> call .)
    RPAREN          reduce using rule 49 (f -> call .)
    RBRACKET        reduce using rule 49 (f -> call .)


state 124

    (75) var -> ID .
    (76) call -> ID . LPAREN callp RPAREN

    MULT            reduce using rule 75 (var -> ID .)
    DIV             reduce using rule 75 (var -> ID .)
    PLUS            reduce using rule 75 (var -> ID .)
    MINUS           reduce using rule 75 (var -> ID .)
    LT              reduce using rule 75 (var -> ID .)
    GT              reduce using rule 75 (var -> ID .)
    IFEQUAL         reduce using rule 75 (var -> ID .)
    DIFF            reduce using rule 75 (var -> ID .)
    AND             reduce using rule 75 (var -> ID .)
    OR              reduce using rule 75 (var -> ID .)
    SEMICOLON       reduce using rule 75 (var -> ID .)
    COMMA           reduce using rule 75 (var -> ID .)
    RPAREN          reduce using rule 75 (var -> ID .)
    RBRACKET        reduce using rule 75 (var -> ID .)
    LPAREN          shift and go to state 92


state 125

    (76) call -> ID LPAREN callp . RPAREN

    RPAREN          shift and go to state 161


state 126

    (77) callp -> exp . COMMA callp
    (78) callp -> exp .

    COMMA           shift and go to state 162
    RPAREN          reduce using rule 78 (callp -> exp .)


state 127

    (71) read -> READ LPAREN var . RPAREN SEMICOLON

    RPAREN          shift and go to state 163


state 128

    (75) var -> ID .

    RPAREN          reduce using rule 75 (var -> ID .)


state 129

    (72) print -> PRINT LPAREN printp . SEMICOLON

    SEMICOLON       shift and go to state 164


state 130

    (73) printp -> exp . RPAREN
    (74) printp -> exp . COMMA printp

    RPAREN          shift and go to state 165
    COMMA           shift and go to state 166


state 131

    (80) if -> IF LPAREN ifexp . RPAREN quadsIf LBRACE body RBRACE ifelse jumpsIf SEMICOLON

    RPAREN          shift and go to state 167


state 132

    (81) ifexp -> exp .

    RPAREN          reduce using rule 81 (ifexp -> exp .)


state 133

    (87) while -> WHILE saveJumps LPAREN . whilexp RPAREN quadsWhile LBRACE body RBRACE jumpsWhile SEMICOLON
    (88) whilexp -> . exp
    (29) exp -> . texp
    (30) exp -> . texp OR exp
    (31) texp -> . gexp
    (32) texp -> . gexp AND texp
    (33) gexp -> . mexp
    (34) gexp -> . mexp gexpp mexp
    (39) mexp -> . t
    (40) mexp -> . mexp PLUS t
    (41) mexp -> . mexp MINUS t
    (42) t -> . f
    (43) t -> . t MULT f
    (44) t -> . t DIV f
    (45) f -> . LPAREN exp RPAREN
    (46) f -> . CTI
    (47) f -> . CTF
    (48) f -> . var
    (49) f -> . call
    (75) var -> . ID
    (76) call -> . ID LPAREN callp RPAREN

    LPAREN          shift and go to state 120
    CTI             shift and go to state 121
    CTF             shift and go to state 122
    ID              shift and go to state 124

    whilexp                        shift and go to state 168
    exp                            shift and go to state 169
    texp                           shift and go to state 115
    gexp                           shift and go to state 116
    mexp                           shift and go to state 117
    t                              shift and go to state 118
    f                              shift and go to state 119
    var                            shift and go to state 113
    call                           shift and go to state 123

state 134

    (100) array -> ARRAY ID LBRACKET . exp RBRACKET EQUAL LBRACKET arrvalues RBRACKET SEMICOLON
    (29) exp -> . texp
    (30) exp -> . texp OR exp
    (31) texp -> . gexp
    (32) texp -> . gexp AND texp
    (33) gexp -> . mexp
    (34) gexp -> . mexp gexpp mexp
    (39) mexp -> . t
    (40) mexp -> . mexp PLUS t
    (41) mexp -> . mexp MINUS t
    (42) t -> . f
    (43) t -> . t MULT f
    (44) t -> . t DIV f
    (45) f -> . LPAREN exp RPAREN
    (46) f -> . CTI
    (47) f -> . CTF
    (48) f -> . var
    (49) f -> . call
    (75) var -> . ID
    (76) call -> . ID LPAREN callp RPAREN

    LPAREN          shift and go to state 120
    CTI             shift and go to state 121
    CTF             shift and go to state 122
    ID              shift and go to state 124

    exp                            shift and go to state 170
    texp                           shift and go to state 115
    gexp                           shift and go to state 116
    mexp                           shift and go to state 117
    t                              shift and go to state 118
    f                              shift and go to state 119
    var                            shift and go to state 113
    call                           shift and go to state 123

state 135

    (103) matrix -> MATRIX ID LBRACKET . exp RBRACKET LBRACKET exp RBRACKET EQUAL LBRACKET matvalues RBRACKET SEMICOLON
    (29) exp -> . texp
    (30) exp -> . texp OR exp
    (31) texp -> . gexp
    (32) texp -> . gexp AND texp
    (33) gexp -> . mexp
    (34) gexp -> . mexp gexpp mexp
    (39) mexp -> . t
    (40) mexp -> . mexp PLUS t
    (41) mexp -> . mexp MINUS t
    (42) t -> . f
    (43) t -> . t MULT f
    (44) t -> . t DIV f
    (45) f -> . LPAREN exp RPAREN
    (46) f -> . CTI
    (47) f -> . CTF
    (48) f -> . var
    (49) f -> . call
    (75) var -> . ID
    (76) call -> . ID LPAREN callp RPAREN

    LPAREN          shift and go to state 120
    CTI             shift and go to state 121
    CTF             shift and go to state 122
    ID              shift and go to state 124

    exp                            shift and go to state 171
    texp                           shift and go to state 115
    gexp                           shift and go to state 116
    mexp                           shift and go to state 117
    t                              shift and go to state 118
    f                              shift and go to state 119
    var                            shift and go to state 113
    call                           shift and go to state 123

state 136

    (106) mean -> MEAN LPAREN ID . RPAREN SEMICOLON

    RPAREN          shift and go to state 172


state 137

    (107) layers -> LAYERS LPAREN UNITS . EQUAL CTI RPAREN SEMICOLON

    EQUAL           shift and go to state 173


state 138

    (108) sequential -> SEQUENTIAL LPAREN RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 174


state 139

    (109) compile -> COMPILE LPAREN CTF . RPAREN SEMICOLON

    RPAREN          shift and go to state 175


state 140

    (110) fit -> FIT LPAREN ID . COMMA ID COMMA EPOCHS EQUAL CTI RPAREN SEMICOLON

    COMMA           shift and go to state 176


state 141

    (111) predict -> PREDICT LPAREN CTF . RPAREN SEMICOLON

    RPAREN          shift and go to state 177


state 142

    (112) getweights -> GETWEIGHTS LPAREN RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 178


state 143

    (113) fibonacci -> FIBONACCI LPAREN exp . RPAREN SEMICOLON

    RPAREN          shift and go to state 179


state 144

    (114) factorial -> FACTORIAL LPAREN exp . RPAREN SEMICOLON

    RPAREN          shift and go to state 180


state 145

    (115) mmult -> MMULT LPAREN ID . COMMA ID RPAREN SEMICOLON

    COMMA           shift and go to state 181


state 146

    (11) function -> FUNCTION decfunctype decfunc LPAREN param RPAREN LBRACE body RETURN . exp SEMICOLON RBRACE
    (29) exp -> . texp
    (30) exp -> . texp OR exp
    (31) texp -> . gexp
    (32) texp -> . gexp AND texp
    (33) gexp -> . mexp
    (34) gexp -> . mexp gexpp mexp
    (39) mexp -> . t
    (40) mexp -> . mexp PLUS t
    (41) mexp -> . mexp MINUS t
    (42) t -> . f
    (43) t -> . t MULT f
    (44) t -> . t DIV f
    (45) f -> . LPAREN exp RPAREN
    (46) f -> . CTI
    (47) f -> . CTF
    (48) f -> . var
    (49) f -> . call
    (75) var -> . ID
    (76) call -> . ID LPAREN callp RPAREN

    LPAREN          shift and go to state 120
    CTI             shift and go to state 121
    CTF             shift and go to state 122
    ID              shift and go to state 124

    exp                            shift and go to state 182
    texp                           shift and go to state 115
    gexp                           shift and go to state 116
    mexp                           shift and go to state 117
    t                              shift and go to state 118
    f                              shift and go to state 119
    var                            shift and go to state 113
    call                           shift and go to state 123

state 147

    (14) voidfunction -> FUNCTION VOID decfunc LPAREN param RPAREN LBRACE body RBRACE .

    FUNCTION        reduce using rule 14 (voidfunction -> FUNCTION VOID decfunc LPAREN param RPAREN LBRACE body RBRACE .)
    MAIN            reduce using rule 14 (voidfunction -> FUNCTION VOID decfunc LPAREN param RPAREN LBRACE body RBRACE .)
    VAR             reduce using rule 14 (voidfunction -> FUNCTION VOID decfunc LPAREN param RPAREN LBRACE body RBRACE .)
    ID              reduce using rule 14 (voidfunction -> FUNCTION VOID decfunc LPAREN param RPAREN LBRACE body RBRACE .)
    READ            reduce using rule 14 (voidfunction -> FUNCTION VOID decfunc LPAREN param RPAREN LBRACE body RBRACE .)
    PRINT           reduce using rule 14 (voidfunction -> FUNCTION VOID decfunc LPAREN param RPAREN LBRACE body RBRACE .)
    IF              reduce using rule 14 (voidfunction -> FUNCTION VOID decfunc LPAREN param RPAREN LBRACE body RBRACE .)
    WHILE           reduce using rule 14 (voidfunction -> FUNCTION VOID decfunc LPAREN param RPAREN LBRACE body RBRACE .)
    ARRAY           reduce using rule 14 (voidfunction -> FUNCTION VOID decfunc LPAREN param RPAREN LBRACE body RBRACE .)
    MATRIX          reduce using rule 14 (voidfunction -> FUNCTION VOID decfunc LPAREN param RPAREN LBRACE body RBRACE .)
    MEAN            reduce using rule 14 (voidfunction -> FUNCTION VOID decfunc LPAREN param RPAREN LBRACE body RBRACE .)
    LAYERS          reduce using rule 14 (voidfunction -> FUNCTION VOID decfunc LPAREN param RPAREN LBRACE body RBRACE .)
    SEQUENTIAL      reduce using rule 14 (voidfunction -> FUNCTION VOID decfunc LPAREN param RPAREN LBRACE body RBRACE .)
    COMPILE         reduce using rule 14 (voidfunction -> FUNCTION VOID decfunc LPAREN param RPAREN LBRACE body RBRACE .)
    FIT             reduce using rule 14 (voidfunction -> FUNCTION VOID decfunc LPAREN param RPAREN LBRACE body RBRACE .)
    PREDICT         reduce using rule 14 (voidfunction -> FUNCTION VOID decfunc LPAREN param RPAREN LBRACE body RBRACE .)
    GETWEIGHTS      reduce using rule 14 (voidfunction -> FUNCTION VOID decfunc LPAREN param RPAREN LBRACE body RBRACE .)
    FIBONACCI       reduce using rule 14 (voidfunction -> FUNCTION VOID decfunc LPAREN param RPAREN LBRACE body RBRACE .)
    FACTORIAL       reduce using rule 14 (voidfunction -> FUNCTION VOID decfunc LPAREN param RPAREN LBRACE body RBRACE .)
    MMULT           reduce using rule 14 (voidfunction -> FUNCTION VOID decfunc LPAREN param RPAREN LBRACE body RBRACE .)
    RBRACE          reduce using rule 14 (voidfunction -> FUNCTION VOID decfunc LPAREN param RPAREN LBRACE body RBRACE .)
    RETURN          reduce using rule 14 (voidfunction -> FUNCTION VOID decfunc LPAREN param RPAREN LBRACE body RBRACE .)


state 148

    (70) assign -> var EQUAL exp SEMICOLON .

    VAR             reduce using rule 70 (assign -> var EQUAL exp SEMICOLON .)
    FUNCTION        reduce using rule 70 (assign -> var EQUAL exp SEMICOLON .)
    ID              reduce using rule 70 (assign -> var EQUAL exp SEMICOLON .)
    READ            reduce using rule 70 (assign -> var EQUAL exp SEMICOLON .)
    PRINT           reduce using rule 70 (assign -> var EQUAL exp SEMICOLON .)
    IF              reduce using rule 70 (assign -> var EQUAL exp SEMICOLON .)
    WHILE           reduce using rule 70 (assign -> var EQUAL exp SEMICOLON .)
    ARRAY           reduce using rule 70 (assign -> var EQUAL exp SEMICOLON .)
    MATRIX          reduce using rule 70 (assign -> var EQUAL exp SEMICOLON .)
    MEAN            reduce using rule 70 (assign -> var EQUAL exp SEMICOLON .)
    LAYERS          reduce using rule 70 (assign -> var EQUAL exp SEMICOLON .)
    SEQUENTIAL      reduce using rule 70 (assign -> var EQUAL exp SEMICOLON .)
    COMPILE         reduce using rule 70 (assign -> var EQUAL exp SEMICOLON .)
    FIT             reduce using rule 70 (assign -> var EQUAL exp SEMICOLON .)
    PREDICT         reduce using rule 70 (assign -> var EQUAL exp SEMICOLON .)
    GETWEIGHTS      reduce using rule 70 (assign -> var EQUAL exp SEMICOLON .)
    FIBONACCI       reduce using rule 70 (assign -> var EQUAL exp SEMICOLON .)
    FACTORIAL       reduce using rule 70 (assign -> var EQUAL exp SEMICOLON .)
    MMULT           reduce using rule 70 (assign -> var EQUAL exp SEMICOLON .)
    RBRACE          reduce using rule 70 (assign -> var EQUAL exp SEMICOLON .)
    RETURN          reduce using rule 70 (assign -> var EQUAL exp SEMICOLON .)


state 149

    (30) exp -> texp OR . exp
    (29) exp -> . texp
    (30) exp -> . texp OR exp
    (31) texp -> . gexp
    (32) texp -> . gexp AND texp
    (33) gexp -> . mexp
    (34) gexp -> . mexp gexpp mexp
    (39) mexp -> . t
    (40) mexp -> . mexp PLUS t
    (41) mexp -> . mexp MINUS t
    (42) t -> . f
    (43) t -> . t MULT f
    (44) t -> . t DIV f
    (45) f -> . LPAREN exp RPAREN
    (46) f -> . CTI
    (47) f -> . CTF
    (48) f -> . var
    (49) f -> . call
    (75) var -> . ID
    (76) call -> . ID LPAREN callp RPAREN

    LPAREN          shift and go to state 120
    CTI             shift and go to state 121
    CTF             shift and go to state 122
    ID              shift and go to state 124

    texp                           shift and go to state 115
    exp                            shift and go to state 183
    gexp                           shift and go to state 116
    mexp                           shift and go to state 117
    t                              shift and go to state 118
    f                              shift and go to state 119
    var                            shift and go to state 113
    call                           shift and go to state 123

state 150

    (32) texp -> gexp AND . texp
    (31) texp -> . gexp
    (32) texp -> . gexp AND texp
    (33) gexp -> . mexp
    (34) gexp -> . mexp gexpp mexp
    (39) mexp -> . t
    (40) mexp -> . mexp PLUS t
    (41) mexp -> . mexp MINUS t
    (42) t -> . f
    (43) t -> . t MULT f
    (44) t -> . t DIV f
    (45) f -> . LPAREN exp RPAREN
    (46) f -> . CTI
    (47) f -> . CTF
    (48) f -> . var
    (49) f -> . call
    (75) var -> . ID
    (76) call -> . ID LPAREN callp RPAREN

    LPAREN          shift and go to state 120
    CTI             shift and go to state 121
    CTF             shift and go to state 122
    ID              shift and go to state 124

    gexp                           shift and go to state 116
    texp                           shift and go to state 184
    mexp                           shift and go to state 117
    t                              shift and go to state 118
    f                              shift and go to state 119
    var                            shift and go to state 113
    call                           shift and go to state 123

state 151

    (34) gexp -> mexp gexpp . mexp
    (39) mexp -> . t
    (40) mexp -> . mexp PLUS t
    (41) mexp -> . mexp MINUS t
    (42) t -> . f
    (43) t -> . t MULT f
    (44) t -> . t DIV f
    (45) f -> . LPAREN exp RPAREN
    (46) f -> . CTI
    (47) f -> . CTF
    (48) f -> . var
    (49) f -> . call
    (75) var -> . ID
    (76) call -> . ID LPAREN callp RPAREN

    LPAREN          shift and go to state 120
    CTI             shift and go to state 121
    CTF             shift and go to state 122
    ID              shift and go to state 124

    mexp                           shift and go to state 185
    t                              shift and go to state 118
    f                              shift and go to state 119
    var                            shift and go to state 113
    call                           shift and go to state 123

state 152

    (40) mexp -> mexp PLUS . t
    (42) t -> . f
    (43) t -> . t MULT f
    (44) t -> . t DIV f
    (45) f -> . LPAREN exp RPAREN
    (46) f -> . CTI
    (47) f -> . CTF
    (48) f -> . var
    (49) f -> . call
    (75) var -> . ID
    (76) call -> . ID LPAREN callp RPAREN

    LPAREN          shift and go to state 120
    CTI             shift and go to state 121
    CTF             shift and go to state 122
    ID              shift and go to state 124

    t                              shift and go to state 186
    f                              shift and go to state 119
    var                            shift and go to state 113
    call                           shift and go to state 123

state 153

    (41) mexp -> mexp MINUS . t
    (42) t -> . f
    (43) t -> . t MULT f
    (44) t -> . t DIV f
    (45) f -> . LPAREN exp RPAREN
    (46) f -> . CTI
    (47) f -> . CTF
    (48) f -> . var
    (49) f -> . call
    (75) var -> . ID
    (76) call -> . ID LPAREN callp RPAREN

    LPAREN          shift and go to state 120
    CTI             shift and go to state 121
    CTF             shift and go to state 122
    ID              shift and go to state 124

    t                              shift and go to state 187
    f                              shift and go to state 119
    var                            shift and go to state 113
    call                           shift and go to state 123

state 154

    (35) gexpp -> LT .

    LPAREN          reduce using rule 35 (gexpp -> LT .)
    CTI             reduce using rule 35 (gexpp -> LT .)
    CTF             reduce using rule 35 (gexpp -> LT .)
    ID              reduce using rule 35 (gexpp -> LT .)


state 155

    (36) gexpp -> GT .

    LPAREN          reduce using rule 36 (gexpp -> GT .)
    CTI             reduce using rule 36 (gexpp -> GT .)
    CTF             reduce using rule 36 (gexpp -> GT .)
    ID              reduce using rule 36 (gexpp -> GT .)


state 156

    (37) gexpp -> IFEQUAL .

    LPAREN          reduce using rule 37 (gexpp -> IFEQUAL .)
    CTI             reduce using rule 37 (gexpp -> IFEQUAL .)
    CTF             reduce using rule 37 (gexpp -> IFEQUAL .)
    ID              reduce using rule 37 (gexpp -> IFEQUAL .)


state 157

    (38) gexpp -> DIFF .

    LPAREN          reduce using rule 38 (gexpp -> DIFF .)
    CTI             reduce using rule 38 (gexpp -> DIFF .)
    CTF             reduce using rule 38 (gexpp -> DIFF .)
    ID              reduce using rule 38 (gexpp -> DIFF .)


state 158

    (43) t -> t MULT . f
    (45) f -> . LPAREN exp RPAREN
    (46) f -> . CTI
    (47) f -> . CTF
    (48) f -> . var
    (49) f -> . call
    (75) var -> . ID
    (76) call -> . ID LPAREN callp RPAREN

    LPAREN          shift and go to state 120
    CTI             shift and go to state 121
    CTF             shift and go to state 122
    ID              shift and go to state 124

    f                              shift and go to state 188
    var                            shift and go to state 113
    call                           shift and go to state 123

state 159

    (44) t -> t DIV . f
    (45) f -> . LPAREN exp RPAREN
    (46) f -> . CTI
    (47) f -> . CTF
    (48) f -> . var
    (49) f -> . call
    (75) var -> . ID
    (76) call -> . ID LPAREN callp RPAREN

    LPAREN          shift and go to state 120
    CTI             shift and go to state 121
    CTF             shift and go to state 122
    ID              shift and go to state 124

    f                              shift and go to state 189
    var                            shift and go to state 113
    call                           shift and go to state 123

state 160

    (45) f -> LPAREN exp . RPAREN

    RPAREN          shift and go to state 190


state 161

    (76) call -> ID LPAREN callp RPAREN .

    VAR             reduce using rule 76 (call -> ID LPAREN callp RPAREN .)
    FUNCTION        reduce using rule 76 (call -> ID LPAREN callp RPAREN .)
    ID              reduce using rule 76 (call -> ID LPAREN callp RPAREN .)
    READ            reduce using rule 76 (call -> ID LPAREN callp RPAREN .)
    PRINT           reduce using rule 76 (call -> ID LPAREN callp RPAREN .)
    IF              reduce using rule 76 (call -> ID LPAREN callp RPAREN .)
    WHILE           reduce using rule 76 (call -> ID LPAREN callp RPAREN .)
    ARRAY           reduce using rule 76 (call -> ID LPAREN callp RPAREN .)
    MATRIX          reduce using rule 76 (call -> ID LPAREN callp RPAREN .)
    MEAN            reduce using rule 76 (call -> ID LPAREN callp RPAREN .)
    LAYERS          reduce using rule 76 (call -> ID LPAREN callp RPAREN .)
    SEQUENTIAL      reduce using rule 76 (call -> ID LPAREN callp RPAREN .)
    COMPILE         reduce using rule 76 (call -> ID LPAREN callp RPAREN .)
    FIT             reduce using rule 76 (call -> ID LPAREN callp RPAREN .)
    PREDICT         reduce using rule 76 (call -> ID LPAREN callp RPAREN .)
    GETWEIGHTS      reduce using rule 76 (call -> ID LPAREN callp RPAREN .)
    FIBONACCI       reduce using rule 76 (call -> ID LPAREN callp RPAREN .)
    FACTORIAL       reduce using rule 76 (call -> ID LPAREN callp RPAREN .)
    MMULT           reduce using rule 76 (call -> ID LPAREN callp RPAREN .)
    RBRACE          reduce using rule 76 (call -> ID LPAREN callp RPAREN .)
    RETURN          reduce using rule 76 (call -> ID LPAREN callp RPAREN .)
    MULT            reduce using rule 76 (call -> ID LPAREN callp RPAREN .)
    DIV             reduce using rule 76 (call -> ID LPAREN callp RPAREN .)
    PLUS            reduce using rule 76 (call -> ID LPAREN callp RPAREN .)
    MINUS           reduce using rule 76 (call -> ID LPAREN callp RPAREN .)
    LT              reduce using rule 76 (call -> ID LPAREN callp RPAREN .)
    GT              reduce using rule 76 (call -> ID LPAREN callp RPAREN .)
    IFEQUAL         reduce using rule 76 (call -> ID LPAREN callp RPAREN .)
    DIFF            reduce using rule 76 (call -> ID LPAREN callp RPAREN .)
    AND             reduce using rule 76 (call -> ID LPAREN callp RPAREN .)
    OR              reduce using rule 76 (call -> ID LPAREN callp RPAREN .)
    SEMICOLON       reduce using rule 76 (call -> ID LPAREN callp RPAREN .)
    COMMA           reduce using rule 76 (call -> ID LPAREN callp RPAREN .)
    RPAREN          reduce using rule 76 (call -> ID LPAREN callp RPAREN .)
    RBRACKET        reduce using rule 76 (call -> ID LPAREN callp RPAREN .)


state 162

    (77) callp -> exp COMMA . callp
    (77) callp -> . exp COMMA callp
    (78) callp -> . exp
    (79) callp -> .
    (29) exp -> . texp
    (30) exp -> . texp OR exp
    (31) texp -> . gexp
    (32) texp -> . gexp AND texp
    (33) gexp -> . mexp
    (34) gexp -> . mexp gexpp mexp
    (39) mexp -> . t
    (40) mexp -> . mexp PLUS t
    (41) mexp -> . mexp MINUS t
    (42) t -> . f
    (43) t -> . t MULT f
    (44) t -> . t DIV f
    (45) f -> . LPAREN exp RPAREN
    (46) f -> . CTI
    (47) f -> . CTF
    (48) f -> . var
    (49) f -> . call
    (75) var -> . ID
    (76) call -> . ID LPAREN callp RPAREN

    RPAREN          reduce using rule 79 (callp -> .)
    LPAREN          shift and go to state 120
    CTI             shift and go to state 121
    CTF             shift and go to state 122
    ID              shift and go to state 124

    exp                            shift and go to state 126
    callp                          shift and go to state 191
    texp                           shift and go to state 115
    gexp                           shift and go to state 116
    mexp                           shift and go to state 117
    t                              shift and go to state 118
    f                              shift and go to state 119
    var                            shift and go to state 113
    call                           shift and go to state 123

state 163

    (71) read -> READ LPAREN var RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 192


state 164

    (72) print -> PRINT LPAREN printp SEMICOLON .

    VAR             reduce using rule 72 (print -> PRINT LPAREN printp SEMICOLON .)
    FUNCTION        reduce using rule 72 (print -> PRINT LPAREN printp SEMICOLON .)
    ID              reduce using rule 72 (print -> PRINT LPAREN printp SEMICOLON .)
    READ            reduce using rule 72 (print -> PRINT LPAREN printp SEMICOLON .)
    PRINT           reduce using rule 72 (print -> PRINT LPAREN printp SEMICOLON .)
    IF              reduce using rule 72 (print -> PRINT LPAREN printp SEMICOLON .)
    WHILE           reduce using rule 72 (print -> PRINT LPAREN printp SEMICOLON .)
    ARRAY           reduce using rule 72 (print -> PRINT LPAREN printp SEMICOLON .)
    MATRIX          reduce using rule 72 (print -> PRINT LPAREN printp SEMICOLON .)
    MEAN            reduce using rule 72 (print -> PRINT LPAREN printp SEMICOLON .)
    LAYERS          reduce using rule 72 (print -> PRINT LPAREN printp SEMICOLON .)
    SEQUENTIAL      reduce using rule 72 (print -> PRINT LPAREN printp SEMICOLON .)
    COMPILE         reduce using rule 72 (print -> PRINT LPAREN printp SEMICOLON .)
    FIT             reduce using rule 72 (print -> PRINT LPAREN printp SEMICOLON .)
    PREDICT         reduce using rule 72 (print -> PRINT LPAREN printp SEMICOLON .)
    GETWEIGHTS      reduce using rule 72 (print -> PRINT LPAREN printp SEMICOLON .)
    FIBONACCI       reduce using rule 72 (print -> PRINT LPAREN printp SEMICOLON .)
    FACTORIAL       reduce using rule 72 (print -> PRINT LPAREN printp SEMICOLON .)
    MMULT           reduce using rule 72 (print -> PRINT LPAREN printp SEMICOLON .)
    RBRACE          reduce using rule 72 (print -> PRINT LPAREN printp SEMICOLON .)
    RETURN          reduce using rule 72 (print -> PRINT LPAREN printp SEMICOLON .)


state 165

    (73) printp -> exp RPAREN .

    SEMICOLON       reduce using rule 73 (printp -> exp RPAREN .)


state 166

    (74) printp -> exp COMMA . printp
    (73) printp -> . exp RPAREN
    (74) printp -> . exp COMMA printp
    (29) exp -> . texp
    (30) exp -> . texp OR exp
    (31) texp -> . gexp
    (32) texp -> . gexp AND texp
    (33) gexp -> . mexp
    (34) gexp -> . mexp gexpp mexp
    (39) mexp -> . t
    (40) mexp -> . mexp PLUS t
    (41) mexp -> . mexp MINUS t
    (42) t -> . f
    (43) t -> . t MULT f
    (44) t -> . t DIV f
    (45) f -> . LPAREN exp RPAREN
    (46) f -> . CTI
    (47) f -> . CTF
    (48) f -> . var
    (49) f -> . call
    (75) var -> . ID
    (76) call -> . ID LPAREN callp RPAREN

    LPAREN          shift and go to state 120
    CTI             shift and go to state 121
    CTF             shift and go to state 122
    ID              shift and go to state 124

    exp                            shift and go to state 130
    printp                         shift and go to state 193
    texp                           shift and go to state 115
    gexp                           shift and go to state 116
    mexp                           shift and go to state 117
    t                              shift and go to state 118
    f                              shift and go to state 119
    var                            shift and go to state 113
    call                           shift and go to state 123

state 167

    (80) if -> IF LPAREN ifexp RPAREN . quadsIf LBRACE body RBRACE ifelse jumpsIf SEMICOLON
    (84) quadsIf -> .

    LBRACE          reduce using rule 84 (quadsIf -> .)

    quadsIf                        shift and go to state 194

state 168

    (87) while -> WHILE saveJumps LPAREN whilexp . RPAREN quadsWhile LBRACE body RBRACE jumpsWhile SEMICOLON

    RPAREN          shift and go to state 195


state 169

    (88) whilexp -> exp .

    RPAREN          reduce using rule 88 (whilexp -> exp .)


state 170

    (100) array -> ARRAY ID LBRACKET exp . RBRACKET EQUAL LBRACKET arrvalues RBRACKET SEMICOLON

    RBRACKET        shift and go to state 196


state 171

    (103) matrix -> MATRIX ID LBRACKET exp . RBRACKET LBRACKET exp RBRACKET EQUAL LBRACKET matvalues RBRACKET SEMICOLON

    RBRACKET        shift and go to state 197


state 172

    (106) mean -> MEAN LPAREN ID RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 198


state 173

    (107) layers -> LAYERS LPAREN UNITS EQUAL . CTI RPAREN SEMICOLON

    CTI             shift and go to state 199


state 174

    (108) sequential -> SEQUENTIAL LPAREN RPAREN SEMICOLON .

    VAR             reduce using rule 108 (sequential -> SEQUENTIAL LPAREN RPAREN SEMICOLON .)
    FUNCTION        reduce using rule 108 (sequential -> SEQUENTIAL LPAREN RPAREN SEMICOLON .)
    ID              reduce using rule 108 (sequential -> SEQUENTIAL LPAREN RPAREN SEMICOLON .)
    READ            reduce using rule 108 (sequential -> SEQUENTIAL LPAREN RPAREN SEMICOLON .)
    PRINT           reduce using rule 108 (sequential -> SEQUENTIAL LPAREN RPAREN SEMICOLON .)
    IF              reduce using rule 108 (sequential -> SEQUENTIAL LPAREN RPAREN SEMICOLON .)
    WHILE           reduce using rule 108 (sequential -> SEQUENTIAL LPAREN RPAREN SEMICOLON .)
    ARRAY           reduce using rule 108 (sequential -> SEQUENTIAL LPAREN RPAREN SEMICOLON .)
    MATRIX          reduce using rule 108 (sequential -> SEQUENTIAL LPAREN RPAREN SEMICOLON .)
    MEAN            reduce using rule 108 (sequential -> SEQUENTIAL LPAREN RPAREN SEMICOLON .)
    LAYERS          reduce using rule 108 (sequential -> SEQUENTIAL LPAREN RPAREN SEMICOLON .)
    SEQUENTIAL      reduce using rule 108 (sequential -> SEQUENTIAL LPAREN RPAREN SEMICOLON .)
    COMPILE         reduce using rule 108 (sequential -> SEQUENTIAL LPAREN RPAREN SEMICOLON .)
    FIT             reduce using rule 108 (sequential -> SEQUENTIAL LPAREN RPAREN SEMICOLON .)
    PREDICT         reduce using rule 108 (sequential -> SEQUENTIAL LPAREN RPAREN SEMICOLON .)
    GETWEIGHTS      reduce using rule 108 (sequential -> SEQUENTIAL LPAREN RPAREN SEMICOLON .)
    FIBONACCI       reduce using rule 108 (sequential -> SEQUENTIAL LPAREN RPAREN SEMICOLON .)
    FACTORIAL       reduce using rule 108 (sequential -> SEQUENTIAL LPAREN RPAREN SEMICOLON .)
    MMULT           reduce using rule 108 (sequential -> SEQUENTIAL LPAREN RPAREN SEMICOLON .)
    RBRACE          reduce using rule 108 (sequential -> SEQUENTIAL LPAREN RPAREN SEMICOLON .)
    RETURN          reduce using rule 108 (sequential -> SEQUENTIAL LPAREN RPAREN SEMICOLON .)


state 175

    (109) compile -> COMPILE LPAREN CTF RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 200


state 176

    (110) fit -> FIT LPAREN ID COMMA . ID COMMA EPOCHS EQUAL CTI RPAREN SEMICOLON

    ID              shift and go to state 201


state 177

    (111) predict -> PREDICT LPAREN CTF RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 202


state 178

    (112) getweights -> GETWEIGHTS LPAREN RPAREN SEMICOLON .

    VAR             reduce using rule 112 (getweights -> GETWEIGHTS LPAREN RPAREN SEMICOLON .)
    FUNCTION        reduce using rule 112 (getweights -> GETWEIGHTS LPAREN RPAREN SEMICOLON .)
    ID              reduce using rule 112 (getweights -> GETWEIGHTS LPAREN RPAREN SEMICOLON .)
    READ            reduce using rule 112 (getweights -> GETWEIGHTS LPAREN RPAREN SEMICOLON .)
    PRINT           reduce using rule 112 (getweights -> GETWEIGHTS LPAREN RPAREN SEMICOLON .)
    IF              reduce using rule 112 (getweights -> GETWEIGHTS LPAREN RPAREN SEMICOLON .)
    WHILE           reduce using rule 112 (getweights -> GETWEIGHTS LPAREN RPAREN SEMICOLON .)
    ARRAY           reduce using rule 112 (getweights -> GETWEIGHTS LPAREN RPAREN SEMICOLON .)
    MATRIX          reduce using rule 112 (getweights -> GETWEIGHTS LPAREN RPAREN SEMICOLON .)
    MEAN            reduce using rule 112 (getweights -> GETWEIGHTS LPAREN RPAREN SEMICOLON .)
    LAYERS          reduce using rule 112 (getweights -> GETWEIGHTS LPAREN RPAREN SEMICOLON .)
    SEQUENTIAL      reduce using rule 112 (getweights -> GETWEIGHTS LPAREN RPAREN SEMICOLON .)
    COMPILE         reduce using rule 112 (getweights -> GETWEIGHTS LPAREN RPAREN SEMICOLON .)
    FIT             reduce using rule 112 (getweights -> GETWEIGHTS LPAREN RPAREN SEMICOLON .)
    PREDICT         reduce using rule 112 (getweights -> GETWEIGHTS LPAREN RPAREN SEMICOLON .)
    GETWEIGHTS      reduce using rule 112 (getweights -> GETWEIGHTS LPAREN RPAREN SEMICOLON .)
    FIBONACCI       reduce using rule 112 (getweights -> GETWEIGHTS LPAREN RPAREN SEMICOLON .)
    FACTORIAL       reduce using rule 112 (getweights -> GETWEIGHTS LPAREN RPAREN SEMICOLON .)
    MMULT           reduce using rule 112 (getweights -> GETWEIGHTS LPAREN RPAREN SEMICOLON .)
    RBRACE          reduce using rule 112 (getweights -> GETWEIGHTS LPAREN RPAREN SEMICOLON .)
    RETURN          reduce using rule 112 (getweights -> GETWEIGHTS LPAREN RPAREN SEMICOLON .)


state 179

    (113) fibonacci -> FIBONACCI LPAREN exp RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 203


state 180

    (114) factorial -> FACTORIAL LPAREN exp RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 204


state 181

    (115) mmult -> MMULT LPAREN ID COMMA . ID RPAREN SEMICOLON

    ID              shift and go to state 205


state 182

    (11) function -> FUNCTION decfunctype decfunc LPAREN param RPAREN LBRACE body RETURN exp . SEMICOLON RBRACE

    SEMICOLON       shift and go to state 206


state 183

    (30) exp -> texp OR exp .

    SEMICOLON       reduce using rule 30 (exp -> texp OR exp .)
    COMMA           reduce using rule 30 (exp -> texp OR exp .)
    RPAREN          reduce using rule 30 (exp -> texp OR exp .)
    RBRACKET        reduce using rule 30 (exp -> texp OR exp .)


state 184

    (32) texp -> gexp AND texp .

    OR              reduce using rule 32 (texp -> gexp AND texp .)
    SEMICOLON       reduce using rule 32 (texp -> gexp AND texp .)
    COMMA           reduce using rule 32 (texp -> gexp AND texp .)
    RPAREN          reduce using rule 32 (texp -> gexp AND texp .)
    RBRACKET        reduce using rule 32 (texp -> gexp AND texp .)


state 185

    (34) gexp -> mexp gexpp mexp .
    (40) mexp -> mexp . PLUS t
    (41) mexp -> mexp . MINUS t

    AND             reduce using rule 34 (gexp -> mexp gexpp mexp .)
    OR              reduce using rule 34 (gexp -> mexp gexpp mexp .)
    SEMICOLON       reduce using rule 34 (gexp -> mexp gexpp mexp .)
    COMMA           reduce using rule 34 (gexp -> mexp gexpp mexp .)
    RPAREN          reduce using rule 34 (gexp -> mexp gexpp mexp .)
    RBRACKET        reduce using rule 34 (gexp -> mexp gexpp mexp .)
    PLUS            shift and go to state 152
    MINUS           shift and go to state 153


state 186

    (40) mexp -> mexp PLUS t .
    (43) t -> t . MULT f
    (44) t -> t . DIV f

    PLUS            reduce using rule 40 (mexp -> mexp PLUS t .)
    MINUS           reduce using rule 40 (mexp -> mexp PLUS t .)
    LT              reduce using rule 40 (mexp -> mexp PLUS t .)
    GT              reduce using rule 40 (mexp -> mexp PLUS t .)
    IFEQUAL         reduce using rule 40 (mexp -> mexp PLUS t .)
    DIFF            reduce using rule 40 (mexp -> mexp PLUS t .)
    AND             reduce using rule 40 (mexp -> mexp PLUS t .)
    OR              reduce using rule 40 (mexp -> mexp PLUS t .)
    SEMICOLON       reduce using rule 40 (mexp -> mexp PLUS t .)
    COMMA           reduce using rule 40 (mexp -> mexp PLUS t .)
    RPAREN          reduce using rule 40 (mexp -> mexp PLUS t .)
    RBRACKET        reduce using rule 40 (mexp -> mexp PLUS t .)
    MULT            shift and go to state 158
    DIV             shift and go to state 159


state 187

    (41) mexp -> mexp MINUS t .
    (43) t -> t . MULT f
    (44) t -> t . DIV f

    PLUS            reduce using rule 41 (mexp -> mexp MINUS t .)
    MINUS           reduce using rule 41 (mexp -> mexp MINUS t .)
    LT              reduce using rule 41 (mexp -> mexp MINUS t .)
    GT              reduce using rule 41 (mexp -> mexp MINUS t .)
    IFEQUAL         reduce using rule 41 (mexp -> mexp MINUS t .)
    DIFF            reduce using rule 41 (mexp -> mexp MINUS t .)
    AND             reduce using rule 41 (mexp -> mexp MINUS t .)
    OR              reduce using rule 41 (mexp -> mexp MINUS t .)
    SEMICOLON       reduce using rule 41 (mexp -> mexp MINUS t .)
    COMMA           reduce using rule 41 (mexp -> mexp MINUS t .)
    RPAREN          reduce using rule 41 (mexp -> mexp MINUS t .)
    RBRACKET        reduce using rule 41 (mexp -> mexp MINUS t .)
    MULT            shift and go to state 158
    DIV             shift and go to state 159


state 188

    (43) t -> t MULT f .

    MULT            reduce using rule 43 (t -> t MULT f .)
    DIV             reduce using rule 43 (t -> t MULT f .)
    PLUS            reduce using rule 43 (t -> t MULT f .)
    MINUS           reduce using rule 43 (t -> t MULT f .)
    LT              reduce using rule 43 (t -> t MULT f .)
    GT              reduce using rule 43 (t -> t MULT f .)
    IFEQUAL         reduce using rule 43 (t -> t MULT f .)
    DIFF            reduce using rule 43 (t -> t MULT f .)
    AND             reduce using rule 43 (t -> t MULT f .)
    OR              reduce using rule 43 (t -> t MULT f .)
    SEMICOLON       reduce using rule 43 (t -> t MULT f .)
    COMMA           reduce using rule 43 (t -> t MULT f .)
    RPAREN          reduce using rule 43 (t -> t MULT f .)
    RBRACKET        reduce using rule 43 (t -> t MULT f .)


state 189

    (44) t -> t DIV f .

    MULT            reduce using rule 44 (t -> t DIV f .)
    DIV             reduce using rule 44 (t -> t DIV f .)
    PLUS            reduce using rule 44 (t -> t DIV f .)
    MINUS           reduce using rule 44 (t -> t DIV f .)
    LT              reduce using rule 44 (t -> t DIV f .)
    GT              reduce using rule 44 (t -> t DIV f .)
    IFEQUAL         reduce using rule 44 (t -> t DIV f .)
    DIFF            reduce using rule 44 (t -> t DIV f .)
    AND             reduce using rule 44 (t -> t DIV f .)
    OR              reduce using rule 44 (t -> t DIV f .)
    SEMICOLON       reduce using rule 44 (t -> t DIV f .)
    COMMA           reduce using rule 44 (t -> t DIV f .)
    RPAREN          reduce using rule 44 (t -> t DIV f .)
    RBRACKET        reduce using rule 44 (t -> t DIV f .)


state 190

    (45) f -> LPAREN exp RPAREN .

    MULT            reduce using rule 45 (f -> LPAREN exp RPAREN .)
    DIV             reduce using rule 45 (f -> LPAREN exp RPAREN .)
    PLUS            reduce using rule 45 (f -> LPAREN exp RPAREN .)
    MINUS           reduce using rule 45 (f -> LPAREN exp RPAREN .)
    LT              reduce using rule 45 (f -> LPAREN exp RPAREN .)
    GT              reduce using rule 45 (f -> LPAREN exp RPAREN .)
    IFEQUAL         reduce using rule 45 (f -> LPAREN exp RPAREN .)
    DIFF            reduce using rule 45 (f -> LPAREN exp RPAREN .)
    AND             reduce using rule 45 (f -> LPAREN exp RPAREN .)
    OR              reduce using rule 45 (f -> LPAREN exp RPAREN .)
    SEMICOLON       reduce using rule 45 (f -> LPAREN exp RPAREN .)
    COMMA           reduce using rule 45 (f -> LPAREN exp RPAREN .)
    RPAREN          reduce using rule 45 (f -> LPAREN exp RPAREN .)
    RBRACKET        reduce using rule 45 (f -> LPAREN exp RPAREN .)


state 191

    (77) callp -> exp COMMA callp .

    RPAREN          reduce using rule 77 (callp -> exp COMMA callp .)


state 192

    (71) read -> READ LPAREN var RPAREN SEMICOLON .

    VAR             reduce using rule 71 (read -> READ LPAREN var RPAREN SEMICOLON .)
    FUNCTION        reduce using rule 71 (read -> READ LPAREN var RPAREN SEMICOLON .)
    ID              reduce using rule 71 (read -> READ LPAREN var RPAREN SEMICOLON .)
    READ            reduce using rule 71 (read -> READ LPAREN var RPAREN SEMICOLON .)
    PRINT           reduce using rule 71 (read -> READ LPAREN var RPAREN SEMICOLON .)
    IF              reduce using rule 71 (read -> READ LPAREN var RPAREN SEMICOLON .)
    WHILE           reduce using rule 71 (read -> READ LPAREN var RPAREN SEMICOLON .)
    ARRAY           reduce using rule 71 (read -> READ LPAREN var RPAREN SEMICOLON .)
    MATRIX          reduce using rule 71 (read -> READ LPAREN var RPAREN SEMICOLON .)
    MEAN            reduce using rule 71 (read -> READ LPAREN var RPAREN SEMICOLON .)
    LAYERS          reduce using rule 71 (read -> READ LPAREN var RPAREN SEMICOLON .)
    SEQUENTIAL      reduce using rule 71 (read -> READ LPAREN var RPAREN SEMICOLON .)
    COMPILE         reduce using rule 71 (read -> READ LPAREN var RPAREN SEMICOLON .)
    FIT             reduce using rule 71 (read -> READ LPAREN var RPAREN SEMICOLON .)
    PREDICT         reduce using rule 71 (read -> READ LPAREN var RPAREN SEMICOLON .)
    GETWEIGHTS      reduce using rule 71 (read -> READ LPAREN var RPAREN SEMICOLON .)
    FIBONACCI       reduce using rule 71 (read -> READ LPAREN var RPAREN SEMICOLON .)
    FACTORIAL       reduce using rule 71 (read -> READ LPAREN var RPAREN SEMICOLON .)
    MMULT           reduce using rule 71 (read -> READ LPAREN var RPAREN SEMICOLON .)
    RBRACE          reduce using rule 71 (read -> READ LPAREN var RPAREN SEMICOLON .)
    RETURN          reduce using rule 71 (read -> READ LPAREN var RPAREN SEMICOLON .)


state 193

    (74) printp -> exp COMMA printp .

    SEMICOLON       reduce using rule 74 (printp -> exp COMMA printp .)


state 194

    (80) if -> IF LPAREN ifexp RPAREN quadsIf . LBRACE body RBRACE ifelse jumpsIf SEMICOLON

    LBRACE          shift and go to state 207


state 195

    (87) while -> WHILE saveJumps LPAREN whilexp RPAREN . quadsWhile LBRACE body RBRACE jumpsWhile SEMICOLON
    (90) quadsWhile -> .

    LBRACE          reduce using rule 90 (quadsWhile -> .)

    quadsWhile                     shift and go to state 208

state 196

    (100) array -> ARRAY ID LBRACKET exp RBRACKET . EQUAL LBRACKET arrvalues RBRACKET SEMICOLON

    EQUAL           shift and go to state 209


state 197

    (103) matrix -> MATRIX ID LBRACKET exp RBRACKET . LBRACKET exp RBRACKET EQUAL LBRACKET matvalues RBRACKET SEMICOLON

    LBRACKET        shift and go to state 210


state 198

    (106) mean -> MEAN LPAREN ID RPAREN SEMICOLON .

    VAR             reduce using rule 106 (mean -> MEAN LPAREN ID RPAREN SEMICOLON .)
    FUNCTION        reduce using rule 106 (mean -> MEAN LPAREN ID RPAREN SEMICOLON .)
    ID              reduce using rule 106 (mean -> MEAN LPAREN ID RPAREN SEMICOLON .)
    READ            reduce using rule 106 (mean -> MEAN LPAREN ID RPAREN SEMICOLON .)
    PRINT           reduce using rule 106 (mean -> MEAN LPAREN ID RPAREN SEMICOLON .)
    IF              reduce using rule 106 (mean -> MEAN LPAREN ID RPAREN SEMICOLON .)
    WHILE           reduce using rule 106 (mean -> MEAN LPAREN ID RPAREN SEMICOLON .)
    ARRAY           reduce using rule 106 (mean -> MEAN LPAREN ID RPAREN SEMICOLON .)
    MATRIX          reduce using rule 106 (mean -> MEAN LPAREN ID RPAREN SEMICOLON .)
    MEAN            reduce using rule 106 (mean -> MEAN LPAREN ID RPAREN SEMICOLON .)
    LAYERS          reduce using rule 106 (mean -> MEAN LPAREN ID RPAREN SEMICOLON .)
    SEQUENTIAL      reduce using rule 106 (mean -> MEAN LPAREN ID RPAREN SEMICOLON .)
    COMPILE         reduce using rule 106 (mean -> MEAN LPAREN ID RPAREN SEMICOLON .)
    FIT             reduce using rule 106 (mean -> MEAN LPAREN ID RPAREN SEMICOLON .)
    PREDICT         reduce using rule 106 (mean -> MEAN LPAREN ID RPAREN SEMICOLON .)
    GETWEIGHTS      reduce using rule 106 (mean -> MEAN LPAREN ID RPAREN SEMICOLON .)
    FIBONACCI       reduce using rule 106 (mean -> MEAN LPAREN ID RPAREN SEMICOLON .)
    FACTORIAL       reduce using rule 106 (mean -> MEAN LPAREN ID RPAREN SEMICOLON .)
    MMULT           reduce using rule 106 (mean -> MEAN LPAREN ID RPAREN SEMICOLON .)
    RBRACE          reduce using rule 106 (mean -> MEAN LPAREN ID RPAREN SEMICOLON .)
    RETURN          reduce using rule 106 (mean -> MEAN LPAREN ID RPAREN SEMICOLON .)


state 199

    (107) layers -> LAYERS LPAREN UNITS EQUAL CTI . RPAREN SEMICOLON

    RPAREN          shift and go to state 211


state 200

    (109) compile -> COMPILE LPAREN CTF RPAREN SEMICOLON .

    VAR             reduce using rule 109 (compile -> COMPILE LPAREN CTF RPAREN SEMICOLON .)
    FUNCTION        reduce using rule 109 (compile -> COMPILE LPAREN CTF RPAREN SEMICOLON .)
    ID              reduce using rule 109 (compile -> COMPILE LPAREN CTF RPAREN SEMICOLON .)
    READ            reduce using rule 109 (compile -> COMPILE LPAREN CTF RPAREN SEMICOLON .)
    PRINT           reduce using rule 109 (compile -> COMPILE LPAREN CTF RPAREN SEMICOLON .)
    IF              reduce using rule 109 (compile -> COMPILE LPAREN CTF RPAREN SEMICOLON .)
    WHILE           reduce using rule 109 (compile -> COMPILE LPAREN CTF RPAREN SEMICOLON .)
    ARRAY           reduce using rule 109 (compile -> COMPILE LPAREN CTF RPAREN SEMICOLON .)
    MATRIX          reduce using rule 109 (compile -> COMPILE LPAREN CTF RPAREN SEMICOLON .)
    MEAN            reduce using rule 109 (compile -> COMPILE LPAREN CTF RPAREN SEMICOLON .)
    LAYERS          reduce using rule 109 (compile -> COMPILE LPAREN CTF RPAREN SEMICOLON .)
    SEQUENTIAL      reduce using rule 109 (compile -> COMPILE LPAREN CTF RPAREN SEMICOLON .)
    COMPILE         reduce using rule 109 (compile -> COMPILE LPAREN CTF RPAREN SEMICOLON .)
    FIT             reduce using rule 109 (compile -> COMPILE LPAREN CTF RPAREN SEMICOLON .)
    PREDICT         reduce using rule 109 (compile -> COMPILE LPAREN CTF RPAREN SEMICOLON .)
    GETWEIGHTS      reduce using rule 109 (compile -> COMPILE LPAREN CTF RPAREN SEMICOLON .)
    FIBONACCI       reduce using rule 109 (compile -> COMPILE LPAREN CTF RPAREN SEMICOLON .)
    FACTORIAL       reduce using rule 109 (compile -> COMPILE LPAREN CTF RPAREN SEMICOLON .)
    MMULT           reduce using rule 109 (compile -> COMPILE LPAREN CTF RPAREN SEMICOLON .)
    RBRACE          reduce using rule 109 (compile -> COMPILE LPAREN CTF RPAREN SEMICOLON .)
    RETURN          reduce using rule 109 (compile -> COMPILE LPAREN CTF RPAREN SEMICOLON .)


state 201

    (110) fit -> FIT LPAREN ID COMMA ID . COMMA EPOCHS EQUAL CTI RPAREN SEMICOLON

    COMMA           shift and go to state 212


state 202

    (111) predict -> PREDICT LPAREN CTF RPAREN SEMICOLON .

    VAR             reduce using rule 111 (predict -> PREDICT LPAREN CTF RPAREN SEMICOLON .)
    FUNCTION        reduce using rule 111 (predict -> PREDICT LPAREN CTF RPAREN SEMICOLON .)
    ID              reduce using rule 111 (predict -> PREDICT LPAREN CTF RPAREN SEMICOLON .)
    READ            reduce using rule 111 (predict -> PREDICT LPAREN CTF RPAREN SEMICOLON .)
    PRINT           reduce using rule 111 (predict -> PREDICT LPAREN CTF RPAREN SEMICOLON .)
    IF              reduce using rule 111 (predict -> PREDICT LPAREN CTF RPAREN SEMICOLON .)
    WHILE           reduce using rule 111 (predict -> PREDICT LPAREN CTF RPAREN SEMICOLON .)
    ARRAY           reduce using rule 111 (predict -> PREDICT LPAREN CTF RPAREN SEMICOLON .)
    MATRIX          reduce using rule 111 (predict -> PREDICT LPAREN CTF RPAREN SEMICOLON .)
    MEAN            reduce using rule 111 (predict -> PREDICT LPAREN CTF RPAREN SEMICOLON .)
    LAYERS          reduce using rule 111 (predict -> PREDICT LPAREN CTF RPAREN SEMICOLON .)
    SEQUENTIAL      reduce using rule 111 (predict -> PREDICT LPAREN CTF RPAREN SEMICOLON .)
    COMPILE         reduce using rule 111 (predict -> PREDICT LPAREN CTF RPAREN SEMICOLON .)
    FIT             reduce using rule 111 (predict -> PREDICT LPAREN CTF RPAREN SEMICOLON .)
    PREDICT         reduce using rule 111 (predict -> PREDICT LPAREN CTF RPAREN SEMICOLON .)
    GETWEIGHTS      reduce using rule 111 (predict -> PREDICT LPAREN CTF RPAREN SEMICOLON .)
    FIBONACCI       reduce using rule 111 (predict -> PREDICT LPAREN CTF RPAREN SEMICOLON .)
    FACTORIAL       reduce using rule 111 (predict -> PREDICT LPAREN CTF RPAREN SEMICOLON .)
    MMULT           reduce using rule 111 (predict -> PREDICT LPAREN CTF RPAREN SEMICOLON .)
    RBRACE          reduce using rule 111 (predict -> PREDICT LPAREN CTF RPAREN SEMICOLON .)
    RETURN          reduce using rule 111 (predict -> PREDICT LPAREN CTF RPAREN SEMICOLON .)


state 203

    (113) fibonacci -> FIBONACCI LPAREN exp RPAREN SEMICOLON .

    VAR             reduce using rule 113 (fibonacci -> FIBONACCI LPAREN exp RPAREN SEMICOLON .)
    FUNCTION        reduce using rule 113 (fibonacci -> FIBONACCI LPAREN exp RPAREN SEMICOLON .)
    ID              reduce using rule 113 (fibonacci -> FIBONACCI LPAREN exp RPAREN SEMICOLON .)
    READ            reduce using rule 113 (fibonacci -> FIBONACCI LPAREN exp RPAREN SEMICOLON .)
    PRINT           reduce using rule 113 (fibonacci -> FIBONACCI LPAREN exp RPAREN SEMICOLON .)
    IF              reduce using rule 113 (fibonacci -> FIBONACCI LPAREN exp RPAREN SEMICOLON .)
    WHILE           reduce using rule 113 (fibonacci -> FIBONACCI LPAREN exp RPAREN SEMICOLON .)
    ARRAY           reduce using rule 113 (fibonacci -> FIBONACCI LPAREN exp RPAREN SEMICOLON .)
    MATRIX          reduce using rule 113 (fibonacci -> FIBONACCI LPAREN exp RPAREN SEMICOLON .)
    MEAN            reduce using rule 113 (fibonacci -> FIBONACCI LPAREN exp RPAREN SEMICOLON .)
    LAYERS          reduce using rule 113 (fibonacci -> FIBONACCI LPAREN exp RPAREN SEMICOLON .)
    SEQUENTIAL      reduce using rule 113 (fibonacci -> FIBONACCI LPAREN exp RPAREN SEMICOLON .)
    COMPILE         reduce using rule 113 (fibonacci -> FIBONACCI LPAREN exp RPAREN SEMICOLON .)
    FIT             reduce using rule 113 (fibonacci -> FIBONACCI LPAREN exp RPAREN SEMICOLON .)
    PREDICT         reduce using rule 113 (fibonacci -> FIBONACCI LPAREN exp RPAREN SEMICOLON .)
    GETWEIGHTS      reduce using rule 113 (fibonacci -> FIBONACCI LPAREN exp RPAREN SEMICOLON .)
    FIBONACCI       reduce using rule 113 (fibonacci -> FIBONACCI LPAREN exp RPAREN SEMICOLON .)
    FACTORIAL       reduce using rule 113 (fibonacci -> FIBONACCI LPAREN exp RPAREN SEMICOLON .)
    MMULT           reduce using rule 113 (fibonacci -> FIBONACCI LPAREN exp RPAREN SEMICOLON .)
    RBRACE          reduce using rule 113 (fibonacci -> FIBONACCI LPAREN exp RPAREN SEMICOLON .)
    RETURN          reduce using rule 113 (fibonacci -> FIBONACCI LPAREN exp RPAREN SEMICOLON .)


state 204

    (114) factorial -> FACTORIAL LPAREN exp RPAREN SEMICOLON .

    VAR             reduce using rule 114 (factorial -> FACTORIAL LPAREN exp RPAREN SEMICOLON .)
    FUNCTION        reduce using rule 114 (factorial -> FACTORIAL LPAREN exp RPAREN SEMICOLON .)
    ID              reduce using rule 114 (factorial -> FACTORIAL LPAREN exp RPAREN SEMICOLON .)
    READ            reduce using rule 114 (factorial -> FACTORIAL LPAREN exp RPAREN SEMICOLON .)
    PRINT           reduce using rule 114 (factorial -> FACTORIAL LPAREN exp RPAREN SEMICOLON .)
    IF              reduce using rule 114 (factorial -> FACTORIAL LPAREN exp RPAREN SEMICOLON .)
    WHILE           reduce using rule 114 (factorial -> FACTORIAL LPAREN exp RPAREN SEMICOLON .)
    ARRAY           reduce using rule 114 (factorial -> FACTORIAL LPAREN exp RPAREN SEMICOLON .)
    MATRIX          reduce using rule 114 (factorial -> FACTORIAL LPAREN exp RPAREN SEMICOLON .)
    MEAN            reduce using rule 114 (factorial -> FACTORIAL LPAREN exp RPAREN SEMICOLON .)
    LAYERS          reduce using rule 114 (factorial -> FACTORIAL LPAREN exp RPAREN SEMICOLON .)
    SEQUENTIAL      reduce using rule 114 (factorial -> FACTORIAL LPAREN exp RPAREN SEMICOLON .)
    COMPILE         reduce using rule 114 (factorial -> FACTORIAL LPAREN exp RPAREN SEMICOLON .)
    FIT             reduce using rule 114 (factorial -> FACTORIAL LPAREN exp RPAREN SEMICOLON .)
    PREDICT         reduce using rule 114 (factorial -> FACTORIAL LPAREN exp RPAREN SEMICOLON .)
    GETWEIGHTS      reduce using rule 114 (factorial -> FACTORIAL LPAREN exp RPAREN SEMICOLON .)
    FIBONACCI       reduce using rule 114 (factorial -> FACTORIAL LPAREN exp RPAREN SEMICOLON .)
    FACTORIAL       reduce using rule 114 (factorial -> FACTORIAL LPAREN exp RPAREN SEMICOLON .)
    MMULT           reduce using rule 114 (factorial -> FACTORIAL LPAREN exp RPAREN SEMICOLON .)
    RBRACE          reduce using rule 114 (factorial -> FACTORIAL LPAREN exp RPAREN SEMICOLON .)
    RETURN          reduce using rule 114 (factorial -> FACTORIAL LPAREN exp RPAREN SEMICOLON .)


state 205

    (115) mmult -> MMULT LPAREN ID COMMA ID . RPAREN SEMICOLON

    RPAREN          shift and go to state 213


state 206

    (11) function -> FUNCTION decfunctype decfunc LPAREN param RPAREN LBRACE body RETURN exp SEMICOLON . RBRACE

    RBRACE          shift and go to state 214


state 207

    (80) if -> IF LPAREN ifexp RPAREN quadsIf LBRACE . body RBRACE ifelse jumpsIf SEMICOLON
    (22) body -> . decvar statements body
    (23) body -> . statements body
    (24) body -> . decvar
    (25) body -> .
    (3) decvar -> . VAR decvarp
    (4) decvar -> . VAR decvarp decvar
    (5) decvar -> .
    (50) statements -> . assign
    (51) statements -> . function
    (52) statements -> . voidfunction
    (53) statements -> . call
    (54) statements -> . read
    (55) statements -> . print
    (56) statements -> . if
    (57) statements -> . while
    (58) statements -> . array
    (59) statements -> . matrix
    (60) statements -> . mean
    (61) statements -> . layers
    (62) statements -> . sequential
    (63) statements -> . compile
    (64) statements -> . fit
    (65) statements -> . predict
    (66) statements -> . getweights
    (67) statements -> . fibonacci
    (68) statements -> . factorial
    (69) statements -> . mmult
    (70) assign -> . var EQUAL exp SEMICOLON
    (11) function -> . FUNCTION decfunctype decfunc LPAREN param RPAREN LBRACE body RETURN exp SEMICOLON RBRACE
    (14) voidfunction -> . FUNCTION VOID decfunc LPAREN param RPAREN LBRACE body RBRACE
    (76) call -> . ID LPAREN callp RPAREN
    (71) read -> . READ LPAREN var RPAREN SEMICOLON
    (72) print -> . PRINT LPAREN printp SEMICOLON
    (80) if -> . IF LPAREN ifexp RPAREN quadsIf LBRACE body RBRACE ifelse jumpsIf SEMICOLON
    (87) while -> . WHILE saveJumps LPAREN whilexp RPAREN quadsWhile LBRACE body RBRACE jumpsWhile SEMICOLON
    (100) array -> . ARRAY ID LBRACKET exp RBRACKET EQUAL LBRACKET arrvalues RBRACKET SEMICOLON
    (103) matrix -> . MATRIX ID LBRACKET exp RBRACKET LBRACKET exp RBRACKET EQUAL LBRACKET matvalues RBRACKET SEMICOLON
    (106) mean -> . MEAN LPAREN ID RPAREN SEMICOLON
    (107) layers -> . LAYERS LPAREN UNITS EQUAL CTI RPAREN SEMICOLON
    (108) sequential -> . SEQUENTIAL LPAREN RPAREN SEMICOLON
    (109) compile -> . COMPILE LPAREN CTF RPAREN SEMICOLON
    (110) fit -> . FIT LPAREN ID COMMA ID COMMA EPOCHS EQUAL CTI RPAREN SEMICOLON
    (111) predict -> . PREDICT LPAREN CTF RPAREN SEMICOLON
    (112) getweights -> . GETWEIGHTS LPAREN RPAREN SEMICOLON
    (113) fibonacci -> . FIBONACCI LPAREN exp RPAREN SEMICOLON
    (114) factorial -> . FACTORIAL LPAREN exp RPAREN SEMICOLON
    (115) mmult -> . MMULT LPAREN ID COMMA ID RPAREN SEMICOLON
    (75) var -> . ID

  ! reduce/reduce conflict for RBRACE resolved using rule 5 (decvar -> .)
  ! shift/reduce conflict for FUNCTION resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for READ resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for ARRAY resolved as shift
  ! shift/reduce conflict for MATRIX resolved as shift
  ! shift/reduce conflict for MEAN resolved as shift
  ! shift/reduce conflict for LAYERS resolved as shift
  ! shift/reduce conflict for SEQUENTIAL resolved as shift
  ! shift/reduce conflict for COMPILE resolved as shift
  ! shift/reduce conflict for FIT resolved as shift
  ! shift/reduce conflict for PREDICT resolved as shift
  ! shift/reduce conflict for GETWEIGHTS resolved as shift
  ! shift/reduce conflict for FIBONACCI resolved as shift
  ! shift/reduce conflict for FACTORIAL resolved as shift
  ! shift/reduce conflict for MMULT resolved as shift
    VAR             shift and go to state 7
    RBRACE          reduce using rule 5 (decvar -> .)
    FUNCTION        shift and go to state 11
    ID              shift and go to state 68
    READ            shift and go to state 69
    PRINT           shift and go to state 70
    IF              shift and go to state 71
    WHILE           shift and go to state 72
    ARRAY           shift and go to state 73
    MATRIX          shift and go to state 74
    MEAN            shift and go to state 75
    LAYERS          shift and go to state 76
    SEQUENTIAL      shift and go to state 77
    COMPILE         shift and go to state 78
    FIT             shift and go to state 79
    PREDICT         shift and go to state 80
    GETWEIGHTS      shift and go to state 81
    FIBONACCI       shift and go to state 82
    FACTORIAL       shift and go to state 83
    MMULT           shift and go to state 84

  ! RBRACE          [ reduce using rule 25 (body -> .) ]
  ! FUNCTION        [ reduce using rule 5 (decvar -> .) ]
  ! ID              [ reduce using rule 5 (decvar -> .) ]
  ! READ            [ reduce using rule 5 (decvar -> .) ]
  ! PRINT           [ reduce using rule 5 (decvar -> .) ]
  ! IF              [ reduce using rule 5 (decvar -> .) ]
  ! WHILE           [ reduce using rule 5 (decvar -> .) ]
  ! ARRAY           [ reduce using rule 5 (decvar -> .) ]
  ! MATRIX          [ reduce using rule 5 (decvar -> .) ]
  ! MEAN            [ reduce using rule 5 (decvar -> .) ]
  ! LAYERS          [ reduce using rule 5 (decvar -> .) ]
  ! SEQUENTIAL      [ reduce using rule 5 (decvar -> .) ]
  ! COMPILE         [ reduce using rule 5 (decvar -> .) ]
  ! FIT             [ reduce using rule 5 (decvar -> .) ]
  ! PREDICT         [ reduce using rule 5 (decvar -> .) ]
  ! GETWEIGHTS      [ reduce using rule 5 (decvar -> .) ]
  ! FIBONACCI       [ reduce using rule 5 (decvar -> .) ]
  ! FACTORIAL       [ reduce using rule 5 (decvar -> .) ]
  ! MMULT           [ reduce using rule 5 (decvar -> .) ]

    body                           shift and go to state 215
    decvar                         shift and go to state 45
    statements                     shift and go to state 46
    assign                         shift and go to state 47
    function                       shift and go to state 48
    voidfunction                   shift and go to state 49
    call                           shift and go to state 50
    read                           shift and go to state 51
    print                          shift and go to state 52
    if                             shift and go to state 53
    while                          shift and go to state 54
    array                          shift and go to state 55
    matrix                         shift and go to state 56
    mean                           shift and go to state 57
    layers                         shift and go to state 58
    sequential                     shift and go to state 59
    compile                        shift and go to state 60
    fit                            shift and go to state 61
    predict                        shift and go to state 62
    getweights                     shift and go to state 63
    fibonacci                      shift and go to state 64
    factorial                      shift and go to state 65
    mmult                          shift and go to state 66
    var                            shift and go to state 67

state 208

    (87) while -> WHILE saveJumps LPAREN whilexp RPAREN quadsWhile . LBRACE body RBRACE jumpsWhile SEMICOLON

    LBRACE          shift and go to state 216


state 209

    (100) array -> ARRAY ID LBRACKET exp RBRACKET EQUAL . LBRACKET arrvalues RBRACKET SEMICOLON

    LBRACKET        shift and go to state 217


state 210

    (103) matrix -> MATRIX ID LBRACKET exp RBRACKET LBRACKET . exp RBRACKET EQUAL LBRACKET matvalues RBRACKET SEMICOLON
    (29) exp -> . texp
    (30) exp -> . texp OR exp
    (31) texp -> . gexp
    (32) texp -> . gexp AND texp
    (33) gexp -> . mexp
    (34) gexp -> . mexp gexpp mexp
    (39) mexp -> . t
    (40) mexp -> . mexp PLUS t
    (41) mexp -> . mexp MINUS t
    (42) t -> . f
    (43) t -> . t MULT f
    (44) t -> . t DIV f
    (45) f -> . LPAREN exp RPAREN
    (46) f -> . CTI
    (47) f -> . CTF
    (48) f -> . var
    (49) f -> . call
    (75) var -> . ID
    (76) call -> . ID LPAREN callp RPAREN

    LPAREN          shift and go to state 120
    CTI             shift and go to state 121
    CTF             shift and go to state 122
    ID              shift and go to state 124

    exp                            shift and go to state 218
    texp                           shift and go to state 115
    gexp                           shift and go to state 116
    mexp                           shift and go to state 117
    t                              shift and go to state 118
    f                              shift and go to state 119
    var                            shift and go to state 113
    call                           shift and go to state 123

state 211

    (107) layers -> LAYERS LPAREN UNITS EQUAL CTI RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 219


state 212

    (110) fit -> FIT LPAREN ID COMMA ID COMMA . EPOCHS EQUAL CTI RPAREN SEMICOLON

    EPOCHS          shift and go to state 220


state 213

    (115) mmult -> MMULT LPAREN ID COMMA ID RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 221


state 214

    (11) function -> FUNCTION decfunctype decfunc LPAREN param RPAREN LBRACE body RETURN exp SEMICOLON RBRACE .

    FUNCTION        reduce using rule 11 (function -> FUNCTION decfunctype decfunc LPAREN param RPAREN LBRACE body RETURN exp SEMICOLON RBRACE .)
    MAIN            reduce using rule 11 (function -> FUNCTION decfunctype decfunc LPAREN param RPAREN LBRACE body RETURN exp SEMICOLON RBRACE .)
    VAR             reduce using rule 11 (function -> FUNCTION decfunctype decfunc LPAREN param RPAREN LBRACE body RETURN exp SEMICOLON RBRACE .)
    ID              reduce using rule 11 (function -> FUNCTION decfunctype decfunc LPAREN param RPAREN LBRACE body RETURN exp SEMICOLON RBRACE .)
    READ            reduce using rule 11 (function -> FUNCTION decfunctype decfunc LPAREN param RPAREN LBRACE body RETURN exp SEMICOLON RBRACE .)
    PRINT           reduce using rule 11 (function -> FUNCTION decfunctype decfunc LPAREN param RPAREN LBRACE body RETURN exp SEMICOLON RBRACE .)
    IF              reduce using rule 11 (function -> FUNCTION decfunctype decfunc LPAREN param RPAREN LBRACE body RETURN exp SEMICOLON RBRACE .)
    WHILE           reduce using rule 11 (function -> FUNCTION decfunctype decfunc LPAREN param RPAREN LBRACE body RETURN exp SEMICOLON RBRACE .)
    ARRAY           reduce using rule 11 (function -> FUNCTION decfunctype decfunc LPAREN param RPAREN LBRACE body RETURN exp SEMICOLON RBRACE .)
    MATRIX          reduce using rule 11 (function -> FUNCTION decfunctype decfunc LPAREN param RPAREN LBRACE body RETURN exp SEMICOLON RBRACE .)
    MEAN            reduce using rule 11 (function -> FUNCTION decfunctype decfunc LPAREN param RPAREN LBRACE body RETURN exp SEMICOLON RBRACE .)
    LAYERS          reduce using rule 11 (function -> FUNCTION decfunctype decfunc LPAREN param RPAREN LBRACE body RETURN exp SEMICOLON RBRACE .)
    SEQUENTIAL      reduce using rule 11 (function -> FUNCTION decfunctype decfunc LPAREN param RPAREN LBRACE body RETURN exp SEMICOLON RBRACE .)
    COMPILE         reduce using rule 11 (function -> FUNCTION decfunctype decfunc LPAREN param RPAREN LBRACE body RETURN exp SEMICOLON RBRACE .)
    FIT             reduce using rule 11 (function -> FUNCTION decfunctype decfunc LPAREN param RPAREN LBRACE body RETURN exp SEMICOLON RBRACE .)
    PREDICT         reduce using rule 11 (function -> FUNCTION decfunctype decfunc LPAREN param RPAREN LBRACE body RETURN exp SEMICOLON RBRACE .)
    GETWEIGHTS      reduce using rule 11 (function -> FUNCTION decfunctype decfunc LPAREN param RPAREN LBRACE body RETURN exp SEMICOLON RBRACE .)
    FIBONACCI       reduce using rule 11 (function -> FUNCTION decfunctype decfunc LPAREN param RPAREN LBRACE body RETURN exp SEMICOLON RBRACE .)
    FACTORIAL       reduce using rule 11 (function -> FUNCTION decfunctype decfunc LPAREN param RPAREN LBRACE body RETURN exp SEMICOLON RBRACE .)
    MMULT           reduce using rule 11 (function -> FUNCTION decfunctype decfunc LPAREN param RPAREN LBRACE body RETURN exp SEMICOLON RBRACE .)
    RBRACE          reduce using rule 11 (function -> FUNCTION decfunctype decfunc LPAREN param RPAREN LBRACE body RETURN exp SEMICOLON RBRACE .)
    RETURN          reduce using rule 11 (function -> FUNCTION decfunctype decfunc LPAREN param RPAREN LBRACE body RETURN exp SEMICOLON RBRACE .)


state 215

    (80) if -> IF LPAREN ifexp RPAREN quadsIf LBRACE body . RBRACE ifelse jumpsIf SEMICOLON

    RBRACE          shift and go to state 222


state 216

    (87) while -> WHILE saveJumps LPAREN whilexp RPAREN quadsWhile LBRACE . body RBRACE jumpsWhile SEMICOLON
    (22) body -> . decvar statements body
    (23) body -> . statements body
    (24) body -> . decvar
    (25) body -> .
    (3) decvar -> . VAR decvarp
    (4) decvar -> . VAR decvarp decvar
    (5) decvar -> .
    (50) statements -> . assign
    (51) statements -> . function
    (52) statements -> . voidfunction
    (53) statements -> . call
    (54) statements -> . read
    (55) statements -> . print
    (56) statements -> . if
    (57) statements -> . while
    (58) statements -> . array
    (59) statements -> . matrix
    (60) statements -> . mean
    (61) statements -> . layers
    (62) statements -> . sequential
    (63) statements -> . compile
    (64) statements -> . fit
    (65) statements -> . predict
    (66) statements -> . getweights
    (67) statements -> . fibonacci
    (68) statements -> . factorial
    (69) statements -> . mmult
    (70) assign -> . var EQUAL exp SEMICOLON
    (11) function -> . FUNCTION decfunctype decfunc LPAREN param RPAREN LBRACE body RETURN exp SEMICOLON RBRACE
    (14) voidfunction -> . FUNCTION VOID decfunc LPAREN param RPAREN LBRACE body RBRACE
    (76) call -> . ID LPAREN callp RPAREN
    (71) read -> . READ LPAREN var RPAREN SEMICOLON
    (72) print -> . PRINT LPAREN printp SEMICOLON
    (80) if -> . IF LPAREN ifexp RPAREN quadsIf LBRACE body RBRACE ifelse jumpsIf SEMICOLON
    (87) while -> . WHILE saveJumps LPAREN whilexp RPAREN quadsWhile LBRACE body RBRACE jumpsWhile SEMICOLON
    (100) array -> . ARRAY ID LBRACKET exp RBRACKET EQUAL LBRACKET arrvalues RBRACKET SEMICOLON
    (103) matrix -> . MATRIX ID LBRACKET exp RBRACKET LBRACKET exp RBRACKET EQUAL LBRACKET matvalues RBRACKET SEMICOLON
    (106) mean -> . MEAN LPAREN ID RPAREN SEMICOLON
    (107) layers -> . LAYERS LPAREN UNITS EQUAL CTI RPAREN SEMICOLON
    (108) sequential -> . SEQUENTIAL LPAREN RPAREN SEMICOLON
    (109) compile -> . COMPILE LPAREN CTF RPAREN SEMICOLON
    (110) fit -> . FIT LPAREN ID COMMA ID COMMA EPOCHS EQUAL CTI RPAREN SEMICOLON
    (111) predict -> . PREDICT LPAREN CTF RPAREN SEMICOLON
    (112) getweights -> . GETWEIGHTS LPAREN RPAREN SEMICOLON
    (113) fibonacci -> . FIBONACCI LPAREN exp RPAREN SEMICOLON
    (114) factorial -> . FACTORIAL LPAREN exp RPAREN SEMICOLON
    (115) mmult -> . MMULT LPAREN ID COMMA ID RPAREN SEMICOLON
    (75) var -> . ID

  ! reduce/reduce conflict for RBRACE resolved using rule 5 (decvar -> .)
  ! shift/reduce conflict for FUNCTION resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for READ resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for ARRAY resolved as shift
  ! shift/reduce conflict for MATRIX resolved as shift
  ! shift/reduce conflict for MEAN resolved as shift
  ! shift/reduce conflict for LAYERS resolved as shift
  ! shift/reduce conflict for SEQUENTIAL resolved as shift
  ! shift/reduce conflict for COMPILE resolved as shift
  ! shift/reduce conflict for FIT resolved as shift
  ! shift/reduce conflict for PREDICT resolved as shift
  ! shift/reduce conflict for GETWEIGHTS resolved as shift
  ! shift/reduce conflict for FIBONACCI resolved as shift
  ! shift/reduce conflict for FACTORIAL resolved as shift
  ! shift/reduce conflict for MMULT resolved as shift
    VAR             shift and go to state 7
    RBRACE          reduce using rule 5 (decvar -> .)
    FUNCTION        shift and go to state 11
    ID              shift and go to state 68
    READ            shift and go to state 69
    PRINT           shift and go to state 70
    IF              shift and go to state 71
    WHILE           shift and go to state 72
    ARRAY           shift and go to state 73
    MATRIX          shift and go to state 74
    MEAN            shift and go to state 75
    LAYERS          shift and go to state 76
    SEQUENTIAL      shift and go to state 77
    COMPILE         shift and go to state 78
    FIT             shift and go to state 79
    PREDICT         shift and go to state 80
    GETWEIGHTS      shift and go to state 81
    FIBONACCI       shift and go to state 82
    FACTORIAL       shift and go to state 83
    MMULT           shift and go to state 84

  ! RBRACE          [ reduce using rule 25 (body -> .) ]
  ! FUNCTION        [ reduce using rule 5 (decvar -> .) ]
  ! ID              [ reduce using rule 5 (decvar -> .) ]
  ! READ            [ reduce using rule 5 (decvar -> .) ]
  ! PRINT           [ reduce using rule 5 (decvar -> .) ]
  ! IF              [ reduce using rule 5 (decvar -> .) ]
  ! WHILE           [ reduce using rule 5 (decvar -> .) ]
  ! ARRAY           [ reduce using rule 5 (decvar -> .) ]
  ! MATRIX          [ reduce using rule 5 (decvar -> .) ]
  ! MEAN            [ reduce using rule 5 (decvar -> .) ]
  ! LAYERS          [ reduce using rule 5 (decvar -> .) ]
  ! SEQUENTIAL      [ reduce using rule 5 (decvar -> .) ]
  ! COMPILE         [ reduce using rule 5 (decvar -> .) ]
  ! FIT             [ reduce using rule 5 (decvar -> .) ]
  ! PREDICT         [ reduce using rule 5 (decvar -> .) ]
  ! GETWEIGHTS      [ reduce using rule 5 (decvar -> .) ]
  ! FIBONACCI       [ reduce using rule 5 (decvar -> .) ]
  ! FACTORIAL       [ reduce using rule 5 (decvar -> .) ]
  ! MMULT           [ reduce using rule 5 (decvar -> .) ]

    body                           shift and go to state 223
    decvar                         shift and go to state 45
    statements                     shift and go to state 46
    assign                         shift and go to state 47
    function                       shift and go to state 48
    voidfunction                   shift and go to state 49
    call                           shift and go to state 50
    read                           shift and go to state 51
    print                          shift and go to state 52
    if                             shift and go to state 53
    while                          shift and go to state 54
    array                          shift and go to state 55
    matrix                         shift and go to state 56
    mean                           shift and go to state 57
    layers                         shift and go to state 58
    sequential                     shift and go to state 59
    compile                        shift and go to state 60
    fit                            shift and go to state 61
    predict                        shift and go to state 62
    getweights                     shift and go to state 63
    fibonacci                      shift and go to state 64
    factorial                      shift and go to state 65
    mmult                          shift and go to state 66
    var                            shift and go to state 67

state 217

    (100) array -> ARRAY ID LBRACKET exp RBRACKET EQUAL LBRACKET . arrvalues RBRACKET SEMICOLON
    (101) arrvalues -> . exp
    (102) arrvalues -> . exp COMMA arrvalues
    (29) exp -> . texp
    (30) exp -> . texp OR exp
    (31) texp -> . gexp
    (32) texp -> . gexp AND texp
    (33) gexp -> . mexp
    (34) gexp -> . mexp gexpp mexp
    (39) mexp -> . t
    (40) mexp -> . mexp PLUS t
    (41) mexp -> . mexp MINUS t
    (42) t -> . f
    (43) t -> . t MULT f
    (44) t -> . t DIV f
    (45) f -> . LPAREN exp RPAREN
    (46) f -> . CTI
    (47) f -> . CTF
    (48) f -> . var
    (49) f -> . call
    (75) var -> . ID
    (76) call -> . ID LPAREN callp RPAREN

    LPAREN          shift and go to state 120
    CTI             shift and go to state 121
    CTF             shift and go to state 122
    ID              shift and go to state 124

    exp                            shift and go to state 224
    arrvalues                      shift and go to state 225
    texp                           shift and go to state 115
    gexp                           shift and go to state 116
    mexp                           shift and go to state 117
    t                              shift and go to state 118
    f                              shift and go to state 119
    var                            shift and go to state 113
    call                           shift and go to state 123

state 218

    (103) matrix -> MATRIX ID LBRACKET exp RBRACKET LBRACKET exp . RBRACKET EQUAL LBRACKET matvalues RBRACKET SEMICOLON

    RBRACKET        shift and go to state 226


state 219

    (107) layers -> LAYERS LPAREN UNITS EQUAL CTI RPAREN SEMICOLON .

    VAR             reduce using rule 107 (layers -> LAYERS LPAREN UNITS EQUAL CTI RPAREN SEMICOLON .)
    FUNCTION        reduce using rule 107 (layers -> LAYERS LPAREN UNITS EQUAL CTI RPAREN SEMICOLON .)
    ID              reduce using rule 107 (layers -> LAYERS LPAREN UNITS EQUAL CTI RPAREN SEMICOLON .)
    READ            reduce using rule 107 (layers -> LAYERS LPAREN UNITS EQUAL CTI RPAREN SEMICOLON .)
    PRINT           reduce using rule 107 (layers -> LAYERS LPAREN UNITS EQUAL CTI RPAREN SEMICOLON .)
    IF              reduce using rule 107 (layers -> LAYERS LPAREN UNITS EQUAL CTI RPAREN SEMICOLON .)
    WHILE           reduce using rule 107 (layers -> LAYERS LPAREN UNITS EQUAL CTI RPAREN SEMICOLON .)
    ARRAY           reduce using rule 107 (layers -> LAYERS LPAREN UNITS EQUAL CTI RPAREN SEMICOLON .)
    MATRIX          reduce using rule 107 (layers -> LAYERS LPAREN UNITS EQUAL CTI RPAREN SEMICOLON .)
    MEAN            reduce using rule 107 (layers -> LAYERS LPAREN UNITS EQUAL CTI RPAREN SEMICOLON .)
    LAYERS          reduce using rule 107 (layers -> LAYERS LPAREN UNITS EQUAL CTI RPAREN SEMICOLON .)
    SEQUENTIAL      reduce using rule 107 (layers -> LAYERS LPAREN UNITS EQUAL CTI RPAREN SEMICOLON .)
    COMPILE         reduce using rule 107 (layers -> LAYERS LPAREN UNITS EQUAL CTI RPAREN SEMICOLON .)
    FIT             reduce using rule 107 (layers -> LAYERS LPAREN UNITS EQUAL CTI RPAREN SEMICOLON .)
    PREDICT         reduce using rule 107 (layers -> LAYERS LPAREN UNITS EQUAL CTI RPAREN SEMICOLON .)
    GETWEIGHTS      reduce using rule 107 (layers -> LAYERS LPAREN UNITS EQUAL CTI RPAREN SEMICOLON .)
    FIBONACCI       reduce using rule 107 (layers -> LAYERS LPAREN UNITS EQUAL CTI RPAREN SEMICOLON .)
    FACTORIAL       reduce using rule 107 (layers -> LAYERS LPAREN UNITS EQUAL CTI RPAREN SEMICOLON .)
    MMULT           reduce using rule 107 (layers -> LAYERS LPAREN UNITS EQUAL CTI RPAREN SEMICOLON .)
    RBRACE          reduce using rule 107 (layers -> LAYERS LPAREN UNITS EQUAL CTI RPAREN SEMICOLON .)
    RETURN          reduce using rule 107 (layers -> LAYERS LPAREN UNITS EQUAL CTI RPAREN SEMICOLON .)


state 220

    (110) fit -> FIT LPAREN ID COMMA ID COMMA EPOCHS . EQUAL CTI RPAREN SEMICOLON

    EQUAL           shift and go to state 227


state 221

    (115) mmult -> MMULT LPAREN ID COMMA ID RPAREN SEMICOLON .

    VAR             reduce using rule 115 (mmult -> MMULT LPAREN ID COMMA ID RPAREN SEMICOLON .)
    FUNCTION        reduce using rule 115 (mmult -> MMULT LPAREN ID COMMA ID RPAREN SEMICOLON .)
    ID              reduce using rule 115 (mmult -> MMULT LPAREN ID COMMA ID RPAREN SEMICOLON .)
    READ            reduce using rule 115 (mmult -> MMULT LPAREN ID COMMA ID RPAREN SEMICOLON .)
    PRINT           reduce using rule 115 (mmult -> MMULT LPAREN ID COMMA ID RPAREN SEMICOLON .)
    IF              reduce using rule 115 (mmult -> MMULT LPAREN ID COMMA ID RPAREN SEMICOLON .)
    WHILE           reduce using rule 115 (mmult -> MMULT LPAREN ID COMMA ID RPAREN SEMICOLON .)
    ARRAY           reduce using rule 115 (mmult -> MMULT LPAREN ID COMMA ID RPAREN SEMICOLON .)
    MATRIX          reduce using rule 115 (mmult -> MMULT LPAREN ID COMMA ID RPAREN SEMICOLON .)
    MEAN            reduce using rule 115 (mmult -> MMULT LPAREN ID COMMA ID RPAREN SEMICOLON .)
    LAYERS          reduce using rule 115 (mmult -> MMULT LPAREN ID COMMA ID RPAREN SEMICOLON .)
    SEQUENTIAL      reduce using rule 115 (mmult -> MMULT LPAREN ID COMMA ID RPAREN SEMICOLON .)
    COMPILE         reduce using rule 115 (mmult -> MMULT LPAREN ID COMMA ID RPAREN SEMICOLON .)
    FIT             reduce using rule 115 (mmult -> MMULT LPAREN ID COMMA ID RPAREN SEMICOLON .)
    PREDICT         reduce using rule 115 (mmult -> MMULT LPAREN ID COMMA ID RPAREN SEMICOLON .)
    GETWEIGHTS      reduce using rule 115 (mmult -> MMULT LPAREN ID COMMA ID RPAREN SEMICOLON .)
    FIBONACCI       reduce using rule 115 (mmult -> MMULT LPAREN ID COMMA ID RPAREN SEMICOLON .)
    FACTORIAL       reduce using rule 115 (mmult -> MMULT LPAREN ID COMMA ID RPAREN SEMICOLON .)
    MMULT           reduce using rule 115 (mmult -> MMULT LPAREN ID COMMA ID RPAREN SEMICOLON .)
    RBRACE          reduce using rule 115 (mmult -> MMULT LPAREN ID COMMA ID RPAREN SEMICOLON .)
    RETURN          reduce using rule 115 (mmult -> MMULT LPAREN ID COMMA ID RPAREN SEMICOLON .)


state 222

    (80) if -> IF LPAREN ifexp RPAREN quadsIf LBRACE body RBRACE . ifelse jumpsIf SEMICOLON
    (82) ifelse -> .
    (83) ifelse -> . ELSE quadsElse LBRACE body RBRACE

    SEMICOLON       reduce using rule 82 (ifelse -> .)
    ELSE            shift and go to state 229

    ifelse                         shift and go to state 228

state 223

    (87) while -> WHILE saveJumps LPAREN whilexp RPAREN quadsWhile LBRACE body . RBRACE jumpsWhile SEMICOLON

    RBRACE          shift and go to state 230


state 224

    (101) arrvalues -> exp .
    (102) arrvalues -> exp . COMMA arrvalues

    RBRACKET        reduce using rule 101 (arrvalues -> exp .)
    COMMA           shift and go to state 231


state 225

    (100) array -> ARRAY ID LBRACKET exp RBRACKET EQUAL LBRACKET arrvalues . RBRACKET SEMICOLON

    RBRACKET        shift and go to state 232


state 226

    (103) matrix -> MATRIX ID LBRACKET exp RBRACKET LBRACKET exp RBRACKET . EQUAL LBRACKET matvalues RBRACKET SEMICOLON

    EQUAL           shift and go to state 233


state 227

    (110) fit -> FIT LPAREN ID COMMA ID COMMA EPOCHS EQUAL . CTI RPAREN SEMICOLON

    CTI             shift and go to state 234


state 228

    (80) if -> IF LPAREN ifexp RPAREN quadsIf LBRACE body RBRACE ifelse . jumpsIf SEMICOLON
    (85) jumpsIf -> .

    SEMICOLON       reduce using rule 85 (jumpsIf -> .)

    jumpsIf                        shift and go to state 235

state 229

    (83) ifelse -> ELSE . quadsElse LBRACE body RBRACE
    (86) quadsElse -> .

    LBRACE          reduce using rule 86 (quadsElse -> .)

    quadsElse                      shift and go to state 236

state 230

    (87) while -> WHILE saveJumps LPAREN whilexp RPAREN quadsWhile LBRACE body RBRACE . jumpsWhile SEMICOLON
    (91) jumpsWhile -> .

    SEMICOLON       reduce using rule 91 (jumpsWhile -> .)

    jumpsWhile                     shift and go to state 237

state 231

    (102) arrvalues -> exp COMMA . arrvalues
    (101) arrvalues -> . exp
    (102) arrvalues -> . exp COMMA arrvalues
    (29) exp -> . texp
    (30) exp -> . texp OR exp
    (31) texp -> . gexp
    (32) texp -> . gexp AND texp
    (33) gexp -> . mexp
    (34) gexp -> . mexp gexpp mexp
    (39) mexp -> . t
    (40) mexp -> . mexp PLUS t
    (41) mexp -> . mexp MINUS t
    (42) t -> . f
    (43) t -> . t MULT f
    (44) t -> . t DIV f
    (45) f -> . LPAREN exp RPAREN
    (46) f -> . CTI
    (47) f -> . CTF
    (48) f -> . var
    (49) f -> . call
    (75) var -> . ID
    (76) call -> . ID LPAREN callp RPAREN

    LPAREN          shift and go to state 120
    CTI             shift and go to state 121
    CTF             shift and go to state 122
    ID              shift and go to state 124

    exp                            shift and go to state 224
    arrvalues                      shift and go to state 238
    texp                           shift and go to state 115
    gexp                           shift and go to state 116
    mexp                           shift and go to state 117
    t                              shift and go to state 118
    f                              shift and go to state 119
    var                            shift and go to state 113
    call                           shift and go to state 123

state 232

    (100) array -> ARRAY ID LBRACKET exp RBRACKET EQUAL LBRACKET arrvalues RBRACKET . SEMICOLON

    SEMICOLON       shift and go to state 239


state 233

    (103) matrix -> MATRIX ID LBRACKET exp RBRACKET LBRACKET exp RBRACKET EQUAL . LBRACKET matvalues RBRACKET SEMICOLON

    LBRACKET        shift and go to state 240


state 234

    (110) fit -> FIT LPAREN ID COMMA ID COMMA EPOCHS EQUAL CTI . RPAREN SEMICOLON

    RPAREN          shift and go to state 241


state 235

    (80) if -> IF LPAREN ifexp RPAREN quadsIf LBRACE body RBRACE ifelse jumpsIf . SEMICOLON

    SEMICOLON       shift and go to state 242


state 236

    (83) ifelse -> ELSE quadsElse . LBRACE body RBRACE

    LBRACE          shift and go to state 243


state 237

    (87) while -> WHILE saveJumps LPAREN whilexp RPAREN quadsWhile LBRACE body RBRACE jumpsWhile . SEMICOLON

    SEMICOLON       shift and go to state 244


state 238

    (102) arrvalues -> exp COMMA arrvalues .

    RBRACKET        reduce using rule 102 (arrvalues -> exp COMMA arrvalues .)


state 239

    (100) array -> ARRAY ID LBRACKET exp RBRACKET EQUAL LBRACKET arrvalues RBRACKET SEMICOLON .

    VAR             reduce using rule 100 (array -> ARRAY ID LBRACKET exp RBRACKET EQUAL LBRACKET arrvalues RBRACKET SEMICOLON .)
    FUNCTION        reduce using rule 100 (array -> ARRAY ID LBRACKET exp RBRACKET EQUAL LBRACKET arrvalues RBRACKET SEMICOLON .)
    ID              reduce using rule 100 (array -> ARRAY ID LBRACKET exp RBRACKET EQUAL LBRACKET arrvalues RBRACKET SEMICOLON .)
    READ            reduce using rule 100 (array -> ARRAY ID LBRACKET exp RBRACKET EQUAL LBRACKET arrvalues RBRACKET SEMICOLON .)
    PRINT           reduce using rule 100 (array -> ARRAY ID LBRACKET exp RBRACKET EQUAL LBRACKET arrvalues RBRACKET SEMICOLON .)
    IF              reduce using rule 100 (array -> ARRAY ID LBRACKET exp RBRACKET EQUAL LBRACKET arrvalues RBRACKET SEMICOLON .)
    WHILE           reduce using rule 100 (array -> ARRAY ID LBRACKET exp RBRACKET EQUAL LBRACKET arrvalues RBRACKET SEMICOLON .)
    ARRAY           reduce using rule 100 (array -> ARRAY ID LBRACKET exp RBRACKET EQUAL LBRACKET arrvalues RBRACKET SEMICOLON .)
    MATRIX          reduce using rule 100 (array -> ARRAY ID LBRACKET exp RBRACKET EQUAL LBRACKET arrvalues RBRACKET SEMICOLON .)
    MEAN            reduce using rule 100 (array -> ARRAY ID LBRACKET exp RBRACKET EQUAL LBRACKET arrvalues RBRACKET SEMICOLON .)
    LAYERS          reduce using rule 100 (array -> ARRAY ID LBRACKET exp RBRACKET EQUAL LBRACKET arrvalues RBRACKET SEMICOLON .)
    SEQUENTIAL      reduce using rule 100 (array -> ARRAY ID LBRACKET exp RBRACKET EQUAL LBRACKET arrvalues RBRACKET SEMICOLON .)
    COMPILE         reduce using rule 100 (array -> ARRAY ID LBRACKET exp RBRACKET EQUAL LBRACKET arrvalues RBRACKET SEMICOLON .)
    FIT             reduce using rule 100 (array -> ARRAY ID LBRACKET exp RBRACKET EQUAL LBRACKET arrvalues RBRACKET SEMICOLON .)
    PREDICT         reduce using rule 100 (array -> ARRAY ID LBRACKET exp RBRACKET EQUAL LBRACKET arrvalues RBRACKET SEMICOLON .)
    GETWEIGHTS      reduce using rule 100 (array -> ARRAY ID LBRACKET exp RBRACKET EQUAL LBRACKET arrvalues RBRACKET SEMICOLON .)
    FIBONACCI       reduce using rule 100 (array -> ARRAY ID LBRACKET exp RBRACKET EQUAL LBRACKET arrvalues RBRACKET SEMICOLON .)
    FACTORIAL       reduce using rule 100 (array -> ARRAY ID LBRACKET exp RBRACKET EQUAL LBRACKET arrvalues RBRACKET SEMICOLON .)
    MMULT           reduce using rule 100 (array -> ARRAY ID LBRACKET exp RBRACKET EQUAL LBRACKET arrvalues RBRACKET SEMICOLON .)
    RBRACE          reduce using rule 100 (array -> ARRAY ID LBRACKET exp RBRACKET EQUAL LBRACKET arrvalues RBRACKET SEMICOLON .)
    RETURN          reduce using rule 100 (array -> ARRAY ID LBRACKET exp RBRACKET EQUAL LBRACKET arrvalues RBRACKET SEMICOLON .)


state 240

    (103) matrix -> MATRIX ID LBRACKET exp RBRACKET LBRACKET exp RBRACKET EQUAL LBRACKET . matvalues RBRACKET SEMICOLON
    (104) matvalues -> . exp
    (105) matvalues -> . exp COMMA matvalues
    (29) exp -> . texp
    (30) exp -> . texp OR exp
    (31) texp -> . gexp
    (32) texp -> . gexp AND texp
    (33) gexp -> . mexp
    (34) gexp -> . mexp gexpp mexp
    (39) mexp -> . t
    (40) mexp -> . mexp PLUS t
    (41) mexp -> . mexp MINUS t
    (42) t -> . f
    (43) t -> . t MULT f
    (44) t -> . t DIV f
    (45) f -> . LPAREN exp RPAREN
    (46) f -> . CTI
    (47) f -> . CTF
    (48) f -> . var
    (49) f -> . call
    (75) var -> . ID
    (76) call -> . ID LPAREN callp RPAREN

    LPAREN          shift and go to state 120
    CTI             shift and go to state 121
    CTF             shift and go to state 122
    ID              shift and go to state 124

    exp                            shift and go to state 245
    matvalues                      shift and go to state 246
    texp                           shift and go to state 115
    gexp                           shift and go to state 116
    mexp                           shift and go to state 117
    t                              shift and go to state 118
    f                              shift and go to state 119
    var                            shift and go to state 113
    call                           shift and go to state 123

state 241

    (110) fit -> FIT LPAREN ID COMMA ID COMMA EPOCHS EQUAL CTI RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 247


state 242

    (80) if -> IF LPAREN ifexp RPAREN quadsIf LBRACE body RBRACE ifelse jumpsIf SEMICOLON .

    VAR             reduce using rule 80 (if -> IF LPAREN ifexp RPAREN quadsIf LBRACE body RBRACE ifelse jumpsIf SEMICOLON .)
    FUNCTION        reduce using rule 80 (if -> IF LPAREN ifexp RPAREN quadsIf LBRACE body RBRACE ifelse jumpsIf SEMICOLON .)
    ID              reduce using rule 80 (if -> IF LPAREN ifexp RPAREN quadsIf LBRACE body RBRACE ifelse jumpsIf SEMICOLON .)
    READ            reduce using rule 80 (if -> IF LPAREN ifexp RPAREN quadsIf LBRACE body RBRACE ifelse jumpsIf SEMICOLON .)
    PRINT           reduce using rule 80 (if -> IF LPAREN ifexp RPAREN quadsIf LBRACE body RBRACE ifelse jumpsIf SEMICOLON .)
    IF              reduce using rule 80 (if -> IF LPAREN ifexp RPAREN quadsIf LBRACE body RBRACE ifelse jumpsIf SEMICOLON .)
    WHILE           reduce using rule 80 (if -> IF LPAREN ifexp RPAREN quadsIf LBRACE body RBRACE ifelse jumpsIf SEMICOLON .)
    ARRAY           reduce using rule 80 (if -> IF LPAREN ifexp RPAREN quadsIf LBRACE body RBRACE ifelse jumpsIf SEMICOLON .)
    MATRIX          reduce using rule 80 (if -> IF LPAREN ifexp RPAREN quadsIf LBRACE body RBRACE ifelse jumpsIf SEMICOLON .)
    MEAN            reduce using rule 80 (if -> IF LPAREN ifexp RPAREN quadsIf LBRACE body RBRACE ifelse jumpsIf SEMICOLON .)
    LAYERS          reduce using rule 80 (if -> IF LPAREN ifexp RPAREN quadsIf LBRACE body RBRACE ifelse jumpsIf SEMICOLON .)
    SEQUENTIAL      reduce using rule 80 (if -> IF LPAREN ifexp RPAREN quadsIf LBRACE body RBRACE ifelse jumpsIf SEMICOLON .)
    COMPILE         reduce using rule 80 (if -> IF LPAREN ifexp RPAREN quadsIf LBRACE body RBRACE ifelse jumpsIf SEMICOLON .)
    FIT             reduce using rule 80 (if -> IF LPAREN ifexp RPAREN quadsIf LBRACE body RBRACE ifelse jumpsIf SEMICOLON .)
    PREDICT         reduce using rule 80 (if -> IF LPAREN ifexp RPAREN quadsIf LBRACE body RBRACE ifelse jumpsIf SEMICOLON .)
    GETWEIGHTS      reduce using rule 80 (if -> IF LPAREN ifexp RPAREN quadsIf LBRACE body RBRACE ifelse jumpsIf SEMICOLON .)
    FIBONACCI       reduce using rule 80 (if -> IF LPAREN ifexp RPAREN quadsIf LBRACE body RBRACE ifelse jumpsIf SEMICOLON .)
    FACTORIAL       reduce using rule 80 (if -> IF LPAREN ifexp RPAREN quadsIf LBRACE body RBRACE ifelse jumpsIf SEMICOLON .)
    MMULT           reduce using rule 80 (if -> IF LPAREN ifexp RPAREN quadsIf LBRACE body RBRACE ifelse jumpsIf SEMICOLON .)
    RBRACE          reduce using rule 80 (if -> IF LPAREN ifexp RPAREN quadsIf LBRACE body RBRACE ifelse jumpsIf SEMICOLON .)
    RETURN          reduce using rule 80 (if -> IF LPAREN ifexp RPAREN quadsIf LBRACE body RBRACE ifelse jumpsIf SEMICOLON .)


state 243

    (83) ifelse -> ELSE quadsElse LBRACE . body RBRACE
    (22) body -> . decvar statements body
    (23) body -> . statements body
    (24) body -> . decvar
    (25) body -> .
    (3) decvar -> . VAR decvarp
    (4) decvar -> . VAR decvarp decvar
    (5) decvar -> .
    (50) statements -> . assign
    (51) statements -> . function
    (52) statements -> . voidfunction
    (53) statements -> . call
    (54) statements -> . read
    (55) statements -> . print
    (56) statements -> . if
    (57) statements -> . while
    (58) statements -> . array
    (59) statements -> . matrix
    (60) statements -> . mean
    (61) statements -> . layers
    (62) statements -> . sequential
    (63) statements -> . compile
    (64) statements -> . fit
    (65) statements -> . predict
    (66) statements -> . getweights
    (67) statements -> . fibonacci
    (68) statements -> . factorial
    (69) statements -> . mmult
    (70) assign -> . var EQUAL exp SEMICOLON
    (11) function -> . FUNCTION decfunctype decfunc LPAREN param RPAREN LBRACE body RETURN exp SEMICOLON RBRACE
    (14) voidfunction -> . FUNCTION VOID decfunc LPAREN param RPAREN LBRACE body RBRACE
    (76) call -> . ID LPAREN callp RPAREN
    (71) read -> . READ LPAREN var RPAREN SEMICOLON
    (72) print -> . PRINT LPAREN printp SEMICOLON
    (80) if -> . IF LPAREN ifexp RPAREN quadsIf LBRACE body RBRACE ifelse jumpsIf SEMICOLON
    (87) while -> . WHILE saveJumps LPAREN whilexp RPAREN quadsWhile LBRACE body RBRACE jumpsWhile SEMICOLON
    (100) array -> . ARRAY ID LBRACKET exp RBRACKET EQUAL LBRACKET arrvalues RBRACKET SEMICOLON
    (103) matrix -> . MATRIX ID LBRACKET exp RBRACKET LBRACKET exp RBRACKET EQUAL LBRACKET matvalues RBRACKET SEMICOLON
    (106) mean -> . MEAN LPAREN ID RPAREN SEMICOLON
    (107) layers -> . LAYERS LPAREN UNITS EQUAL CTI RPAREN SEMICOLON
    (108) sequential -> . SEQUENTIAL LPAREN RPAREN SEMICOLON
    (109) compile -> . COMPILE LPAREN CTF RPAREN SEMICOLON
    (110) fit -> . FIT LPAREN ID COMMA ID COMMA EPOCHS EQUAL CTI RPAREN SEMICOLON
    (111) predict -> . PREDICT LPAREN CTF RPAREN SEMICOLON
    (112) getweights -> . GETWEIGHTS LPAREN RPAREN SEMICOLON
    (113) fibonacci -> . FIBONACCI LPAREN exp RPAREN SEMICOLON
    (114) factorial -> . FACTORIAL LPAREN exp RPAREN SEMICOLON
    (115) mmult -> . MMULT LPAREN ID COMMA ID RPAREN SEMICOLON
    (75) var -> . ID

  ! reduce/reduce conflict for RBRACE resolved using rule 5 (decvar -> .)
  ! shift/reduce conflict for FUNCTION resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for READ resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for ARRAY resolved as shift
  ! shift/reduce conflict for MATRIX resolved as shift
  ! shift/reduce conflict for MEAN resolved as shift
  ! shift/reduce conflict for LAYERS resolved as shift
  ! shift/reduce conflict for SEQUENTIAL resolved as shift
  ! shift/reduce conflict for COMPILE resolved as shift
  ! shift/reduce conflict for FIT resolved as shift
  ! shift/reduce conflict for PREDICT resolved as shift
  ! shift/reduce conflict for GETWEIGHTS resolved as shift
  ! shift/reduce conflict for FIBONACCI resolved as shift
  ! shift/reduce conflict for FACTORIAL resolved as shift
  ! shift/reduce conflict for MMULT resolved as shift
    VAR             shift and go to state 7
    RBRACE          reduce using rule 5 (decvar -> .)
    FUNCTION        shift and go to state 11
    ID              shift and go to state 68
    READ            shift and go to state 69
    PRINT           shift and go to state 70
    IF              shift and go to state 71
    WHILE           shift and go to state 72
    ARRAY           shift and go to state 73
    MATRIX          shift and go to state 74
    MEAN            shift and go to state 75
    LAYERS          shift and go to state 76
    SEQUENTIAL      shift and go to state 77
    COMPILE         shift and go to state 78
    FIT             shift and go to state 79
    PREDICT         shift and go to state 80
    GETWEIGHTS      shift and go to state 81
    FIBONACCI       shift and go to state 82
    FACTORIAL       shift and go to state 83
    MMULT           shift and go to state 84

  ! RBRACE          [ reduce using rule 25 (body -> .) ]
  ! FUNCTION        [ reduce using rule 5 (decvar -> .) ]
  ! ID              [ reduce using rule 5 (decvar -> .) ]
  ! READ            [ reduce using rule 5 (decvar -> .) ]
  ! PRINT           [ reduce using rule 5 (decvar -> .) ]
  ! IF              [ reduce using rule 5 (decvar -> .) ]
  ! WHILE           [ reduce using rule 5 (decvar -> .) ]
  ! ARRAY           [ reduce using rule 5 (decvar -> .) ]
  ! MATRIX          [ reduce using rule 5 (decvar -> .) ]
  ! MEAN            [ reduce using rule 5 (decvar -> .) ]
  ! LAYERS          [ reduce using rule 5 (decvar -> .) ]
  ! SEQUENTIAL      [ reduce using rule 5 (decvar -> .) ]
  ! COMPILE         [ reduce using rule 5 (decvar -> .) ]
  ! FIT             [ reduce using rule 5 (decvar -> .) ]
  ! PREDICT         [ reduce using rule 5 (decvar -> .) ]
  ! GETWEIGHTS      [ reduce using rule 5 (decvar -> .) ]
  ! FIBONACCI       [ reduce using rule 5 (decvar -> .) ]
  ! FACTORIAL       [ reduce using rule 5 (decvar -> .) ]
  ! MMULT           [ reduce using rule 5 (decvar -> .) ]

    body                           shift and go to state 248
    decvar                         shift and go to state 45
    statements                     shift and go to state 46
    assign                         shift and go to state 47
    function                       shift and go to state 48
    voidfunction                   shift and go to state 49
    call                           shift and go to state 50
    read                           shift and go to state 51
    print                          shift and go to state 52
    if                             shift and go to state 53
    while                          shift and go to state 54
    array                          shift and go to state 55
    matrix                         shift and go to state 56
    mean                           shift and go to state 57
    layers                         shift and go to state 58
    sequential                     shift and go to state 59
    compile                        shift and go to state 60
    fit                            shift and go to state 61
    predict                        shift and go to state 62
    getweights                     shift and go to state 63
    fibonacci                      shift and go to state 64
    factorial                      shift and go to state 65
    mmult                          shift and go to state 66
    var                            shift and go to state 67

state 244

    (87) while -> WHILE saveJumps LPAREN whilexp RPAREN quadsWhile LBRACE body RBRACE jumpsWhile SEMICOLON .

    VAR             reduce using rule 87 (while -> WHILE saveJumps LPAREN whilexp RPAREN quadsWhile LBRACE body RBRACE jumpsWhile SEMICOLON .)
    FUNCTION        reduce using rule 87 (while -> WHILE saveJumps LPAREN whilexp RPAREN quadsWhile LBRACE body RBRACE jumpsWhile SEMICOLON .)
    ID              reduce using rule 87 (while -> WHILE saveJumps LPAREN whilexp RPAREN quadsWhile LBRACE body RBRACE jumpsWhile SEMICOLON .)
    READ            reduce using rule 87 (while -> WHILE saveJumps LPAREN whilexp RPAREN quadsWhile LBRACE body RBRACE jumpsWhile SEMICOLON .)
    PRINT           reduce using rule 87 (while -> WHILE saveJumps LPAREN whilexp RPAREN quadsWhile LBRACE body RBRACE jumpsWhile SEMICOLON .)
    IF              reduce using rule 87 (while -> WHILE saveJumps LPAREN whilexp RPAREN quadsWhile LBRACE body RBRACE jumpsWhile SEMICOLON .)
    WHILE           reduce using rule 87 (while -> WHILE saveJumps LPAREN whilexp RPAREN quadsWhile LBRACE body RBRACE jumpsWhile SEMICOLON .)
    ARRAY           reduce using rule 87 (while -> WHILE saveJumps LPAREN whilexp RPAREN quadsWhile LBRACE body RBRACE jumpsWhile SEMICOLON .)
    MATRIX          reduce using rule 87 (while -> WHILE saveJumps LPAREN whilexp RPAREN quadsWhile LBRACE body RBRACE jumpsWhile SEMICOLON .)
    MEAN            reduce using rule 87 (while -> WHILE saveJumps LPAREN whilexp RPAREN quadsWhile LBRACE body RBRACE jumpsWhile SEMICOLON .)
    LAYERS          reduce using rule 87 (while -> WHILE saveJumps LPAREN whilexp RPAREN quadsWhile LBRACE body RBRACE jumpsWhile SEMICOLON .)
    SEQUENTIAL      reduce using rule 87 (while -> WHILE saveJumps LPAREN whilexp RPAREN quadsWhile LBRACE body RBRACE jumpsWhile SEMICOLON .)
    COMPILE         reduce using rule 87 (while -> WHILE saveJumps LPAREN whilexp RPAREN quadsWhile LBRACE body RBRACE jumpsWhile SEMICOLON .)
    FIT             reduce using rule 87 (while -> WHILE saveJumps LPAREN whilexp RPAREN quadsWhile LBRACE body RBRACE jumpsWhile SEMICOLON .)
    PREDICT         reduce using rule 87 (while -> WHILE saveJumps LPAREN whilexp RPAREN quadsWhile LBRACE body RBRACE jumpsWhile SEMICOLON .)
    GETWEIGHTS      reduce using rule 87 (while -> WHILE saveJumps LPAREN whilexp RPAREN quadsWhile LBRACE body RBRACE jumpsWhile SEMICOLON .)
    FIBONACCI       reduce using rule 87 (while -> WHILE saveJumps LPAREN whilexp RPAREN quadsWhile LBRACE body RBRACE jumpsWhile SEMICOLON .)
    FACTORIAL       reduce using rule 87 (while -> WHILE saveJumps LPAREN whilexp RPAREN quadsWhile LBRACE body RBRACE jumpsWhile SEMICOLON .)
    MMULT           reduce using rule 87 (while -> WHILE saveJumps LPAREN whilexp RPAREN quadsWhile LBRACE body RBRACE jumpsWhile SEMICOLON .)
    RBRACE          reduce using rule 87 (while -> WHILE saveJumps LPAREN whilexp RPAREN quadsWhile LBRACE body RBRACE jumpsWhile SEMICOLON .)
    RETURN          reduce using rule 87 (while -> WHILE saveJumps LPAREN whilexp RPAREN quadsWhile LBRACE body RBRACE jumpsWhile SEMICOLON .)


state 245

    (104) matvalues -> exp .
    (105) matvalues -> exp . COMMA matvalues

    RBRACKET        reduce using rule 104 (matvalues -> exp .)
    COMMA           shift and go to state 249


state 246

    (103) matrix -> MATRIX ID LBRACKET exp RBRACKET LBRACKET exp RBRACKET EQUAL LBRACKET matvalues . RBRACKET SEMICOLON

    RBRACKET        shift and go to state 250


state 247

    (110) fit -> FIT LPAREN ID COMMA ID COMMA EPOCHS EQUAL CTI RPAREN SEMICOLON .

    VAR             reduce using rule 110 (fit -> FIT LPAREN ID COMMA ID COMMA EPOCHS EQUAL CTI RPAREN SEMICOLON .)
    FUNCTION        reduce using rule 110 (fit -> FIT LPAREN ID COMMA ID COMMA EPOCHS EQUAL CTI RPAREN SEMICOLON .)
    ID              reduce using rule 110 (fit -> FIT LPAREN ID COMMA ID COMMA EPOCHS EQUAL CTI RPAREN SEMICOLON .)
    READ            reduce using rule 110 (fit -> FIT LPAREN ID COMMA ID COMMA EPOCHS EQUAL CTI RPAREN SEMICOLON .)
    PRINT           reduce using rule 110 (fit -> FIT LPAREN ID COMMA ID COMMA EPOCHS EQUAL CTI RPAREN SEMICOLON .)
    IF              reduce using rule 110 (fit -> FIT LPAREN ID COMMA ID COMMA EPOCHS EQUAL CTI RPAREN SEMICOLON .)
    WHILE           reduce using rule 110 (fit -> FIT LPAREN ID COMMA ID COMMA EPOCHS EQUAL CTI RPAREN SEMICOLON .)
    ARRAY           reduce using rule 110 (fit -> FIT LPAREN ID COMMA ID COMMA EPOCHS EQUAL CTI RPAREN SEMICOLON .)
    MATRIX          reduce using rule 110 (fit -> FIT LPAREN ID COMMA ID COMMA EPOCHS EQUAL CTI RPAREN SEMICOLON .)
    MEAN            reduce using rule 110 (fit -> FIT LPAREN ID COMMA ID COMMA EPOCHS EQUAL CTI RPAREN SEMICOLON .)
    LAYERS          reduce using rule 110 (fit -> FIT LPAREN ID COMMA ID COMMA EPOCHS EQUAL CTI RPAREN SEMICOLON .)
    SEQUENTIAL      reduce using rule 110 (fit -> FIT LPAREN ID COMMA ID COMMA EPOCHS EQUAL CTI RPAREN SEMICOLON .)
    COMPILE         reduce using rule 110 (fit -> FIT LPAREN ID COMMA ID COMMA EPOCHS EQUAL CTI RPAREN SEMICOLON .)
    FIT             reduce using rule 110 (fit -> FIT LPAREN ID COMMA ID COMMA EPOCHS EQUAL CTI RPAREN SEMICOLON .)
    PREDICT         reduce using rule 110 (fit -> FIT LPAREN ID COMMA ID COMMA EPOCHS EQUAL CTI RPAREN SEMICOLON .)
    GETWEIGHTS      reduce using rule 110 (fit -> FIT LPAREN ID COMMA ID COMMA EPOCHS EQUAL CTI RPAREN SEMICOLON .)
    FIBONACCI       reduce using rule 110 (fit -> FIT LPAREN ID COMMA ID COMMA EPOCHS EQUAL CTI RPAREN SEMICOLON .)
    FACTORIAL       reduce using rule 110 (fit -> FIT LPAREN ID COMMA ID COMMA EPOCHS EQUAL CTI RPAREN SEMICOLON .)
    MMULT           reduce using rule 110 (fit -> FIT LPAREN ID COMMA ID COMMA EPOCHS EQUAL CTI RPAREN SEMICOLON .)
    RBRACE          reduce using rule 110 (fit -> FIT LPAREN ID COMMA ID COMMA EPOCHS EQUAL CTI RPAREN SEMICOLON .)
    RETURN          reduce using rule 110 (fit -> FIT LPAREN ID COMMA ID COMMA EPOCHS EQUAL CTI RPAREN SEMICOLON .)


state 248

    (83) ifelse -> ELSE quadsElse LBRACE body . RBRACE

    RBRACE          shift and go to state 251


state 249

    (105) matvalues -> exp COMMA . matvalues
    (104) matvalues -> . exp
    (105) matvalues -> . exp COMMA matvalues
    (29) exp -> . texp
    (30) exp -> . texp OR exp
    (31) texp -> . gexp
    (32) texp -> . gexp AND texp
    (33) gexp -> . mexp
    (34) gexp -> . mexp gexpp mexp
    (39) mexp -> . t
    (40) mexp -> . mexp PLUS t
    (41) mexp -> . mexp MINUS t
    (42) t -> . f
    (43) t -> . t MULT f
    (44) t -> . t DIV f
    (45) f -> . LPAREN exp RPAREN
    (46) f -> . CTI
    (47) f -> . CTF
    (48) f -> . var
    (49) f -> . call
    (75) var -> . ID
    (76) call -> . ID LPAREN callp RPAREN

    LPAREN          shift and go to state 120
    CTI             shift and go to state 121
    CTF             shift and go to state 122
    ID              shift and go to state 124

    exp                            shift and go to state 245
    matvalues                      shift and go to state 252
    texp                           shift and go to state 115
    gexp                           shift and go to state 116
    mexp                           shift and go to state 117
    t                              shift and go to state 118
    f                              shift and go to state 119
    var                            shift and go to state 113
    call                           shift and go to state 123

state 250

    (103) matrix -> MATRIX ID LBRACKET exp RBRACKET LBRACKET exp RBRACKET EQUAL LBRACKET matvalues RBRACKET . SEMICOLON

    SEMICOLON       shift and go to state 253


state 251

    (83) ifelse -> ELSE quadsElse LBRACE body RBRACE .

    SEMICOLON       reduce using rule 83 (ifelse -> ELSE quadsElse LBRACE body RBRACE .)


state 252

    (105) matvalues -> exp COMMA matvalues .

    RBRACKET        reduce using rule 105 (matvalues -> exp COMMA matvalues .)


state 253

    (103) matrix -> MATRIX ID LBRACKET exp RBRACKET LBRACKET exp RBRACKET EQUAL LBRACKET matvalues RBRACKET SEMICOLON .

    VAR             reduce using rule 103 (matrix -> MATRIX ID LBRACKET exp RBRACKET LBRACKET exp RBRACKET EQUAL LBRACKET matvalues RBRACKET SEMICOLON .)
    FUNCTION        reduce using rule 103 (matrix -> MATRIX ID LBRACKET exp RBRACKET LBRACKET exp RBRACKET EQUAL LBRACKET matvalues RBRACKET SEMICOLON .)
    ID              reduce using rule 103 (matrix -> MATRIX ID LBRACKET exp RBRACKET LBRACKET exp RBRACKET EQUAL LBRACKET matvalues RBRACKET SEMICOLON .)
    READ            reduce using rule 103 (matrix -> MATRIX ID LBRACKET exp RBRACKET LBRACKET exp RBRACKET EQUAL LBRACKET matvalues RBRACKET SEMICOLON .)
    PRINT           reduce using rule 103 (matrix -> MATRIX ID LBRACKET exp RBRACKET LBRACKET exp RBRACKET EQUAL LBRACKET matvalues RBRACKET SEMICOLON .)
    IF              reduce using rule 103 (matrix -> MATRIX ID LBRACKET exp RBRACKET LBRACKET exp RBRACKET EQUAL LBRACKET matvalues RBRACKET SEMICOLON .)
    WHILE           reduce using rule 103 (matrix -> MATRIX ID LBRACKET exp RBRACKET LBRACKET exp RBRACKET EQUAL LBRACKET matvalues RBRACKET SEMICOLON .)
    ARRAY           reduce using rule 103 (matrix -> MATRIX ID LBRACKET exp RBRACKET LBRACKET exp RBRACKET EQUAL LBRACKET matvalues RBRACKET SEMICOLON .)
    MATRIX          reduce using rule 103 (matrix -> MATRIX ID LBRACKET exp RBRACKET LBRACKET exp RBRACKET EQUAL LBRACKET matvalues RBRACKET SEMICOLON .)
    MEAN            reduce using rule 103 (matrix -> MATRIX ID LBRACKET exp RBRACKET LBRACKET exp RBRACKET EQUAL LBRACKET matvalues RBRACKET SEMICOLON .)
    LAYERS          reduce using rule 103 (matrix -> MATRIX ID LBRACKET exp RBRACKET LBRACKET exp RBRACKET EQUAL LBRACKET matvalues RBRACKET SEMICOLON .)
    SEQUENTIAL      reduce using rule 103 (matrix -> MATRIX ID LBRACKET exp RBRACKET LBRACKET exp RBRACKET EQUAL LBRACKET matvalues RBRACKET SEMICOLON .)
    COMPILE         reduce using rule 103 (matrix -> MATRIX ID LBRACKET exp RBRACKET LBRACKET exp RBRACKET EQUAL LBRACKET matvalues RBRACKET SEMICOLON .)
    FIT             reduce using rule 103 (matrix -> MATRIX ID LBRACKET exp RBRACKET LBRACKET exp RBRACKET EQUAL LBRACKET matvalues RBRACKET SEMICOLON .)
    PREDICT         reduce using rule 103 (matrix -> MATRIX ID LBRACKET exp RBRACKET LBRACKET exp RBRACKET EQUAL LBRACKET matvalues RBRACKET SEMICOLON .)
    GETWEIGHTS      reduce using rule 103 (matrix -> MATRIX ID LBRACKET exp RBRACKET LBRACKET exp RBRACKET EQUAL LBRACKET matvalues RBRACKET SEMICOLON .)
    FIBONACCI       reduce using rule 103 (matrix -> MATRIX ID LBRACKET exp RBRACKET LBRACKET exp RBRACKET EQUAL LBRACKET matvalues RBRACKET SEMICOLON .)
    FACTORIAL       reduce using rule 103 (matrix -> MATRIX ID LBRACKET exp RBRACKET LBRACKET exp RBRACKET EQUAL LBRACKET matvalues RBRACKET SEMICOLON .)
    MMULT           reduce using rule 103 (matrix -> MATRIX ID LBRACKET exp RBRACKET LBRACKET exp RBRACKET EQUAL LBRACKET matvalues RBRACKET SEMICOLON .)
    RBRACE          reduce using rule 103 (matrix -> MATRIX ID LBRACKET exp RBRACKET LBRACKET exp RBRACKET EQUAL LBRACKET matvalues RBRACKET SEMICOLON .)
    RETURN          reduce using rule 103 (matrix -> MATRIX ID LBRACKET exp RBRACKET LBRACKET exp RBRACKET EQUAL LBRACKET matvalues RBRACKET SEMICOLON .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for FUNCTION in state 40 resolved as shift
WARNING: shift/reduce conflict for ID in state 40 resolved as shift
WARNING: shift/reduce conflict for READ in state 40 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 40 resolved as shift
WARNING: shift/reduce conflict for IF in state 40 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 40 resolved as shift
WARNING: shift/reduce conflict for ARRAY in state 40 resolved as shift
WARNING: shift/reduce conflict for MATRIX in state 40 resolved as shift
WARNING: shift/reduce conflict for MEAN in state 40 resolved as shift
WARNING: shift/reduce conflict for LAYERS in state 40 resolved as shift
WARNING: shift/reduce conflict for SEQUENTIAL in state 40 resolved as shift
WARNING: shift/reduce conflict for COMPILE in state 40 resolved as shift
WARNING: shift/reduce conflict for FIT in state 40 resolved as shift
WARNING: shift/reduce conflict for PREDICT in state 40 resolved as shift
WARNING: shift/reduce conflict for GETWEIGHTS in state 40 resolved as shift
WARNING: shift/reduce conflict for FIBONACCI in state 40 resolved as shift
WARNING: shift/reduce conflict for FACTORIAL in state 40 resolved as shift
WARNING: shift/reduce conflict for MMULT in state 40 resolved as shift
WARNING: shift/reduce conflict for FUNCTION in state 46 resolved as shift
WARNING: shift/reduce conflict for ID in state 46 resolved as shift
WARNING: shift/reduce conflict for READ in state 46 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 46 resolved as shift
WARNING: shift/reduce conflict for IF in state 46 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 46 resolved as shift
WARNING: shift/reduce conflict for ARRAY in state 46 resolved as shift
WARNING: shift/reduce conflict for MATRIX in state 46 resolved as shift
WARNING: shift/reduce conflict for MEAN in state 46 resolved as shift
WARNING: shift/reduce conflict for LAYERS in state 46 resolved as shift
WARNING: shift/reduce conflict for SEQUENTIAL in state 46 resolved as shift
WARNING: shift/reduce conflict for COMPILE in state 46 resolved as shift
WARNING: shift/reduce conflict for FIT in state 46 resolved as shift
WARNING: shift/reduce conflict for PREDICT in state 46 resolved as shift
WARNING: shift/reduce conflict for GETWEIGHTS in state 46 resolved as shift
WARNING: shift/reduce conflict for FIBONACCI in state 46 resolved as shift
WARNING: shift/reduce conflict for FACTORIAL in state 46 resolved as shift
WARNING: shift/reduce conflict for MMULT in state 46 resolved as shift
WARNING: shift/reduce conflict for FUNCTION in state 85 resolved as shift
WARNING: shift/reduce conflict for ID in state 85 resolved as shift
WARNING: shift/reduce conflict for READ in state 85 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 85 resolved as shift
WARNING: shift/reduce conflict for IF in state 85 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 85 resolved as shift
WARNING: shift/reduce conflict for ARRAY in state 85 resolved as shift
WARNING: shift/reduce conflict for MATRIX in state 85 resolved as shift
WARNING: shift/reduce conflict for MEAN in state 85 resolved as shift
WARNING: shift/reduce conflict for LAYERS in state 85 resolved as shift
WARNING: shift/reduce conflict for SEQUENTIAL in state 85 resolved as shift
WARNING: shift/reduce conflict for COMPILE in state 85 resolved as shift
WARNING: shift/reduce conflict for FIT in state 85 resolved as shift
WARNING: shift/reduce conflict for PREDICT in state 85 resolved as shift
WARNING: shift/reduce conflict for GETWEIGHTS in state 85 resolved as shift
WARNING: shift/reduce conflict for FIBONACCI in state 85 resolved as shift
WARNING: shift/reduce conflict for FACTORIAL in state 85 resolved as shift
WARNING: shift/reduce conflict for MMULT in state 85 resolved as shift
WARNING: shift/reduce conflict for FUNCTION in state 87 resolved as shift
WARNING: shift/reduce conflict for ID in state 87 resolved as shift
WARNING: shift/reduce conflict for READ in state 87 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 87 resolved as shift
WARNING: shift/reduce conflict for IF in state 87 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 87 resolved as shift
WARNING: shift/reduce conflict for ARRAY in state 87 resolved as shift
WARNING: shift/reduce conflict for MATRIX in state 87 resolved as shift
WARNING: shift/reduce conflict for MEAN in state 87 resolved as shift
WARNING: shift/reduce conflict for LAYERS in state 87 resolved as shift
WARNING: shift/reduce conflict for SEQUENTIAL in state 87 resolved as shift
WARNING: shift/reduce conflict for COMPILE in state 87 resolved as shift
WARNING: shift/reduce conflict for FIT in state 87 resolved as shift
WARNING: shift/reduce conflict for PREDICT in state 87 resolved as shift
WARNING: shift/reduce conflict for GETWEIGHTS in state 87 resolved as shift
WARNING: shift/reduce conflict for FIBONACCI in state 87 resolved as shift
WARNING: shift/reduce conflict for FACTORIAL in state 87 resolved as shift
WARNING: shift/reduce conflict for MMULT in state 87 resolved as shift
WARNING: shift/reduce conflict for FUNCTION in state 89 resolved as shift
WARNING: shift/reduce conflict for ID in state 89 resolved as shift
WARNING: shift/reduce conflict for READ in state 89 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 89 resolved as shift
WARNING: shift/reduce conflict for IF in state 89 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 89 resolved as shift
WARNING: shift/reduce conflict for ARRAY in state 89 resolved as shift
WARNING: shift/reduce conflict for MATRIX in state 89 resolved as shift
WARNING: shift/reduce conflict for MEAN in state 89 resolved as shift
WARNING: shift/reduce conflict for LAYERS in state 89 resolved as shift
WARNING: shift/reduce conflict for SEQUENTIAL in state 89 resolved as shift
WARNING: shift/reduce conflict for COMPILE in state 89 resolved as shift
WARNING: shift/reduce conflict for FIT in state 89 resolved as shift
WARNING: shift/reduce conflict for PREDICT in state 89 resolved as shift
WARNING: shift/reduce conflict for GETWEIGHTS in state 89 resolved as shift
WARNING: shift/reduce conflict for FIBONACCI in state 89 resolved as shift
WARNING: shift/reduce conflict for FACTORIAL in state 89 resolved as shift
WARNING: shift/reduce conflict for MMULT in state 89 resolved as shift
WARNING: shift/reduce conflict for FUNCTION in state 207 resolved as shift
WARNING: shift/reduce conflict for ID in state 207 resolved as shift
WARNING: shift/reduce conflict for READ in state 207 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 207 resolved as shift
WARNING: shift/reduce conflict for IF in state 207 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 207 resolved as shift
WARNING: shift/reduce conflict for ARRAY in state 207 resolved as shift
WARNING: shift/reduce conflict for MATRIX in state 207 resolved as shift
WARNING: shift/reduce conflict for MEAN in state 207 resolved as shift
WARNING: shift/reduce conflict for LAYERS in state 207 resolved as shift
WARNING: shift/reduce conflict for SEQUENTIAL in state 207 resolved as shift
WARNING: shift/reduce conflict for COMPILE in state 207 resolved as shift
WARNING: shift/reduce conflict for FIT in state 207 resolved as shift
WARNING: shift/reduce conflict for PREDICT in state 207 resolved as shift
WARNING: shift/reduce conflict for GETWEIGHTS in state 207 resolved as shift
WARNING: shift/reduce conflict for FIBONACCI in state 207 resolved as shift
WARNING: shift/reduce conflict for FACTORIAL in state 207 resolved as shift
WARNING: shift/reduce conflict for MMULT in state 207 resolved as shift
WARNING: shift/reduce conflict for FUNCTION in state 216 resolved as shift
WARNING: shift/reduce conflict for ID in state 216 resolved as shift
WARNING: shift/reduce conflict for READ in state 216 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 216 resolved as shift
WARNING: shift/reduce conflict for IF in state 216 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 216 resolved as shift
WARNING: shift/reduce conflict for ARRAY in state 216 resolved as shift
WARNING: shift/reduce conflict for MATRIX in state 216 resolved as shift
WARNING: shift/reduce conflict for MEAN in state 216 resolved as shift
WARNING: shift/reduce conflict for LAYERS in state 216 resolved as shift
WARNING: shift/reduce conflict for SEQUENTIAL in state 216 resolved as shift
WARNING: shift/reduce conflict for COMPILE in state 216 resolved as shift
WARNING: shift/reduce conflict for FIT in state 216 resolved as shift
WARNING: shift/reduce conflict for PREDICT in state 216 resolved as shift
WARNING: shift/reduce conflict for GETWEIGHTS in state 216 resolved as shift
WARNING: shift/reduce conflict for FIBONACCI in state 216 resolved as shift
WARNING: shift/reduce conflict for FACTORIAL in state 216 resolved as shift
WARNING: shift/reduce conflict for MMULT in state 216 resolved as shift
WARNING: shift/reduce conflict for FUNCTION in state 243 resolved as shift
WARNING: shift/reduce conflict for ID in state 243 resolved as shift
WARNING: shift/reduce conflict for READ in state 243 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 243 resolved as shift
WARNING: shift/reduce conflict for IF in state 243 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 243 resolved as shift
WARNING: shift/reduce conflict for ARRAY in state 243 resolved as shift
WARNING: shift/reduce conflict for MATRIX in state 243 resolved as shift
WARNING: shift/reduce conflict for MEAN in state 243 resolved as shift
WARNING: shift/reduce conflict for LAYERS in state 243 resolved as shift
WARNING: shift/reduce conflict for SEQUENTIAL in state 243 resolved as shift
WARNING: shift/reduce conflict for COMPILE in state 243 resolved as shift
WARNING: shift/reduce conflict for FIT in state 243 resolved as shift
WARNING: shift/reduce conflict for PREDICT in state 243 resolved as shift
WARNING: shift/reduce conflict for GETWEIGHTS in state 243 resolved as shift
WARNING: shift/reduce conflict for FIBONACCI in state 243 resolved as shift
WARNING: shift/reduce conflict for FACTORIAL in state 243 resolved as shift
WARNING: shift/reduce conflict for MMULT in state 243 resolved as shift
WARNING: reduce/reduce conflict in state 9 resolved using rule (modules -> function)
WARNING: rejected rule (modules -> <empty>) in state 9
WARNING: reduce/reduce conflict in state 10 resolved using rule (modules -> voidfunction)
WARNING: rejected rule (modules -> <empty>) in state 10
WARNING: reduce/reduce conflict in state 12 resolved using rule (decvar -> VAR decvarp)
WARNING: rejected rule (decvar -> <empty>) in state 12
WARNING: reduce/reduce conflict in state 40 resolved using rule (decvar -> <empty>)
WARNING: rejected rule (body -> <empty>) in state 40
WARNING: reduce/reduce conflict in state 46 resolved using rule (decvar -> <empty>)
WARNING: rejected rule (body -> <empty>) in state 46
WARNING: reduce/reduce conflict in state 85 resolved using rule (decvar -> <empty>)
WARNING: rejected rule (body -> <empty>) in state 85
WARNING: reduce/reduce conflict in state 87 resolved using rule (decvar -> <empty>)
WARNING: rejected rule (body -> <empty>) in state 87
WARNING: reduce/reduce conflict in state 89 resolved using rule (decvar -> <empty>)
WARNING: rejected rule (body -> <empty>) in state 89
WARNING: reduce/reduce conflict in state 207 resolved using rule (decvar -> <empty>)
WARNING: rejected rule (body -> <empty>) in state 207
WARNING: reduce/reduce conflict in state 216 resolved using rule (decvar -> <empty>)
WARNING: rejected rule (body -> <empty>) in state 216
WARNING: reduce/reduce conflict in state 243 resolved using rule (decvar -> <empty>)
WARNING: rejected rule (body -> <empty>) in state 243
WARNING: Rule (body -> <empty>) is never reduced
