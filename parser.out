Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    ASSIGN
    CHAR
    COLON
    CTF
    CTI
    FUNCESP
    GTE
    LTE
    NUMPY
    QUOTE
    STRING

Grammar

Rule 0     S' -> program
Rule 1     program -> PROGRAM ID SEMICOLON decvar
Rule 2     decvar -> VAR type decvarp SEMICOLON
Rule 3     decvarp -> ID COMMA decvarp
Rule 4     decvarp -> ID
Rule 5     type -> INT
Rule 6     type -> FLOAT
Rule 7     function -> FUNCTION type ID LPAREN param RPAREN body
Rule 8     voidfunction -> FUNCTION VOID ID LPAREN param RPAREN body
Rule 9     body -> LBRACE bodyp RBRACE
Rule 10    bodyp -> decvar statements bodyp
Rule 11    bodyp -> statements bodyp
Rule 12    bodyp -> decvar
Rule 13    bodyp -> <empty>
Rule 14    param -> <empty>
Rule 15    param -> type paramp
Rule 16    paramp -> ID
Rule 17    paramp -> ID COMMA param
Rule 18    exp -> texp
Rule 19    exp -> texp OR exp
Rule 20    texp -> gexp
Rule 21    texp -> gexp AND texp
Rule 22    gexp -> mexp
Rule 23    gexp -> mexp gexpp mexp
Rule 24    gexpp -> LT
Rule 25    gexpp -> GT
Rule 26    gexpp -> EQUAL
Rule 27    gexpp -> DIFF
Rule 28    mexp -> t
Rule 29    mexp -> t PLUS mexp
Rule 30    mexp -> t MINUS mexp
Rule 31    t -> f
Rule 32    t -> f MULT t
Rule 33    t -> f DIV t
Rule 34    f -> LPAREN exp RPAREN
Rule 35    f -> INT
Rule 36    f -> FLOAT
Rule 37    f -> var
Rule 38    f -> call
Rule 39    statements -> assign
Rule 40    statements -> function
Rule 41    statements -> voidfunction
Rule 42    statements -> call
Rule 43    statements -> read
Rule 44    statements -> print
Rule 45    statements -> if
Rule 46    statements -> while
Rule 47    statements -> for
Rule 48    statements -> funcesp
Rule 49    assign -> var EQUAL exp
Rule 50    read -> READ var
Rule 51    print -> PRINT LPAREN printp
Rule 52    printp -> exp RPAREN
Rule 53    printp -> exp COMMA printp
Rule 54    var -> ID
Rule 55    var -> ID LBRACKET exp RBRACKET
Rule 56    var -> ID LBRACKET exp RBRACKET LBRACKET exp RBRACKET
Rule 57    call -> ID LPAREN callp RPAREN
Rule 58    callp -> exp SEMICOLON callp
Rule 59    callp -> exp
Rule 60    if -> IF LPAREN exp RPAREN statements ifp
Rule 61    ifp -> <empty>
Rule 62    ifp -> ELSE statements
Rule 63    while -> WHILE LPAREN exp RPAREN statements whilep
Rule 64    whilep -> SEMICOLON
Rule 65    whilep -> statements whilep
Rule 66    for -> FOR LPAREN var SEMICOLON exp SEMICOLON exp RPAREN LBRACKET statements forp
Rule 67    forp -> RBRACKET
Rule 68    forp -> statements forp
Rule 69    funcesp -> array
Rule 70    funcesp -> matrix
Rule 71    funcesp -> mean
Rule 72    funcesp -> layers
Rule 73    funcesp -> sequential
Rule 74    funcesp -> compile
Rule 75    funcesp -> fit
Rule 76    funcesp -> predict
Rule 77    funcesp -> getweights
Rule 78    array -> ID EQUAL ARRAY LPAREN var arrayp
Rule 79    arrayp -> RPAREN
Rule 80    arrayp -> COMMA var RPAREN
Rule 81    matrix -> ID EQUAL MATRIX LPAREN array matrixp
Rule 82    matrixp -> RPAREN
Rule 83    matrixp -> COMMA array RPAREN
Rule 84    mean -> MEAN LPAREN array RPAREN
Rule 85    layers -> ID EQUAL LAYERS LPAREN UNITS EQUAL INT RPAREN
Rule 86    sequential -> ID EQUAL SEQUENTIAL LPAREN LBRACKET layers sequentialp
Rule 87    sequentialp -> RBRACKET RPAREN
Rule 88    sequentialp -> COMMA layers sequentialp
Rule 89    compile -> sequential DOT COMPILE LPAREN RPAREN
Rule 90    fit -> ID EQUAL sequential DOT FIT LPAREN array COMMA array COMMA EPOCHS EQUAL INT COMMA VERBOSE EQUAL fitp
Rule 91    fitp -> TRUE RPAREN
Rule 92    fitp -> FALSE RPAREN
Rule 93    predict -> ID EQUAL sequential DOT PREDICT LPAREN LBRACKET predictp
Rule 94    predictp -> INT RBRACKET RPAREN
Rule 95    predictp -> FLOAT RBRACKET RPAREN
Rule 96    getweights -> layers DOT GETWEIGHTS LPAREN RPAREN
Rule 97    empty -> <empty>

Terminals, with rules where they appear

AND                  : 21
ARRAY                : 78
ASSIGN               : 
CHAR                 : 
COLON                : 
COMMA                : 3 17 53 80 83 88 90 90 90
COMPILE              : 89
CTF                  : 
CTI                  : 
DIFF                 : 27
DIV                  : 33
DOT                  : 89 90 93 96
ELSE                 : 62
EPOCHS               : 90
EQUAL                : 26 49 78 81 85 85 86 90 90 90 93
FALSE                : 92
FIT                  : 90
FLOAT                : 6 36 95
FOR                  : 66
FUNCESP              : 
FUNCTION             : 7 8
GETWEIGHTS           : 96
GT                   : 25
GTE                  : 
ID                   : 1 3 4 7 8 16 17 54 55 56 57 78 81 85 86 90 93
IF                   : 60
INT                  : 5 35 85 90 94
LAYERS               : 85
LBRACE               : 9
LBRACKET             : 55 56 56 66 86 93
LPAREN               : 7 8 34 51 57 60 63 66 78 81 84 85 86 89 90 93 96
LT                   : 24
LTE                  : 
MATRIX               : 81
MEAN                 : 84
MINUS                : 30
MULT                 : 32
NUMPY                : 
OR                   : 19
PLUS                 : 29
PREDICT              : 93
PRINT                : 51
PROGRAM              : 1
QUOTE                : 
RBRACE               : 9
RBRACKET             : 55 56 56 67 87 94 95
READ                 : 50
RPAREN               : 7 8 34 52 57 60 63 66 79 80 82 83 84 85 87 89 91 92 94 95 96
SEMICOLON            : 1 2 58 64 66 66
SEQUENTIAL           : 86
STRING               : 
TRUE                 : 91
UNITS                : 85
VAR                  : 2
VERBOSE              : 90
VOID                 : 8
WHILE                : 63
error                : 

Nonterminals, with rules where they appear

array                : 69 81 83 84 90 90
arrayp               : 78
assign               : 39
body                 : 7 8
bodyp                : 9 10 11
call                 : 38 42
callp                : 57 58
compile              : 74
decvar               : 1 10 12
decvarp              : 2 3
empty                : 
exp                  : 19 34 49 52 53 55 56 56 58 59 60 63 66 66
f                    : 31 32 33
fit                  : 75
fitp                 : 90
for                  : 47
forp                 : 66 68
funcesp              : 48
function             : 40
getweights           : 77
gexp                 : 20 21
gexpp                : 23
if                   : 45
ifp                  : 60
layers               : 72 86 88 96
matrix               : 70
matrixp              : 81
mean                 : 71
mexp                 : 22 23 23 29 30
param                : 7 8 17
paramp               : 15
predict              : 76
predictp             : 93
print                : 44
printp               : 51 53
program              : 0
read                 : 43
sequential           : 73 89 90 93
sequentialp          : 86 88
statements           : 10 11 60 62 63 65 66 68
t                    : 28 29 30 32 33
texp                 : 18 19 21
type                 : 2 7 15
var                  : 37 49 50 66 78 80
voidfunction         : 41
while                : 46
whilep               : 63 65

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . PROGRAM ID SEMICOLON decvar

    PROGRAM         shift and go to state 2

    program                        shift and go to state 1

state 1

    (0) S' -> program .



state 2

    (1) program -> PROGRAM . ID SEMICOLON decvar

    ID              shift and go to state 3


state 3

    (1) program -> PROGRAM ID . SEMICOLON decvar

    SEMICOLON       shift and go to state 4


state 4

    (1) program -> PROGRAM ID SEMICOLON . decvar
    (2) decvar -> . VAR type decvarp SEMICOLON

    VAR             shift and go to state 6

    decvar                         shift and go to state 5

state 5

    (1) program -> PROGRAM ID SEMICOLON decvar .

    $end            reduce using rule 1 (program -> PROGRAM ID SEMICOLON decvar .)


state 6

    (2) decvar -> VAR . type decvarp SEMICOLON
    (5) type -> . INT
    (6) type -> . FLOAT

    INT             shift and go to state 8
    FLOAT           shift and go to state 9

    type                           shift and go to state 7

state 7

    (2) decvar -> VAR type . decvarp SEMICOLON
    (3) decvarp -> . ID COMMA decvarp
    (4) decvarp -> . ID

    ID              shift and go to state 11

    decvarp                        shift and go to state 10

state 8

    (5) type -> INT .

    ID              reduce using rule 5 (type -> INT .)


state 9

    (6) type -> FLOAT .

    ID              reduce using rule 6 (type -> FLOAT .)


state 10

    (2) decvar -> VAR type decvarp . SEMICOLON

    SEMICOLON       shift and go to state 12


state 11

    (3) decvarp -> ID . COMMA decvarp
    (4) decvarp -> ID .

    COMMA           shift and go to state 13
    SEMICOLON       reduce using rule 4 (decvarp -> ID .)


state 12

    (2) decvar -> VAR type decvarp SEMICOLON .

    $end            reduce using rule 2 (decvar -> VAR type decvarp SEMICOLON .)


state 13

    (3) decvarp -> ID COMMA . decvarp
    (3) decvarp -> . ID COMMA decvarp
    (4) decvarp -> . ID

    ID              shift and go to state 11

    decvarp                        shift and go to state 14

state 14

    (3) decvarp -> ID COMMA decvarp .

    SEMICOLON       reduce using rule 3 (decvarp -> ID COMMA decvarp .)

