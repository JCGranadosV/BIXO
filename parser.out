Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    ASSIGN
    CHAR
    COLON
    END
    FUNCESP
    GTE
    LTE
    NUMPY
    QUOTE
    STRING

Grammar

Rule 0     S' -> program
Rule 1     program -> PROGRAM ID SEMICOLON decvar modules
Rule 2     decvar -> VAR decvarp
Rule 3     decvar -> VAR decvarp decvar
Rule 4     decvar -> <empty>
Rule 5     decvarp -> type decvarpp SEMICOLON
Rule 6     decvarpp -> ID COMMA decvarpp
Rule 7     decvarpp -> ID
Rule 8     type -> INT
Rule 9     type -> FLOAT
Rule 10    function -> FUNCTION type decfunc LPAREN param RPAREN LBRACE body RBRACE
Rule 11    decfunc -> ID
Rule 12    voidfunction -> FUNCTION VOID decfunc LPAREN param RPAREN LBRACE body RBRACE
Rule 13    mainfunction -> MAIN
Rule 14    modules -> function modules
Rule 15    modules -> voidfunction modules
Rule 16    modules -> function
Rule 17    modules -> voidfunction
Rule 18    body -> decvar statements body
Rule 19    body -> statements body
Rule 20    body -> decvar
Rule 21    body -> <empty>
Rule 22    param -> type ID
Rule 23    param -> type ID COMMA param
Rule 24    param -> <empty>
Rule 25    exp -> texp
Rule 26    exp -> texp OR exp
Rule 27    texp -> gexp
Rule 28    texp -> gexp AND texp
Rule 29    gexp -> mexp
Rule 30    gexp -> mexp gexpp mexp
Rule 31    gexpp -> LT
Rule 32    gexpp -> GT
Rule 33    gexpp -> EQUAL
Rule 34    gexpp -> DIFF
Rule 35    mexp -> t
Rule 36    mexp -> t PLUS mexp
Rule 37    mexp -> t MINUS mexp
Rule 38    t -> f
Rule 39    t -> f MULT t
Rule 40    t -> f DIV t
Rule 41    f -> LPAREN exp RPAREN
Rule 42    f -> CTI
Rule 43    f -> CTF
Rule 44    f -> var
Rule 45    f -> call
Rule 46    statements -> assign
Rule 47    statements -> function
Rule 48    statements -> voidfunction
Rule 49    statements -> call
Rule 50    statements -> read
Rule 51    statements -> print
Rule 52    statements -> if
Rule 53    statements -> while
Rule 54    statements -> for
Rule 55    statements -> funcesp
Rule 56    statements -> <empty>
Rule 57    assign -> var EQUAL exp SEMICOLON
Rule 58    read -> READ var
Rule 59    print -> PRINT LPAREN printp
Rule 60    printp -> exp RPAREN
Rule 61    printp -> exp COMMA printp
Rule 62    var -> ID
Rule 63    call -> ID LPAREN callp RPAREN
Rule 64    callp -> exp SEMICOLON callp
Rule 65    callp -> exp
Rule 66    if -> IF LPAREN CTI GT CTI RPAREN quadsIf ifp jumpsIf
Rule 67    ifp -> <empty>
Rule 68    ifp -> ELSE quadsElse statements
Rule 69    quadsIf -> <empty>
Rule 70    jumpsIf -> <empty>
Rule 71    quadsElse -> <empty>
Rule 72    while -> WHILE LPAREN exp RPAREN statements whilep
Rule 73    whilep -> SEMICOLON
Rule 74    whilep -> statements whilep
Rule 75    for -> FOR LPAREN var SEMICOLON exp SEMICOLON exp RPAREN LBRACKET statements forp
Rule 76    forp -> RBRACKET
Rule 77    forp -> statements forp
Rule 78    funcesp -> array
Rule 79    funcesp -> matrix
Rule 80    funcesp -> mean
Rule 81    funcesp -> layers
Rule 82    funcesp -> sequential
Rule 83    funcesp -> compile
Rule 84    funcesp -> fit
Rule 85    funcesp -> predict
Rule 86    funcesp -> getweights
Rule 87    array -> ID EQUAL ARRAY LPAREN var arrayp
Rule 88    arrayp -> RPAREN
Rule 89    arrayp -> COMMA var RPAREN
Rule 90    matrix -> ID EQUAL MATRIX LPAREN array matrixp
Rule 91    matrixp -> RPAREN
Rule 92    matrixp -> COMMA array RPAREN
Rule 93    mean -> MEAN LPAREN array RPAREN
Rule 94    layers -> ID EQUAL LAYERS LPAREN UNITS EQUAL INT RPAREN
Rule 95    sequential -> ID EQUAL SEQUENTIAL LPAREN LBRACKET layers sequentialp
Rule 96    sequentialp -> RBRACKET RPAREN
Rule 97    sequentialp -> COMMA layers sequentialp
Rule 98    compile -> sequential DOT COMPILE LPAREN RPAREN
Rule 99    fit -> ID EQUAL sequential DOT FIT LPAREN array COMMA array COMMA EPOCHS EQUAL INT COMMA VERBOSE EQUAL fitp
Rule 100   fitp -> TRUE RPAREN
Rule 101   fitp -> FALSE RPAREN
Rule 102   predict -> ID EQUAL sequential DOT PREDICT LPAREN LBRACKET predictp
Rule 103   predictp -> INT RBRACKET RPAREN
Rule 104   predictp -> FLOAT RBRACKET RPAREN
Rule 105   getweights -> layers DOT GETWEIGHTS LPAREN RPAREN
Rule 106   empty -> <empty>

Terminals, with rules where they appear

AND                  : 28
ARRAY                : 87
ASSIGN               : 
CHAR                 : 
COLON                : 
COMMA                : 6 23 61 89 92 97 99 99 99
COMPILE              : 98
CTF                  : 43
CTI                  : 42 66 66
DIFF                 : 34
DIV                  : 40
DOT                  : 98 99 102 105
ELSE                 : 68
END                  : 
EPOCHS               : 99
EQUAL                : 33 57 87 90 94 94 95 99 99 99 102
FALSE                : 101
FIT                  : 99
FLOAT                : 9 104
FOR                  : 75
FUNCESP              : 
FUNCTION             : 10 12
GETWEIGHTS           : 105
GT                   : 32 66
GTE                  : 
ID                   : 1 6 7 11 22 23 62 63 87 90 94 95 99 102
IF                   : 66
INT                  : 8 94 99 103
LAYERS               : 94
LBRACE               : 10 12
LBRACKET             : 75 95 102
LPAREN               : 10 12 41 59 63 66 72 75 87 90 93 94 95 98 99 102 105
LT                   : 31
LTE                  : 
MAIN                 : 13
MATRIX               : 90
MEAN                 : 93
MINUS                : 37
MULT                 : 39
NUMPY                : 
OR                   : 26
PLUS                 : 36
PREDICT              : 102
PRINT                : 59
PROGRAM              : 1
QUOTE                : 
RBRACE               : 10 12
RBRACKET             : 76 96 103 104
READ                 : 58
RPAREN               : 10 12 41 60 63 66 72 75 88 89 91 92 93 94 96 98 100 101 103 104 105
SEMICOLON            : 1 5 57 64 73 75 75
SEQUENTIAL           : 95
STRING               : 
TRUE                 : 100
UNITS                : 94
VAR                  : 2 3
VERBOSE              : 99
VOID                 : 12
WHILE                : 72
error                : 

Nonterminals, with rules where they appear

array                : 78 90 92 93 99 99
arrayp               : 87
assign               : 46
body                 : 10 12 18 19
call                 : 45 49
callp                : 63 64
compile              : 83
decfunc              : 10 12
decvar               : 1 3 18 20
decvarp              : 2 3
decvarpp             : 5 6
empty                : 
exp                  : 26 41 57 60 61 64 65 72 75 75
f                    : 38 39 40
fit                  : 84
fitp                 : 99
for                  : 54
forp                 : 75 77
funcesp              : 55
function             : 14 16 47
getweights           : 86
gexp                 : 27 28
gexpp                : 30
if                   : 52
ifp                  : 66
jumpsIf              : 66
layers               : 81 95 97 105
mainfunction         : 
matrix               : 79
matrixp              : 90
mean                 : 80
mexp                 : 29 30 30 36 37
modules              : 1 14 15
param                : 10 12 23
predict              : 85
predictp             : 102
print                : 51
printp               : 59 61
program              : 0
quadsElse            : 68
quadsIf              : 66
read                 : 50
sequential           : 82 98 99 102
sequentialp          : 95 97
statements           : 18 19 68 72 74 75 77
t                    : 35 36 37 39 40
texp                 : 25 26 28
type                 : 5 10 22 23
var                  : 44 57 58 75 87 89
voidfunction         : 15 17 48
while                : 53
whilep               : 72 74

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . PROGRAM ID SEMICOLON decvar modules

    PROGRAM         shift and go to state 2

    program                        shift and go to state 1

state 1

    (0) S' -> program .



state 2

    (1) program -> PROGRAM . ID SEMICOLON decvar modules

    ID              shift and go to state 3


state 3

    (1) program -> PROGRAM ID . SEMICOLON decvar modules

    SEMICOLON       shift and go to state 4


state 4

    (1) program -> PROGRAM ID SEMICOLON . decvar modules
    (2) decvar -> . VAR decvarp
    (3) decvar -> . VAR decvarp decvar
    (4) decvar -> .

    VAR             shift and go to state 6
    FUNCTION        reduce using rule 4 (decvar -> .)

    decvar                         shift and go to state 5

state 5

    (1) program -> PROGRAM ID SEMICOLON decvar . modules
    (14) modules -> . function modules
    (15) modules -> . voidfunction modules
    (16) modules -> . function
    (17) modules -> . voidfunction
    (10) function -> . FUNCTION type decfunc LPAREN param RPAREN LBRACE body RBRACE
    (12) voidfunction -> . FUNCTION VOID decfunc LPAREN param RPAREN LBRACE body RBRACE

    FUNCTION        shift and go to state 10

    modules                        shift and go to state 7
    function                       shift and go to state 8
    voidfunction                   shift and go to state 9

state 6

    (2) decvar -> VAR . decvarp
    (3) decvar -> VAR . decvarp decvar
    (5) decvarp -> . type decvarpp SEMICOLON
    (8) type -> . INT
    (9) type -> . FLOAT

    INT             shift and go to state 13
    FLOAT           shift and go to state 14

    decvarp                        shift and go to state 11
    type                           shift and go to state 12

state 7

    (1) program -> PROGRAM ID SEMICOLON decvar modules .

    $end            reduce using rule 1 (program -> PROGRAM ID SEMICOLON decvar modules .)


state 8

    (14) modules -> function . modules
    (16) modules -> function .
    (14) modules -> . function modules
    (15) modules -> . voidfunction modules
    (16) modules -> . function
    (17) modules -> . voidfunction
    (10) function -> . FUNCTION type decfunc LPAREN param RPAREN LBRACE body RBRACE
    (12) voidfunction -> . FUNCTION VOID decfunc LPAREN param RPAREN LBRACE body RBRACE

    $end            reduce using rule 16 (modules -> function .)
    FUNCTION        shift and go to state 10

    function                       shift and go to state 8
    modules                        shift and go to state 15
    voidfunction                   shift and go to state 9

state 9

    (15) modules -> voidfunction . modules
    (17) modules -> voidfunction .
    (14) modules -> . function modules
    (15) modules -> . voidfunction modules
    (16) modules -> . function
    (17) modules -> . voidfunction
    (10) function -> . FUNCTION type decfunc LPAREN param RPAREN LBRACE body RBRACE
    (12) voidfunction -> . FUNCTION VOID decfunc LPAREN param RPAREN LBRACE body RBRACE

    $end            reduce using rule 17 (modules -> voidfunction .)
    FUNCTION        shift and go to state 10

    voidfunction                   shift and go to state 9
    modules                        shift and go to state 16
    function                       shift and go to state 8

state 10

    (10) function -> FUNCTION . type decfunc LPAREN param RPAREN LBRACE body RBRACE
    (12) voidfunction -> FUNCTION . VOID decfunc LPAREN param RPAREN LBRACE body RBRACE
    (8) type -> . INT
    (9) type -> . FLOAT

    VOID            shift and go to state 18
    INT             shift and go to state 13
    FLOAT           shift and go to state 14

    type                           shift and go to state 17

state 11

    (2) decvar -> VAR decvarp .
    (3) decvar -> VAR decvarp . decvar
    (2) decvar -> . VAR decvarp
    (3) decvar -> . VAR decvarp decvar
    (4) decvar -> .

  ! shift/reduce conflict for VAR resolved as shift
  ! reduce/reduce conflict for FUNCTION resolved using rule 2 (decvar -> VAR decvarp .)
  ! reduce/reduce conflict for ID resolved using rule 2 (decvar -> VAR decvarp .)
  ! reduce/reduce conflict for READ resolved using rule 2 (decvar -> VAR decvarp .)
  ! reduce/reduce conflict for PRINT resolved using rule 2 (decvar -> VAR decvarp .)
  ! reduce/reduce conflict for IF resolved using rule 2 (decvar -> VAR decvarp .)
  ! reduce/reduce conflict for WHILE resolved using rule 2 (decvar -> VAR decvarp .)
  ! reduce/reduce conflict for FOR resolved using rule 2 (decvar -> VAR decvarp .)
  ! reduce/reduce conflict for MEAN resolved using rule 2 (decvar -> VAR decvarp .)
  ! shift/reduce conflict for VAR resolved as shift
  ! reduce/reduce conflict for RBRACE resolved using rule 2 (decvar -> VAR decvarp .)
    FUNCTION        reduce using rule 2 (decvar -> VAR decvarp .)
    ID              reduce using rule 2 (decvar -> VAR decvarp .)
    READ            reduce using rule 2 (decvar -> VAR decvarp .)
    PRINT           reduce using rule 2 (decvar -> VAR decvarp .)
    IF              reduce using rule 2 (decvar -> VAR decvarp .)
    WHILE           reduce using rule 2 (decvar -> VAR decvarp .)
    FOR             reduce using rule 2 (decvar -> VAR decvarp .)
    MEAN            reduce using rule 2 (decvar -> VAR decvarp .)
    RBRACE          reduce using rule 2 (decvar -> VAR decvarp .)
    VAR             shift and go to state 6

  ! VAR             [ reduce using rule 2 (decvar -> VAR decvarp .) ]
  ! FUNCTION        [ reduce using rule 4 (decvar -> .) ]
  ! ID              [ reduce using rule 4 (decvar -> .) ]
  ! READ            [ reduce using rule 4 (decvar -> .) ]
  ! PRINT           [ reduce using rule 4 (decvar -> .) ]
  ! IF              [ reduce using rule 4 (decvar -> .) ]
  ! WHILE           [ reduce using rule 4 (decvar -> .) ]
  ! FOR             [ reduce using rule 4 (decvar -> .) ]
  ! MEAN            [ reduce using rule 4 (decvar -> .) ]
  ! VAR             [ reduce using rule 4 (decvar -> .) ]
  ! RBRACE          [ reduce using rule 4 (decvar -> .) ]

    decvar                         shift and go to state 19

state 12

    (5) decvarp -> type . decvarpp SEMICOLON
    (6) decvarpp -> . ID COMMA decvarpp
    (7) decvarpp -> . ID

    ID              shift and go to state 21

    decvarpp                       shift and go to state 20

state 13

    (8) type -> INT .

    ID              reduce using rule 8 (type -> INT .)


state 14

    (9) type -> FLOAT .

    ID              reduce using rule 9 (type -> FLOAT .)


state 15

    (14) modules -> function modules .

    $end            reduce using rule 14 (modules -> function modules .)


state 16

    (15) modules -> voidfunction modules .

    $end            reduce using rule 15 (modules -> voidfunction modules .)


state 17

    (10) function -> FUNCTION type . decfunc LPAREN param RPAREN LBRACE body RBRACE
    (11) decfunc -> . ID

    ID              shift and go to state 23

    decfunc                        shift and go to state 22

state 18

    (12) voidfunction -> FUNCTION VOID . decfunc LPAREN param RPAREN LBRACE body RBRACE
    (11) decfunc -> . ID

    ID              shift and go to state 23

    decfunc                        shift and go to state 24

state 19

    (3) decvar -> VAR decvarp decvar .

    FUNCTION        reduce using rule 3 (decvar -> VAR decvarp decvar .)
    ID              reduce using rule 3 (decvar -> VAR decvarp decvar .)
    READ            reduce using rule 3 (decvar -> VAR decvarp decvar .)
    PRINT           reduce using rule 3 (decvar -> VAR decvarp decvar .)
    IF              reduce using rule 3 (decvar -> VAR decvarp decvar .)
    WHILE           reduce using rule 3 (decvar -> VAR decvarp decvar .)
    FOR             reduce using rule 3 (decvar -> VAR decvarp decvar .)
    MEAN            reduce using rule 3 (decvar -> VAR decvarp decvar .)
    VAR             reduce using rule 3 (decvar -> VAR decvarp decvar .)
    RBRACE          reduce using rule 3 (decvar -> VAR decvarp decvar .)


state 20

    (5) decvarp -> type decvarpp . SEMICOLON

    SEMICOLON       shift and go to state 25


state 21

    (6) decvarpp -> ID . COMMA decvarpp
    (7) decvarpp -> ID .

    COMMA           shift and go to state 26
    SEMICOLON       reduce using rule 7 (decvarpp -> ID .)


state 22

    (10) function -> FUNCTION type decfunc . LPAREN param RPAREN LBRACE body RBRACE

    LPAREN          shift and go to state 27


state 23

    (11) decfunc -> ID .

    LPAREN          reduce using rule 11 (decfunc -> ID .)


state 24

    (12) voidfunction -> FUNCTION VOID decfunc . LPAREN param RPAREN LBRACE body RBRACE

    LPAREN          shift and go to state 28


state 25

    (5) decvarp -> type decvarpp SEMICOLON .

    VAR             reduce using rule 5 (decvarp -> type decvarpp SEMICOLON .)
    FUNCTION        reduce using rule 5 (decvarp -> type decvarpp SEMICOLON .)
    ID              reduce using rule 5 (decvarp -> type decvarpp SEMICOLON .)
    READ            reduce using rule 5 (decvarp -> type decvarpp SEMICOLON .)
    PRINT           reduce using rule 5 (decvarp -> type decvarpp SEMICOLON .)
    IF              reduce using rule 5 (decvarp -> type decvarpp SEMICOLON .)
    WHILE           reduce using rule 5 (decvarp -> type decvarpp SEMICOLON .)
    FOR             reduce using rule 5 (decvarp -> type decvarpp SEMICOLON .)
    MEAN            reduce using rule 5 (decvarp -> type decvarpp SEMICOLON .)
    RBRACE          reduce using rule 5 (decvarp -> type decvarpp SEMICOLON .)


state 26

    (6) decvarpp -> ID COMMA . decvarpp
    (6) decvarpp -> . ID COMMA decvarpp
    (7) decvarpp -> . ID

    ID              shift and go to state 21

    decvarpp                       shift and go to state 29

state 27

    (10) function -> FUNCTION type decfunc LPAREN . param RPAREN LBRACE body RBRACE
    (22) param -> . type ID
    (23) param -> . type ID COMMA param
    (24) param -> .
    (8) type -> . INT
    (9) type -> . FLOAT

    RPAREN          reduce using rule 24 (param -> .)
    INT             shift and go to state 13
    FLOAT           shift and go to state 14

    type                           shift and go to state 30
    param                          shift and go to state 31

state 28

    (12) voidfunction -> FUNCTION VOID decfunc LPAREN . param RPAREN LBRACE body RBRACE
    (22) param -> . type ID
    (23) param -> . type ID COMMA param
    (24) param -> .
    (8) type -> . INT
    (9) type -> . FLOAT

    RPAREN          reduce using rule 24 (param -> .)
    INT             shift and go to state 13
    FLOAT           shift and go to state 14

    param                          shift and go to state 32
    type                           shift and go to state 30

state 29

    (6) decvarpp -> ID COMMA decvarpp .

    SEMICOLON       reduce using rule 6 (decvarpp -> ID COMMA decvarpp .)


state 30

    (22) param -> type . ID
    (23) param -> type . ID COMMA param

    ID              shift and go to state 33


state 31

    (10) function -> FUNCTION type decfunc LPAREN param . RPAREN LBRACE body RBRACE

    RPAREN          shift and go to state 34


state 32

    (12) voidfunction -> FUNCTION VOID decfunc LPAREN param . RPAREN LBRACE body RBRACE

    RPAREN          shift and go to state 35


state 33

    (22) param -> type ID .
    (23) param -> type ID . COMMA param

    RPAREN          reduce using rule 22 (param -> type ID .)
    COMMA           shift and go to state 36


state 34

    (10) function -> FUNCTION type decfunc LPAREN param RPAREN . LBRACE body RBRACE

    LBRACE          shift and go to state 37


state 35

    (12) voidfunction -> FUNCTION VOID decfunc LPAREN param RPAREN . LBRACE body RBRACE

    LBRACE          shift and go to state 38


state 36

    (23) param -> type ID COMMA . param
    (22) param -> . type ID
    (23) param -> . type ID COMMA param
    (24) param -> .
    (8) type -> . INT
    (9) type -> . FLOAT

    RPAREN          reduce using rule 24 (param -> .)
    INT             shift and go to state 13
    FLOAT           shift and go to state 14

    type                           shift and go to state 30
    param                          shift and go to state 39

state 37

    (10) function -> FUNCTION type decfunc LPAREN param RPAREN LBRACE . body RBRACE
    (18) body -> . decvar statements body
    (19) body -> . statements body
    (20) body -> . decvar
    (21) body -> .
    (2) decvar -> . VAR decvarp
    (3) decvar -> . VAR decvarp decvar
    (4) decvar -> .
    (46) statements -> . assign
    (47) statements -> . function
    (48) statements -> . voidfunction
    (49) statements -> . call
    (50) statements -> . read
    (51) statements -> . print
    (52) statements -> . if
    (53) statements -> . while
    (54) statements -> . for
    (55) statements -> . funcesp
    (56) statements -> .
    (57) assign -> . var EQUAL exp SEMICOLON
    (10) function -> . FUNCTION type decfunc LPAREN param RPAREN LBRACE body RBRACE
    (12) voidfunction -> . FUNCTION VOID decfunc LPAREN param RPAREN LBRACE body RBRACE
    (63) call -> . ID LPAREN callp RPAREN
    (58) read -> . READ var
    (59) print -> . PRINT LPAREN printp
    (66) if -> . IF LPAREN CTI GT CTI RPAREN quadsIf ifp jumpsIf
    (72) while -> . WHILE LPAREN exp RPAREN statements whilep
    (75) for -> . FOR LPAREN var SEMICOLON exp SEMICOLON exp RPAREN LBRACKET statements forp
    (78) funcesp -> . array
    (79) funcesp -> . matrix
    (80) funcesp -> . mean
    (81) funcesp -> . layers
    (82) funcesp -> . sequential
    (83) funcesp -> . compile
    (84) funcesp -> . fit
    (85) funcesp -> . predict
    (86) funcesp -> . getweights
    (62) var -> . ID
    (87) array -> . ID EQUAL ARRAY LPAREN var arrayp
    (90) matrix -> . ID EQUAL MATRIX LPAREN array matrixp
    (93) mean -> . MEAN LPAREN array RPAREN
    (94) layers -> . ID EQUAL LAYERS LPAREN UNITS EQUAL INT RPAREN
    (95) sequential -> . ID EQUAL SEQUENTIAL LPAREN LBRACKET layers sequentialp
    (98) compile -> . sequential DOT COMPILE LPAREN RPAREN
    (99) fit -> . ID EQUAL sequential DOT FIT LPAREN array COMMA array COMMA EPOCHS EQUAL INT COMMA VERBOSE EQUAL fitp
    (102) predict -> . ID EQUAL sequential DOT PREDICT LPAREN LBRACKET predictp
    (105) getweights -> . layers DOT GETWEIGHTS LPAREN RPAREN

  ! shift/reduce conflict for VAR resolved as shift
  ! reduce/reduce conflict for RBRACE resolved using rule 4 (decvar -> .)
  ! shift/reduce conflict for VAR resolved as shift
  ! reduce/reduce conflict for FUNCTION resolved using rule 4 (decvar -> .)
  ! reduce/reduce conflict for ID resolved using rule 4 (decvar -> .)
  ! reduce/reduce conflict for READ resolved using rule 4 (decvar -> .)
  ! reduce/reduce conflict for PRINT resolved using rule 4 (decvar -> .)
  ! reduce/reduce conflict for IF resolved using rule 4 (decvar -> .)
  ! reduce/reduce conflict for WHILE resolved using rule 4 (decvar -> .)
  ! reduce/reduce conflict for FOR resolved using rule 4 (decvar -> .)
  ! reduce/reduce conflict for MEAN resolved using rule 4 (decvar -> .)
  ! reduce/reduce conflict for RBRACE resolved using rule 4 (decvar -> .)
  ! shift/reduce conflict for FUNCTION resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for READ resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for MEAN resolved as shift
    VAR             shift and go to state 6
    RBRACE          reduce using rule 4 (decvar -> .)
    FUNCTION        shift and go to state 10
    ID              shift and go to state 54
    READ            shift and go to state 55
    PRINT           shift and go to state 56
    IF              shift and go to state 57
    WHILE           shift and go to state 58
    FOR             shift and go to state 59
    MEAN            shift and go to state 69

  ! RBRACE          [ reduce using rule 21 (body -> .) ]
  ! FUNCTION        [ reduce using rule 4 (decvar -> .) ]
  ! ID              [ reduce using rule 4 (decvar -> .) ]
  ! READ            [ reduce using rule 4 (decvar -> .) ]
  ! PRINT           [ reduce using rule 4 (decvar -> .) ]
  ! IF              [ reduce using rule 4 (decvar -> .) ]
  ! WHILE           [ reduce using rule 4 (decvar -> .) ]
  ! FOR             [ reduce using rule 4 (decvar -> .) ]
  ! MEAN            [ reduce using rule 4 (decvar -> .) ]
  ! VAR             [ reduce using rule 4 (decvar -> .) ]
  ! VAR             [ reduce using rule 56 (statements -> .) ]
  ! FUNCTION        [ reduce using rule 56 (statements -> .) ]
  ! ID              [ reduce using rule 56 (statements -> .) ]
  ! READ            [ reduce using rule 56 (statements -> .) ]
  ! PRINT           [ reduce using rule 56 (statements -> .) ]
  ! IF              [ reduce using rule 56 (statements -> .) ]
  ! WHILE           [ reduce using rule 56 (statements -> .) ]
  ! FOR             [ reduce using rule 56 (statements -> .) ]
  ! MEAN            [ reduce using rule 56 (statements -> .) ]
  ! RBRACE          [ reduce using rule 56 (statements -> .) ]

    body                           shift and go to state 40
    decvar                         shift and go to state 41
    statements                     shift and go to state 42
    assign                         shift and go to state 43
    function                       shift and go to state 44
    voidfunction                   shift and go to state 45
    call                           shift and go to state 46
    read                           shift and go to state 47
    print                          shift and go to state 48
    if                             shift and go to state 49
    while                          shift and go to state 50
    for                            shift and go to state 51
    funcesp                        shift and go to state 52
    var                            shift and go to state 53
    array                          shift and go to state 60
    matrix                         shift and go to state 61
    mean                           shift and go to state 62
    layers                         shift and go to state 63
    sequential                     shift and go to state 64
    compile                        shift and go to state 65
    fit                            shift and go to state 66
    predict                        shift and go to state 67
    getweights                     shift and go to state 68

state 38

    (12) voidfunction -> FUNCTION VOID decfunc LPAREN param RPAREN LBRACE . body RBRACE
    (18) body -> . decvar statements body
    (19) body -> . statements body
    (20) body -> . decvar
    (21) body -> .
    (2) decvar -> . VAR decvarp
    (3) decvar -> . VAR decvarp decvar
    (4) decvar -> .
    (46) statements -> . assign
    (47) statements -> . function
    (48) statements -> . voidfunction
    (49) statements -> . call
    (50) statements -> . read
    (51) statements -> . print
    (52) statements -> . if
    (53) statements -> . while
    (54) statements -> . for
    (55) statements -> . funcesp
    (56) statements -> .
    (57) assign -> . var EQUAL exp SEMICOLON
    (10) function -> . FUNCTION type decfunc LPAREN param RPAREN LBRACE body RBRACE
    (12) voidfunction -> . FUNCTION VOID decfunc LPAREN param RPAREN LBRACE body RBRACE
    (63) call -> . ID LPAREN callp RPAREN
    (58) read -> . READ var
    (59) print -> . PRINT LPAREN printp
    (66) if -> . IF LPAREN CTI GT CTI RPAREN quadsIf ifp jumpsIf
    (72) while -> . WHILE LPAREN exp RPAREN statements whilep
    (75) for -> . FOR LPAREN var SEMICOLON exp SEMICOLON exp RPAREN LBRACKET statements forp
    (78) funcesp -> . array
    (79) funcesp -> . matrix
    (80) funcesp -> . mean
    (81) funcesp -> . layers
    (82) funcesp -> . sequential
    (83) funcesp -> . compile
    (84) funcesp -> . fit
    (85) funcesp -> . predict
    (86) funcesp -> . getweights
    (62) var -> . ID
    (87) array -> . ID EQUAL ARRAY LPAREN var arrayp
    (90) matrix -> . ID EQUAL MATRIX LPAREN array matrixp
    (93) mean -> . MEAN LPAREN array RPAREN
    (94) layers -> . ID EQUAL LAYERS LPAREN UNITS EQUAL INT RPAREN
    (95) sequential -> . ID EQUAL SEQUENTIAL LPAREN LBRACKET layers sequentialp
    (98) compile -> . sequential DOT COMPILE LPAREN RPAREN
    (99) fit -> . ID EQUAL sequential DOT FIT LPAREN array COMMA array COMMA EPOCHS EQUAL INT COMMA VERBOSE EQUAL fitp
    (102) predict -> . ID EQUAL sequential DOT PREDICT LPAREN LBRACKET predictp
    (105) getweights -> . layers DOT GETWEIGHTS LPAREN RPAREN

  ! shift/reduce conflict for VAR resolved as shift
  ! reduce/reduce conflict for RBRACE resolved using rule 4 (decvar -> .)
  ! shift/reduce conflict for VAR resolved as shift
  ! reduce/reduce conflict for FUNCTION resolved using rule 4 (decvar -> .)
  ! reduce/reduce conflict for ID resolved using rule 4 (decvar -> .)
  ! reduce/reduce conflict for READ resolved using rule 4 (decvar -> .)
  ! reduce/reduce conflict for PRINT resolved using rule 4 (decvar -> .)
  ! reduce/reduce conflict for IF resolved using rule 4 (decvar -> .)
  ! reduce/reduce conflict for WHILE resolved using rule 4 (decvar -> .)
  ! reduce/reduce conflict for FOR resolved using rule 4 (decvar -> .)
  ! reduce/reduce conflict for MEAN resolved using rule 4 (decvar -> .)
  ! reduce/reduce conflict for RBRACE resolved using rule 4 (decvar -> .)
  ! shift/reduce conflict for FUNCTION resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for READ resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for MEAN resolved as shift
    VAR             shift and go to state 6
    RBRACE          reduce using rule 4 (decvar -> .)
    FUNCTION        shift and go to state 10
    ID              shift and go to state 54
    READ            shift and go to state 55
    PRINT           shift and go to state 56
    IF              shift and go to state 57
    WHILE           shift and go to state 58
    FOR             shift and go to state 59
    MEAN            shift and go to state 69

  ! RBRACE          [ reduce using rule 21 (body -> .) ]
  ! FUNCTION        [ reduce using rule 4 (decvar -> .) ]
  ! ID              [ reduce using rule 4 (decvar -> .) ]
  ! READ            [ reduce using rule 4 (decvar -> .) ]
  ! PRINT           [ reduce using rule 4 (decvar -> .) ]
  ! IF              [ reduce using rule 4 (decvar -> .) ]
  ! WHILE           [ reduce using rule 4 (decvar -> .) ]
  ! FOR             [ reduce using rule 4 (decvar -> .) ]
  ! MEAN            [ reduce using rule 4 (decvar -> .) ]
  ! VAR             [ reduce using rule 4 (decvar -> .) ]
  ! VAR             [ reduce using rule 56 (statements -> .) ]
  ! FUNCTION        [ reduce using rule 56 (statements -> .) ]
  ! ID              [ reduce using rule 56 (statements -> .) ]
  ! READ            [ reduce using rule 56 (statements -> .) ]
  ! PRINT           [ reduce using rule 56 (statements -> .) ]
  ! IF              [ reduce using rule 56 (statements -> .) ]
  ! WHILE           [ reduce using rule 56 (statements -> .) ]
  ! FOR             [ reduce using rule 56 (statements -> .) ]
  ! MEAN            [ reduce using rule 56 (statements -> .) ]
  ! RBRACE          [ reduce using rule 56 (statements -> .) ]

    body                           shift and go to state 70
    decvar                         shift and go to state 41
    statements                     shift and go to state 42
    assign                         shift and go to state 43
    function                       shift and go to state 44
    voidfunction                   shift and go to state 45
    call                           shift and go to state 46
    read                           shift and go to state 47
    print                          shift and go to state 48
    if                             shift and go to state 49
    while                          shift and go to state 50
    for                            shift and go to state 51
    funcesp                        shift and go to state 52
    var                            shift and go to state 53
    array                          shift and go to state 60
    matrix                         shift and go to state 61
    mean                           shift and go to state 62
    layers                         shift and go to state 63
    sequential                     shift and go to state 64
    compile                        shift and go to state 65
    fit                            shift and go to state 66
    predict                        shift and go to state 67
    getweights                     shift and go to state 68

state 39

    (23) param -> type ID COMMA param .

    RPAREN          reduce using rule 23 (param -> type ID COMMA param .)


state 40

    (10) function -> FUNCTION type decfunc LPAREN param RPAREN LBRACE body . RBRACE

    RBRACE          shift and go to state 71


state 41

    (18) body -> decvar . statements body
    (20) body -> decvar .
    (46) statements -> . assign
    (47) statements -> . function
    (48) statements -> . voidfunction
    (49) statements -> . call
    (50) statements -> . read
    (51) statements -> . print
    (52) statements -> . if
    (53) statements -> . while
    (54) statements -> . for
    (55) statements -> . funcesp
    (56) statements -> .
    (57) assign -> . var EQUAL exp SEMICOLON
    (10) function -> . FUNCTION type decfunc LPAREN param RPAREN LBRACE body RBRACE
    (12) voidfunction -> . FUNCTION VOID decfunc LPAREN param RPAREN LBRACE body RBRACE
    (63) call -> . ID LPAREN callp RPAREN
    (58) read -> . READ var
    (59) print -> . PRINT LPAREN printp
    (66) if -> . IF LPAREN CTI GT CTI RPAREN quadsIf ifp jumpsIf
    (72) while -> . WHILE LPAREN exp RPAREN statements whilep
    (75) for -> . FOR LPAREN var SEMICOLON exp SEMICOLON exp RPAREN LBRACKET statements forp
    (78) funcesp -> . array
    (79) funcesp -> . matrix
    (80) funcesp -> . mean
    (81) funcesp -> . layers
    (82) funcesp -> . sequential
    (83) funcesp -> . compile
    (84) funcesp -> . fit
    (85) funcesp -> . predict
    (86) funcesp -> . getweights
    (62) var -> . ID
    (87) array -> . ID EQUAL ARRAY LPAREN var arrayp
    (90) matrix -> . ID EQUAL MATRIX LPAREN array matrixp
    (93) mean -> . MEAN LPAREN array RPAREN
    (94) layers -> . ID EQUAL LAYERS LPAREN UNITS EQUAL INT RPAREN
    (95) sequential -> . ID EQUAL SEQUENTIAL LPAREN LBRACKET layers sequentialp
    (98) compile -> . sequential DOT COMPILE LPAREN RPAREN
    (99) fit -> . ID EQUAL sequential DOT FIT LPAREN array COMMA array COMMA EPOCHS EQUAL INT COMMA VERBOSE EQUAL fitp
    (102) predict -> . ID EQUAL sequential DOT PREDICT LPAREN LBRACKET predictp
    (105) getweights -> . layers DOT GETWEIGHTS LPAREN RPAREN

  ! reduce/reduce conflict for RBRACE resolved using rule 20 (body -> decvar .)
  ! shift/reduce conflict for FUNCTION resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for READ resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for MEAN resolved as shift
    RBRACE          reduce using rule 20 (body -> decvar .)
    VAR             reduce using rule 56 (statements -> .)
    FUNCTION        shift and go to state 10
    ID              shift and go to state 54
    READ            shift and go to state 55
    PRINT           shift and go to state 56
    IF              shift and go to state 57
    WHILE           shift and go to state 58
    FOR             shift and go to state 59
    MEAN            shift and go to state 69

  ! FUNCTION        [ reduce using rule 56 (statements -> .) ]
  ! ID              [ reduce using rule 56 (statements -> .) ]
  ! READ            [ reduce using rule 56 (statements -> .) ]
  ! PRINT           [ reduce using rule 56 (statements -> .) ]
  ! IF              [ reduce using rule 56 (statements -> .) ]
  ! WHILE           [ reduce using rule 56 (statements -> .) ]
  ! FOR             [ reduce using rule 56 (statements -> .) ]
  ! MEAN            [ reduce using rule 56 (statements -> .) ]
  ! RBRACE          [ reduce using rule 56 (statements -> .) ]

    statements                     shift and go to state 72
    assign                         shift and go to state 43
    function                       shift and go to state 44
    voidfunction                   shift and go to state 45
    call                           shift and go to state 46
    read                           shift and go to state 47
    print                          shift and go to state 48
    if                             shift and go to state 49
    while                          shift and go to state 50
    for                            shift and go to state 51
    funcesp                        shift and go to state 52
    var                            shift and go to state 53
    array                          shift and go to state 60
    matrix                         shift and go to state 61
    mean                           shift and go to state 62
    layers                         shift and go to state 63
    sequential                     shift and go to state 64
    compile                        shift and go to state 65
    fit                            shift and go to state 66
    predict                        shift and go to state 67
    getweights                     shift and go to state 68

state 42

    (19) body -> statements . body
    (18) body -> . decvar statements body
    (19) body -> . statements body
    (20) body -> . decvar
    (21) body -> .
    (2) decvar -> . VAR decvarp
    (3) decvar -> . VAR decvarp decvar
    (4) decvar -> .
    (46) statements -> . assign
    (47) statements -> . function
    (48) statements -> . voidfunction
    (49) statements -> . call
    (50) statements -> . read
    (51) statements -> . print
    (52) statements -> . if
    (53) statements -> . while
    (54) statements -> . for
    (55) statements -> . funcesp
    (56) statements -> .
    (57) assign -> . var EQUAL exp SEMICOLON
    (10) function -> . FUNCTION type decfunc LPAREN param RPAREN LBRACE body RBRACE
    (12) voidfunction -> . FUNCTION VOID decfunc LPAREN param RPAREN LBRACE body RBRACE
    (63) call -> . ID LPAREN callp RPAREN
    (58) read -> . READ var
    (59) print -> . PRINT LPAREN printp
    (66) if -> . IF LPAREN CTI GT CTI RPAREN quadsIf ifp jumpsIf
    (72) while -> . WHILE LPAREN exp RPAREN statements whilep
    (75) for -> . FOR LPAREN var SEMICOLON exp SEMICOLON exp RPAREN LBRACKET statements forp
    (78) funcesp -> . array
    (79) funcesp -> . matrix
    (80) funcesp -> . mean
    (81) funcesp -> . layers
    (82) funcesp -> . sequential
    (83) funcesp -> . compile
    (84) funcesp -> . fit
    (85) funcesp -> . predict
    (86) funcesp -> . getweights
    (62) var -> . ID
    (87) array -> . ID EQUAL ARRAY LPAREN var arrayp
    (90) matrix -> . ID EQUAL MATRIX LPAREN array matrixp
    (93) mean -> . MEAN LPAREN array RPAREN
    (94) layers -> . ID EQUAL LAYERS LPAREN UNITS EQUAL INT RPAREN
    (95) sequential -> . ID EQUAL SEQUENTIAL LPAREN LBRACKET layers sequentialp
    (98) compile -> . sequential DOT COMPILE LPAREN RPAREN
    (99) fit -> . ID EQUAL sequential DOT FIT LPAREN array COMMA array COMMA EPOCHS EQUAL INT COMMA VERBOSE EQUAL fitp
    (102) predict -> . ID EQUAL sequential DOT PREDICT LPAREN LBRACKET predictp
    (105) getweights -> . layers DOT GETWEIGHTS LPAREN RPAREN

  ! shift/reduce conflict for VAR resolved as shift
  ! reduce/reduce conflict for RBRACE resolved using rule 4 (decvar -> .)
  ! shift/reduce conflict for VAR resolved as shift
  ! reduce/reduce conflict for FUNCTION resolved using rule 4 (decvar -> .)
  ! reduce/reduce conflict for ID resolved using rule 4 (decvar -> .)
  ! reduce/reduce conflict for READ resolved using rule 4 (decvar -> .)
  ! reduce/reduce conflict for PRINT resolved using rule 4 (decvar -> .)
  ! reduce/reduce conflict for IF resolved using rule 4 (decvar -> .)
  ! reduce/reduce conflict for WHILE resolved using rule 4 (decvar -> .)
  ! reduce/reduce conflict for FOR resolved using rule 4 (decvar -> .)
  ! reduce/reduce conflict for MEAN resolved using rule 4 (decvar -> .)
  ! reduce/reduce conflict for RBRACE resolved using rule 4 (decvar -> .)
  ! shift/reduce conflict for FUNCTION resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for READ resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for MEAN resolved as shift
    VAR             shift and go to state 6
    RBRACE          reduce using rule 4 (decvar -> .)
    FUNCTION        shift and go to state 10
    ID              shift and go to state 54
    READ            shift and go to state 55
    PRINT           shift and go to state 56
    IF              shift and go to state 57
    WHILE           shift and go to state 58
    FOR             shift and go to state 59
    MEAN            shift and go to state 69

  ! RBRACE          [ reduce using rule 21 (body -> .) ]
  ! VAR             [ reduce using rule 4 (decvar -> .) ]
  ! FUNCTION        [ reduce using rule 4 (decvar -> .) ]
  ! ID              [ reduce using rule 4 (decvar -> .) ]
  ! READ            [ reduce using rule 4 (decvar -> .) ]
  ! PRINT           [ reduce using rule 4 (decvar -> .) ]
  ! IF              [ reduce using rule 4 (decvar -> .) ]
  ! WHILE           [ reduce using rule 4 (decvar -> .) ]
  ! FOR             [ reduce using rule 4 (decvar -> .) ]
  ! MEAN            [ reduce using rule 4 (decvar -> .) ]
  ! VAR             [ reduce using rule 56 (statements -> .) ]
  ! FUNCTION        [ reduce using rule 56 (statements -> .) ]
  ! ID              [ reduce using rule 56 (statements -> .) ]
  ! READ            [ reduce using rule 56 (statements -> .) ]
  ! PRINT           [ reduce using rule 56 (statements -> .) ]
  ! IF              [ reduce using rule 56 (statements -> .) ]
  ! WHILE           [ reduce using rule 56 (statements -> .) ]
  ! FOR             [ reduce using rule 56 (statements -> .) ]
  ! MEAN            [ reduce using rule 56 (statements -> .) ]
  ! RBRACE          [ reduce using rule 56 (statements -> .) ]

    statements                     shift and go to state 42
    body                           shift and go to state 73
    decvar                         shift and go to state 41
    assign                         shift and go to state 43
    function                       shift and go to state 44
    voidfunction                   shift and go to state 45
    call                           shift and go to state 46
    read                           shift and go to state 47
    print                          shift and go to state 48
    if                             shift and go to state 49
    while                          shift and go to state 50
    for                            shift and go to state 51
    funcesp                        shift and go to state 52
    var                            shift and go to state 53
    array                          shift and go to state 60
    matrix                         shift and go to state 61
    mean                           shift and go to state 62
    layers                         shift and go to state 63
    sequential                     shift and go to state 64
    compile                        shift and go to state 65
    fit                            shift and go to state 66
    predict                        shift and go to state 67
    getweights                     shift and go to state 68

state 43

    (46) statements -> assign .

    VAR             reduce using rule 46 (statements -> assign .)
    FUNCTION        reduce using rule 46 (statements -> assign .)
    ID              reduce using rule 46 (statements -> assign .)
    READ            reduce using rule 46 (statements -> assign .)
    PRINT           reduce using rule 46 (statements -> assign .)
    IF              reduce using rule 46 (statements -> assign .)
    WHILE           reduce using rule 46 (statements -> assign .)
    FOR             reduce using rule 46 (statements -> assign .)
    MEAN            reduce using rule 46 (statements -> assign .)
    RBRACE          reduce using rule 46 (statements -> assign .)
    SEMICOLON       reduce using rule 46 (statements -> assign .)
    RBRACKET        reduce using rule 46 (statements -> assign .)


state 44

    (47) statements -> function .

    VAR             reduce using rule 47 (statements -> function .)
    FUNCTION        reduce using rule 47 (statements -> function .)
    ID              reduce using rule 47 (statements -> function .)
    READ            reduce using rule 47 (statements -> function .)
    PRINT           reduce using rule 47 (statements -> function .)
    IF              reduce using rule 47 (statements -> function .)
    WHILE           reduce using rule 47 (statements -> function .)
    FOR             reduce using rule 47 (statements -> function .)
    MEAN            reduce using rule 47 (statements -> function .)
    RBRACE          reduce using rule 47 (statements -> function .)
    SEMICOLON       reduce using rule 47 (statements -> function .)
    RBRACKET        reduce using rule 47 (statements -> function .)


state 45

    (48) statements -> voidfunction .

    VAR             reduce using rule 48 (statements -> voidfunction .)
    FUNCTION        reduce using rule 48 (statements -> voidfunction .)
    ID              reduce using rule 48 (statements -> voidfunction .)
    READ            reduce using rule 48 (statements -> voidfunction .)
    PRINT           reduce using rule 48 (statements -> voidfunction .)
    IF              reduce using rule 48 (statements -> voidfunction .)
    WHILE           reduce using rule 48 (statements -> voidfunction .)
    FOR             reduce using rule 48 (statements -> voidfunction .)
    MEAN            reduce using rule 48 (statements -> voidfunction .)
    RBRACE          reduce using rule 48 (statements -> voidfunction .)
    SEMICOLON       reduce using rule 48 (statements -> voidfunction .)
    RBRACKET        reduce using rule 48 (statements -> voidfunction .)


state 46

    (49) statements -> call .

    VAR             reduce using rule 49 (statements -> call .)
    FUNCTION        reduce using rule 49 (statements -> call .)
    ID              reduce using rule 49 (statements -> call .)
    READ            reduce using rule 49 (statements -> call .)
    PRINT           reduce using rule 49 (statements -> call .)
    IF              reduce using rule 49 (statements -> call .)
    WHILE           reduce using rule 49 (statements -> call .)
    FOR             reduce using rule 49 (statements -> call .)
    MEAN            reduce using rule 49 (statements -> call .)
    RBRACE          reduce using rule 49 (statements -> call .)
    SEMICOLON       reduce using rule 49 (statements -> call .)
    RBRACKET        reduce using rule 49 (statements -> call .)


state 47

    (50) statements -> read .

    VAR             reduce using rule 50 (statements -> read .)
    FUNCTION        reduce using rule 50 (statements -> read .)
    ID              reduce using rule 50 (statements -> read .)
    READ            reduce using rule 50 (statements -> read .)
    PRINT           reduce using rule 50 (statements -> read .)
    IF              reduce using rule 50 (statements -> read .)
    WHILE           reduce using rule 50 (statements -> read .)
    FOR             reduce using rule 50 (statements -> read .)
    MEAN            reduce using rule 50 (statements -> read .)
    RBRACE          reduce using rule 50 (statements -> read .)
    SEMICOLON       reduce using rule 50 (statements -> read .)
    RBRACKET        reduce using rule 50 (statements -> read .)


state 48

    (51) statements -> print .

    VAR             reduce using rule 51 (statements -> print .)
    FUNCTION        reduce using rule 51 (statements -> print .)
    ID              reduce using rule 51 (statements -> print .)
    READ            reduce using rule 51 (statements -> print .)
    PRINT           reduce using rule 51 (statements -> print .)
    IF              reduce using rule 51 (statements -> print .)
    WHILE           reduce using rule 51 (statements -> print .)
    FOR             reduce using rule 51 (statements -> print .)
    MEAN            reduce using rule 51 (statements -> print .)
    RBRACE          reduce using rule 51 (statements -> print .)
    SEMICOLON       reduce using rule 51 (statements -> print .)
    RBRACKET        reduce using rule 51 (statements -> print .)


state 49

    (52) statements -> if .

    VAR             reduce using rule 52 (statements -> if .)
    FUNCTION        reduce using rule 52 (statements -> if .)
    ID              reduce using rule 52 (statements -> if .)
    READ            reduce using rule 52 (statements -> if .)
    PRINT           reduce using rule 52 (statements -> if .)
    IF              reduce using rule 52 (statements -> if .)
    WHILE           reduce using rule 52 (statements -> if .)
    FOR             reduce using rule 52 (statements -> if .)
    MEAN            reduce using rule 52 (statements -> if .)
    RBRACE          reduce using rule 52 (statements -> if .)
    SEMICOLON       reduce using rule 52 (statements -> if .)
    RBRACKET        reduce using rule 52 (statements -> if .)


state 50

    (53) statements -> while .

    VAR             reduce using rule 53 (statements -> while .)
    FUNCTION        reduce using rule 53 (statements -> while .)
    ID              reduce using rule 53 (statements -> while .)
    READ            reduce using rule 53 (statements -> while .)
    PRINT           reduce using rule 53 (statements -> while .)
    IF              reduce using rule 53 (statements -> while .)
    WHILE           reduce using rule 53 (statements -> while .)
    FOR             reduce using rule 53 (statements -> while .)
    MEAN            reduce using rule 53 (statements -> while .)
    RBRACE          reduce using rule 53 (statements -> while .)
    SEMICOLON       reduce using rule 53 (statements -> while .)
    RBRACKET        reduce using rule 53 (statements -> while .)


state 51

    (54) statements -> for .

    VAR             reduce using rule 54 (statements -> for .)
    FUNCTION        reduce using rule 54 (statements -> for .)
    ID              reduce using rule 54 (statements -> for .)
    READ            reduce using rule 54 (statements -> for .)
    PRINT           reduce using rule 54 (statements -> for .)
    IF              reduce using rule 54 (statements -> for .)
    WHILE           reduce using rule 54 (statements -> for .)
    FOR             reduce using rule 54 (statements -> for .)
    MEAN            reduce using rule 54 (statements -> for .)
    RBRACE          reduce using rule 54 (statements -> for .)
    SEMICOLON       reduce using rule 54 (statements -> for .)
    RBRACKET        reduce using rule 54 (statements -> for .)


state 52

    (55) statements -> funcesp .

    VAR             reduce using rule 55 (statements -> funcesp .)
    FUNCTION        reduce using rule 55 (statements -> funcesp .)
    ID              reduce using rule 55 (statements -> funcesp .)
    READ            reduce using rule 55 (statements -> funcesp .)
    PRINT           reduce using rule 55 (statements -> funcesp .)
    IF              reduce using rule 55 (statements -> funcesp .)
    WHILE           reduce using rule 55 (statements -> funcesp .)
    FOR             reduce using rule 55 (statements -> funcesp .)
    MEAN            reduce using rule 55 (statements -> funcesp .)
    RBRACE          reduce using rule 55 (statements -> funcesp .)
    SEMICOLON       reduce using rule 55 (statements -> funcesp .)
    RBRACKET        reduce using rule 55 (statements -> funcesp .)


state 53

    (57) assign -> var . EQUAL exp SEMICOLON

    EQUAL           shift and go to state 74


state 54

    (63) call -> ID . LPAREN callp RPAREN
    (62) var -> ID .
    (87) array -> ID . EQUAL ARRAY LPAREN var arrayp
    (90) matrix -> ID . EQUAL MATRIX LPAREN array matrixp
    (94) layers -> ID . EQUAL LAYERS LPAREN UNITS EQUAL INT RPAREN
    (95) sequential -> ID . EQUAL SEQUENTIAL LPAREN LBRACKET layers sequentialp
    (99) fit -> ID . EQUAL sequential DOT FIT LPAREN array COMMA array COMMA EPOCHS EQUAL INT COMMA VERBOSE EQUAL fitp
    (102) predict -> ID . EQUAL sequential DOT PREDICT LPAREN LBRACKET predictp

  ! shift/reduce conflict for EQUAL resolved as shift
    LPAREN          shift and go to state 75
    EQUAL           shift and go to state 76

  ! EQUAL           [ reduce using rule 62 (var -> ID .) ]


state 55

    (58) read -> READ . var
    (62) var -> . ID

    ID              shift and go to state 78

    var                            shift and go to state 77

state 56

    (59) print -> PRINT . LPAREN printp

    LPAREN          shift and go to state 79


state 57

    (66) if -> IF . LPAREN CTI GT CTI RPAREN quadsIf ifp jumpsIf

    LPAREN          shift and go to state 80


state 58

    (72) while -> WHILE . LPAREN exp RPAREN statements whilep

    LPAREN          shift and go to state 81


state 59

    (75) for -> FOR . LPAREN var SEMICOLON exp SEMICOLON exp RPAREN LBRACKET statements forp

    LPAREN          shift and go to state 82


state 60

    (78) funcesp -> array .

    VAR             reduce using rule 78 (funcesp -> array .)
    FUNCTION        reduce using rule 78 (funcesp -> array .)
    ID              reduce using rule 78 (funcesp -> array .)
    READ            reduce using rule 78 (funcesp -> array .)
    PRINT           reduce using rule 78 (funcesp -> array .)
    IF              reduce using rule 78 (funcesp -> array .)
    WHILE           reduce using rule 78 (funcesp -> array .)
    FOR             reduce using rule 78 (funcesp -> array .)
    MEAN            reduce using rule 78 (funcesp -> array .)
    RBRACE          reduce using rule 78 (funcesp -> array .)
    SEMICOLON       reduce using rule 78 (funcesp -> array .)
    RBRACKET        reduce using rule 78 (funcesp -> array .)


state 61

    (79) funcesp -> matrix .

    VAR             reduce using rule 79 (funcesp -> matrix .)
    FUNCTION        reduce using rule 79 (funcesp -> matrix .)
    ID              reduce using rule 79 (funcesp -> matrix .)
    READ            reduce using rule 79 (funcesp -> matrix .)
    PRINT           reduce using rule 79 (funcesp -> matrix .)
    IF              reduce using rule 79 (funcesp -> matrix .)
    WHILE           reduce using rule 79 (funcesp -> matrix .)
    FOR             reduce using rule 79 (funcesp -> matrix .)
    MEAN            reduce using rule 79 (funcesp -> matrix .)
    RBRACE          reduce using rule 79 (funcesp -> matrix .)
    SEMICOLON       reduce using rule 79 (funcesp -> matrix .)
    RBRACKET        reduce using rule 79 (funcesp -> matrix .)


state 62

    (80) funcesp -> mean .

    VAR             reduce using rule 80 (funcesp -> mean .)
    FUNCTION        reduce using rule 80 (funcesp -> mean .)
    ID              reduce using rule 80 (funcesp -> mean .)
    READ            reduce using rule 80 (funcesp -> mean .)
    PRINT           reduce using rule 80 (funcesp -> mean .)
    IF              reduce using rule 80 (funcesp -> mean .)
    WHILE           reduce using rule 80 (funcesp -> mean .)
    FOR             reduce using rule 80 (funcesp -> mean .)
    MEAN            reduce using rule 80 (funcesp -> mean .)
    RBRACE          reduce using rule 80 (funcesp -> mean .)
    SEMICOLON       reduce using rule 80 (funcesp -> mean .)
    RBRACKET        reduce using rule 80 (funcesp -> mean .)


state 63

    (81) funcesp -> layers .
    (105) getweights -> layers . DOT GETWEIGHTS LPAREN RPAREN

    VAR             reduce using rule 81 (funcesp -> layers .)
    FUNCTION        reduce using rule 81 (funcesp -> layers .)
    ID              reduce using rule 81 (funcesp -> layers .)
    READ            reduce using rule 81 (funcesp -> layers .)
    PRINT           reduce using rule 81 (funcesp -> layers .)
    IF              reduce using rule 81 (funcesp -> layers .)
    WHILE           reduce using rule 81 (funcesp -> layers .)
    FOR             reduce using rule 81 (funcesp -> layers .)
    MEAN            reduce using rule 81 (funcesp -> layers .)
    RBRACE          reduce using rule 81 (funcesp -> layers .)
    SEMICOLON       reduce using rule 81 (funcesp -> layers .)
    RBRACKET        reduce using rule 81 (funcesp -> layers .)
    DOT             shift and go to state 83


state 64

    (82) funcesp -> sequential .
    (98) compile -> sequential . DOT COMPILE LPAREN RPAREN

    VAR             reduce using rule 82 (funcesp -> sequential .)
    FUNCTION        reduce using rule 82 (funcesp -> sequential .)
    ID              reduce using rule 82 (funcesp -> sequential .)
    READ            reduce using rule 82 (funcesp -> sequential .)
    PRINT           reduce using rule 82 (funcesp -> sequential .)
    IF              reduce using rule 82 (funcesp -> sequential .)
    WHILE           reduce using rule 82 (funcesp -> sequential .)
    FOR             reduce using rule 82 (funcesp -> sequential .)
    MEAN            reduce using rule 82 (funcesp -> sequential .)
    RBRACE          reduce using rule 82 (funcesp -> sequential .)
    SEMICOLON       reduce using rule 82 (funcesp -> sequential .)
    RBRACKET        reduce using rule 82 (funcesp -> sequential .)
    DOT             shift and go to state 84


state 65

    (83) funcesp -> compile .

    VAR             reduce using rule 83 (funcesp -> compile .)
    FUNCTION        reduce using rule 83 (funcesp -> compile .)
    ID              reduce using rule 83 (funcesp -> compile .)
    READ            reduce using rule 83 (funcesp -> compile .)
    PRINT           reduce using rule 83 (funcesp -> compile .)
    IF              reduce using rule 83 (funcesp -> compile .)
    WHILE           reduce using rule 83 (funcesp -> compile .)
    FOR             reduce using rule 83 (funcesp -> compile .)
    MEAN            reduce using rule 83 (funcesp -> compile .)
    RBRACE          reduce using rule 83 (funcesp -> compile .)
    SEMICOLON       reduce using rule 83 (funcesp -> compile .)
    RBRACKET        reduce using rule 83 (funcesp -> compile .)


state 66

    (84) funcesp -> fit .

    VAR             reduce using rule 84 (funcesp -> fit .)
    FUNCTION        reduce using rule 84 (funcesp -> fit .)
    ID              reduce using rule 84 (funcesp -> fit .)
    READ            reduce using rule 84 (funcesp -> fit .)
    PRINT           reduce using rule 84 (funcesp -> fit .)
    IF              reduce using rule 84 (funcesp -> fit .)
    WHILE           reduce using rule 84 (funcesp -> fit .)
    FOR             reduce using rule 84 (funcesp -> fit .)
    MEAN            reduce using rule 84 (funcesp -> fit .)
    RBRACE          reduce using rule 84 (funcesp -> fit .)
    SEMICOLON       reduce using rule 84 (funcesp -> fit .)
    RBRACKET        reduce using rule 84 (funcesp -> fit .)


state 67

    (85) funcesp -> predict .

    VAR             reduce using rule 85 (funcesp -> predict .)
    FUNCTION        reduce using rule 85 (funcesp -> predict .)
    ID              reduce using rule 85 (funcesp -> predict .)
    READ            reduce using rule 85 (funcesp -> predict .)
    PRINT           reduce using rule 85 (funcesp -> predict .)
    IF              reduce using rule 85 (funcesp -> predict .)
    WHILE           reduce using rule 85 (funcesp -> predict .)
    FOR             reduce using rule 85 (funcesp -> predict .)
    MEAN            reduce using rule 85 (funcesp -> predict .)
    RBRACE          reduce using rule 85 (funcesp -> predict .)
    SEMICOLON       reduce using rule 85 (funcesp -> predict .)
    RBRACKET        reduce using rule 85 (funcesp -> predict .)


state 68

    (86) funcesp -> getweights .

    VAR             reduce using rule 86 (funcesp -> getweights .)
    FUNCTION        reduce using rule 86 (funcesp -> getweights .)
    ID              reduce using rule 86 (funcesp -> getweights .)
    READ            reduce using rule 86 (funcesp -> getweights .)
    PRINT           reduce using rule 86 (funcesp -> getweights .)
    IF              reduce using rule 86 (funcesp -> getweights .)
    WHILE           reduce using rule 86 (funcesp -> getweights .)
    FOR             reduce using rule 86 (funcesp -> getweights .)
    MEAN            reduce using rule 86 (funcesp -> getweights .)
    RBRACE          reduce using rule 86 (funcesp -> getweights .)
    SEMICOLON       reduce using rule 86 (funcesp -> getweights .)
    RBRACKET        reduce using rule 86 (funcesp -> getweights .)


state 69

    (93) mean -> MEAN . LPAREN array RPAREN

    LPAREN          shift and go to state 85


state 70

    (12) voidfunction -> FUNCTION VOID decfunc LPAREN param RPAREN LBRACE body . RBRACE

    RBRACE          shift and go to state 86


state 71

    (10) function -> FUNCTION type decfunc LPAREN param RPAREN LBRACE body RBRACE .

    FUNCTION        reduce using rule 10 (function -> FUNCTION type decfunc LPAREN param RPAREN LBRACE body RBRACE .)
    $end            reduce using rule 10 (function -> FUNCTION type decfunc LPAREN param RPAREN LBRACE body RBRACE .)
    VAR             reduce using rule 10 (function -> FUNCTION type decfunc LPAREN param RPAREN LBRACE body RBRACE .)
    ID              reduce using rule 10 (function -> FUNCTION type decfunc LPAREN param RPAREN LBRACE body RBRACE .)
    READ            reduce using rule 10 (function -> FUNCTION type decfunc LPAREN param RPAREN LBRACE body RBRACE .)
    PRINT           reduce using rule 10 (function -> FUNCTION type decfunc LPAREN param RPAREN LBRACE body RBRACE .)
    IF              reduce using rule 10 (function -> FUNCTION type decfunc LPAREN param RPAREN LBRACE body RBRACE .)
    WHILE           reduce using rule 10 (function -> FUNCTION type decfunc LPAREN param RPAREN LBRACE body RBRACE .)
    FOR             reduce using rule 10 (function -> FUNCTION type decfunc LPAREN param RPAREN LBRACE body RBRACE .)
    MEAN            reduce using rule 10 (function -> FUNCTION type decfunc LPAREN param RPAREN LBRACE body RBRACE .)
    RBRACE          reduce using rule 10 (function -> FUNCTION type decfunc LPAREN param RPAREN LBRACE body RBRACE .)
    SEMICOLON       reduce using rule 10 (function -> FUNCTION type decfunc LPAREN param RPAREN LBRACE body RBRACE .)
    RBRACKET        reduce using rule 10 (function -> FUNCTION type decfunc LPAREN param RPAREN LBRACE body RBRACE .)


state 72

    (18) body -> decvar statements . body
    (18) body -> . decvar statements body
    (19) body -> . statements body
    (20) body -> . decvar
    (21) body -> .
    (2) decvar -> . VAR decvarp
    (3) decvar -> . VAR decvarp decvar
    (4) decvar -> .
    (46) statements -> . assign
    (47) statements -> . function
    (48) statements -> . voidfunction
    (49) statements -> . call
    (50) statements -> . read
    (51) statements -> . print
    (52) statements -> . if
    (53) statements -> . while
    (54) statements -> . for
    (55) statements -> . funcesp
    (56) statements -> .
    (57) assign -> . var EQUAL exp SEMICOLON
    (10) function -> . FUNCTION type decfunc LPAREN param RPAREN LBRACE body RBRACE
    (12) voidfunction -> . FUNCTION VOID decfunc LPAREN param RPAREN LBRACE body RBRACE
    (63) call -> . ID LPAREN callp RPAREN
    (58) read -> . READ var
    (59) print -> . PRINT LPAREN printp
    (66) if -> . IF LPAREN CTI GT CTI RPAREN quadsIf ifp jumpsIf
    (72) while -> . WHILE LPAREN exp RPAREN statements whilep
    (75) for -> . FOR LPAREN var SEMICOLON exp SEMICOLON exp RPAREN LBRACKET statements forp
    (78) funcesp -> . array
    (79) funcesp -> . matrix
    (80) funcesp -> . mean
    (81) funcesp -> . layers
    (82) funcesp -> . sequential
    (83) funcesp -> . compile
    (84) funcesp -> . fit
    (85) funcesp -> . predict
    (86) funcesp -> . getweights
    (62) var -> . ID
    (87) array -> . ID EQUAL ARRAY LPAREN var arrayp
    (90) matrix -> . ID EQUAL MATRIX LPAREN array matrixp
    (93) mean -> . MEAN LPAREN array RPAREN
    (94) layers -> . ID EQUAL LAYERS LPAREN UNITS EQUAL INT RPAREN
    (95) sequential -> . ID EQUAL SEQUENTIAL LPAREN LBRACKET layers sequentialp
    (98) compile -> . sequential DOT COMPILE LPAREN RPAREN
    (99) fit -> . ID EQUAL sequential DOT FIT LPAREN array COMMA array COMMA EPOCHS EQUAL INT COMMA VERBOSE EQUAL fitp
    (102) predict -> . ID EQUAL sequential DOT PREDICT LPAREN LBRACKET predictp
    (105) getweights -> . layers DOT GETWEIGHTS LPAREN RPAREN

  ! shift/reduce conflict for VAR resolved as shift
  ! reduce/reduce conflict for RBRACE resolved using rule 4 (decvar -> .)
  ! shift/reduce conflict for VAR resolved as shift
  ! reduce/reduce conflict for FUNCTION resolved using rule 4 (decvar -> .)
  ! reduce/reduce conflict for ID resolved using rule 4 (decvar -> .)
  ! reduce/reduce conflict for READ resolved using rule 4 (decvar -> .)
  ! reduce/reduce conflict for PRINT resolved using rule 4 (decvar -> .)
  ! reduce/reduce conflict for IF resolved using rule 4 (decvar -> .)
  ! reduce/reduce conflict for WHILE resolved using rule 4 (decvar -> .)
  ! reduce/reduce conflict for FOR resolved using rule 4 (decvar -> .)
  ! reduce/reduce conflict for MEAN resolved using rule 4 (decvar -> .)
  ! reduce/reduce conflict for RBRACE resolved using rule 4 (decvar -> .)
  ! shift/reduce conflict for FUNCTION resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for READ resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for MEAN resolved as shift
    VAR             shift and go to state 6
    RBRACE          reduce using rule 4 (decvar -> .)
    FUNCTION        shift and go to state 10
    ID              shift and go to state 54
    READ            shift and go to state 55
    PRINT           shift and go to state 56
    IF              shift and go to state 57
    WHILE           shift and go to state 58
    FOR             shift and go to state 59
    MEAN            shift and go to state 69

  ! RBRACE          [ reduce using rule 21 (body -> .) ]
  ! VAR             [ reduce using rule 4 (decvar -> .) ]
  ! FUNCTION        [ reduce using rule 4 (decvar -> .) ]
  ! ID              [ reduce using rule 4 (decvar -> .) ]
  ! READ            [ reduce using rule 4 (decvar -> .) ]
  ! PRINT           [ reduce using rule 4 (decvar -> .) ]
  ! IF              [ reduce using rule 4 (decvar -> .) ]
  ! WHILE           [ reduce using rule 4 (decvar -> .) ]
  ! FOR             [ reduce using rule 4 (decvar -> .) ]
  ! MEAN            [ reduce using rule 4 (decvar -> .) ]
  ! VAR             [ reduce using rule 56 (statements -> .) ]
  ! FUNCTION        [ reduce using rule 56 (statements -> .) ]
  ! ID              [ reduce using rule 56 (statements -> .) ]
  ! READ            [ reduce using rule 56 (statements -> .) ]
  ! PRINT           [ reduce using rule 56 (statements -> .) ]
  ! IF              [ reduce using rule 56 (statements -> .) ]
  ! WHILE           [ reduce using rule 56 (statements -> .) ]
  ! FOR             [ reduce using rule 56 (statements -> .) ]
  ! MEAN            [ reduce using rule 56 (statements -> .) ]
  ! RBRACE          [ reduce using rule 56 (statements -> .) ]

    decvar                         shift and go to state 41
    statements                     shift and go to state 42
    body                           shift and go to state 87
    assign                         shift and go to state 43
    function                       shift and go to state 44
    voidfunction                   shift and go to state 45
    call                           shift and go to state 46
    read                           shift and go to state 47
    print                          shift and go to state 48
    if                             shift and go to state 49
    while                          shift and go to state 50
    for                            shift and go to state 51
    funcesp                        shift and go to state 52
    var                            shift and go to state 53
    array                          shift and go to state 60
    matrix                         shift and go to state 61
    mean                           shift and go to state 62
    layers                         shift and go to state 63
    sequential                     shift and go to state 64
    compile                        shift and go to state 65
    fit                            shift and go to state 66
    predict                        shift and go to state 67
    getweights                     shift and go to state 68

state 73

    (19) body -> statements body .

    RBRACE          reduce using rule 19 (body -> statements body .)


state 74

    (57) assign -> var EQUAL . exp SEMICOLON
    (25) exp -> . texp
    (26) exp -> . texp OR exp
    (27) texp -> . gexp
    (28) texp -> . gexp AND texp
    (29) gexp -> . mexp
    (30) gexp -> . mexp gexpp mexp
    (35) mexp -> . t
    (36) mexp -> . t PLUS mexp
    (37) mexp -> . t MINUS mexp
    (38) t -> . f
    (39) t -> . f MULT t
    (40) t -> . f DIV t
    (41) f -> . LPAREN exp RPAREN
    (42) f -> . CTI
    (43) f -> . CTF
    (44) f -> . var
    (45) f -> . call
    (62) var -> . ID
    (63) call -> . ID LPAREN callp RPAREN

    LPAREN          shift and go to state 95
    CTI             shift and go to state 96
    CTF             shift and go to state 97
    ID              shift and go to state 99

    var                            shift and go to state 88
    exp                            shift and go to state 89
    texp                           shift and go to state 90
    gexp                           shift and go to state 91
    mexp                           shift and go to state 92
    t                              shift and go to state 93
    f                              shift and go to state 94
    call                           shift and go to state 98

state 75

    (63) call -> ID LPAREN . callp RPAREN
    (64) callp -> . exp SEMICOLON callp
    (65) callp -> . exp
    (25) exp -> . texp
    (26) exp -> . texp OR exp
    (27) texp -> . gexp
    (28) texp -> . gexp AND texp
    (29) gexp -> . mexp
    (30) gexp -> . mexp gexpp mexp
    (35) mexp -> . t
    (36) mexp -> . t PLUS mexp
    (37) mexp -> . t MINUS mexp
    (38) t -> . f
    (39) t -> . f MULT t
    (40) t -> . f DIV t
    (41) f -> . LPAREN exp RPAREN
    (42) f -> . CTI
    (43) f -> . CTF
    (44) f -> . var
    (45) f -> . call
    (62) var -> . ID
    (63) call -> . ID LPAREN callp RPAREN

    LPAREN          shift and go to state 95
    CTI             shift and go to state 96
    CTF             shift and go to state 97
    ID              shift and go to state 99

    callp                          shift and go to state 100
    exp                            shift and go to state 101
    texp                           shift and go to state 90
    gexp                           shift and go to state 91
    mexp                           shift and go to state 92
    t                              shift and go to state 93
    f                              shift and go to state 94
    var                            shift and go to state 88
    call                           shift and go to state 98

state 76

    (87) array -> ID EQUAL . ARRAY LPAREN var arrayp
    (90) matrix -> ID EQUAL . MATRIX LPAREN array matrixp
    (94) layers -> ID EQUAL . LAYERS LPAREN UNITS EQUAL INT RPAREN
    (95) sequential -> ID EQUAL . SEQUENTIAL LPAREN LBRACKET layers sequentialp
    (99) fit -> ID EQUAL . sequential DOT FIT LPAREN array COMMA array COMMA EPOCHS EQUAL INT COMMA VERBOSE EQUAL fitp
    (102) predict -> ID EQUAL . sequential DOT PREDICT LPAREN LBRACKET predictp
    (95) sequential -> . ID EQUAL SEQUENTIAL LPAREN LBRACKET layers sequentialp

    ARRAY           shift and go to state 103
    MATRIX          shift and go to state 104
    LAYERS          shift and go to state 105
    SEQUENTIAL      shift and go to state 106
    ID              shift and go to state 102

    sequential                     shift and go to state 107

state 77

    (58) read -> READ var .

    VAR             reduce using rule 58 (read -> READ var .)
    FUNCTION        reduce using rule 58 (read -> READ var .)
    ID              reduce using rule 58 (read -> READ var .)
    READ            reduce using rule 58 (read -> READ var .)
    PRINT           reduce using rule 58 (read -> READ var .)
    IF              reduce using rule 58 (read -> READ var .)
    WHILE           reduce using rule 58 (read -> READ var .)
    FOR             reduce using rule 58 (read -> READ var .)
    MEAN            reduce using rule 58 (read -> READ var .)
    RBRACE          reduce using rule 58 (read -> READ var .)
    SEMICOLON       reduce using rule 58 (read -> READ var .)
    RBRACKET        reduce using rule 58 (read -> READ var .)


state 78

    (62) var -> ID .

    VAR             reduce using rule 62 (var -> ID .)
    FUNCTION        reduce using rule 62 (var -> ID .)
    ID              reduce using rule 62 (var -> ID .)
    READ            reduce using rule 62 (var -> ID .)
    PRINT           reduce using rule 62 (var -> ID .)
    IF              reduce using rule 62 (var -> ID .)
    WHILE           reduce using rule 62 (var -> ID .)
    FOR             reduce using rule 62 (var -> ID .)
    MEAN            reduce using rule 62 (var -> ID .)
    RBRACE          reduce using rule 62 (var -> ID .)
    SEMICOLON       reduce using rule 62 (var -> ID .)
    RBRACKET        reduce using rule 62 (var -> ID .)
    RPAREN          reduce using rule 62 (var -> ID .)
    COMMA           reduce using rule 62 (var -> ID .)


state 79

    (59) print -> PRINT LPAREN . printp
    (60) printp -> . exp RPAREN
    (61) printp -> . exp COMMA printp
    (25) exp -> . texp
    (26) exp -> . texp OR exp
    (27) texp -> . gexp
    (28) texp -> . gexp AND texp
    (29) gexp -> . mexp
    (30) gexp -> . mexp gexpp mexp
    (35) mexp -> . t
    (36) mexp -> . t PLUS mexp
    (37) mexp -> . t MINUS mexp
    (38) t -> . f
    (39) t -> . f MULT t
    (40) t -> . f DIV t
    (41) f -> . LPAREN exp RPAREN
    (42) f -> . CTI
    (43) f -> . CTF
    (44) f -> . var
    (45) f -> . call
    (62) var -> . ID
    (63) call -> . ID LPAREN callp RPAREN

    LPAREN          shift and go to state 95
    CTI             shift and go to state 96
    CTF             shift and go to state 97
    ID              shift and go to state 99

    printp                         shift and go to state 108
    exp                            shift and go to state 109
    texp                           shift and go to state 90
    gexp                           shift and go to state 91
    mexp                           shift and go to state 92
    t                              shift and go to state 93
    f                              shift and go to state 94
    var                            shift and go to state 88
    call                           shift and go to state 98

state 80

    (66) if -> IF LPAREN . CTI GT CTI RPAREN quadsIf ifp jumpsIf

    CTI             shift and go to state 110


state 81

    (72) while -> WHILE LPAREN . exp RPAREN statements whilep
    (25) exp -> . texp
    (26) exp -> . texp OR exp
    (27) texp -> . gexp
    (28) texp -> . gexp AND texp
    (29) gexp -> . mexp
    (30) gexp -> . mexp gexpp mexp
    (35) mexp -> . t
    (36) mexp -> . t PLUS mexp
    (37) mexp -> . t MINUS mexp
    (38) t -> . f
    (39) t -> . f MULT t
    (40) t -> . f DIV t
    (41) f -> . LPAREN exp RPAREN
    (42) f -> . CTI
    (43) f -> . CTF
    (44) f -> . var
    (45) f -> . call
    (62) var -> . ID
    (63) call -> . ID LPAREN callp RPAREN

    LPAREN          shift and go to state 95
    CTI             shift and go to state 96
    CTF             shift and go to state 97
    ID              shift and go to state 99

    exp                            shift and go to state 111
    texp                           shift and go to state 90
    gexp                           shift and go to state 91
    mexp                           shift and go to state 92
    t                              shift and go to state 93
    f                              shift and go to state 94
    var                            shift and go to state 88
    call                           shift and go to state 98

state 82

    (75) for -> FOR LPAREN . var SEMICOLON exp SEMICOLON exp RPAREN LBRACKET statements forp
    (62) var -> . ID

    ID              shift and go to state 78

    var                            shift and go to state 112

state 83

    (105) getweights -> layers DOT . GETWEIGHTS LPAREN RPAREN

    GETWEIGHTS      shift and go to state 113


state 84

    (98) compile -> sequential DOT . COMPILE LPAREN RPAREN

    COMPILE         shift and go to state 114


state 85

    (93) mean -> MEAN LPAREN . array RPAREN
    (87) array -> . ID EQUAL ARRAY LPAREN var arrayp

    ID              shift and go to state 116

    array                          shift and go to state 115

state 86

    (12) voidfunction -> FUNCTION VOID decfunc LPAREN param RPAREN LBRACE body RBRACE .

    FUNCTION        reduce using rule 12 (voidfunction -> FUNCTION VOID decfunc LPAREN param RPAREN LBRACE body RBRACE .)
    $end            reduce using rule 12 (voidfunction -> FUNCTION VOID decfunc LPAREN param RPAREN LBRACE body RBRACE .)
    VAR             reduce using rule 12 (voidfunction -> FUNCTION VOID decfunc LPAREN param RPAREN LBRACE body RBRACE .)
    ID              reduce using rule 12 (voidfunction -> FUNCTION VOID decfunc LPAREN param RPAREN LBRACE body RBRACE .)
    READ            reduce using rule 12 (voidfunction -> FUNCTION VOID decfunc LPAREN param RPAREN LBRACE body RBRACE .)
    PRINT           reduce using rule 12 (voidfunction -> FUNCTION VOID decfunc LPAREN param RPAREN LBRACE body RBRACE .)
    IF              reduce using rule 12 (voidfunction -> FUNCTION VOID decfunc LPAREN param RPAREN LBRACE body RBRACE .)
    WHILE           reduce using rule 12 (voidfunction -> FUNCTION VOID decfunc LPAREN param RPAREN LBRACE body RBRACE .)
    FOR             reduce using rule 12 (voidfunction -> FUNCTION VOID decfunc LPAREN param RPAREN LBRACE body RBRACE .)
    MEAN            reduce using rule 12 (voidfunction -> FUNCTION VOID decfunc LPAREN param RPAREN LBRACE body RBRACE .)
    RBRACE          reduce using rule 12 (voidfunction -> FUNCTION VOID decfunc LPAREN param RPAREN LBRACE body RBRACE .)
    SEMICOLON       reduce using rule 12 (voidfunction -> FUNCTION VOID decfunc LPAREN param RPAREN LBRACE body RBRACE .)
    RBRACKET        reduce using rule 12 (voidfunction -> FUNCTION VOID decfunc LPAREN param RPAREN LBRACE body RBRACE .)


state 87

    (18) body -> decvar statements body .

    RBRACE          reduce using rule 18 (body -> decvar statements body .)


state 88

    (44) f -> var .

    MULT            reduce using rule 44 (f -> var .)
    DIV             reduce using rule 44 (f -> var .)
    PLUS            reduce using rule 44 (f -> var .)
    MINUS           reduce using rule 44 (f -> var .)
    LT              reduce using rule 44 (f -> var .)
    GT              reduce using rule 44 (f -> var .)
    EQUAL           reduce using rule 44 (f -> var .)
    DIFF            reduce using rule 44 (f -> var .)
    AND             reduce using rule 44 (f -> var .)
    OR              reduce using rule 44 (f -> var .)
    SEMICOLON       reduce using rule 44 (f -> var .)
    RPAREN          reduce using rule 44 (f -> var .)
    COMMA           reduce using rule 44 (f -> var .)


state 89

    (57) assign -> var EQUAL exp . SEMICOLON

    SEMICOLON       shift and go to state 117


state 90

    (25) exp -> texp .
    (26) exp -> texp . OR exp

    SEMICOLON       reduce using rule 25 (exp -> texp .)
    RPAREN          reduce using rule 25 (exp -> texp .)
    COMMA           reduce using rule 25 (exp -> texp .)
    OR              shift and go to state 118


state 91

    (27) texp -> gexp .
    (28) texp -> gexp . AND texp

    OR              reduce using rule 27 (texp -> gexp .)
    SEMICOLON       reduce using rule 27 (texp -> gexp .)
    RPAREN          reduce using rule 27 (texp -> gexp .)
    COMMA           reduce using rule 27 (texp -> gexp .)
    AND             shift and go to state 119


state 92

    (29) gexp -> mexp .
    (30) gexp -> mexp . gexpp mexp
    (31) gexpp -> . LT
    (32) gexpp -> . GT
    (33) gexpp -> . EQUAL
    (34) gexpp -> . DIFF

    AND             reduce using rule 29 (gexp -> mexp .)
    OR              reduce using rule 29 (gexp -> mexp .)
    SEMICOLON       reduce using rule 29 (gexp -> mexp .)
    RPAREN          reduce using rule 29 (gexp -> mexp .)
    COMMA           reduce using rule 29 (gexp -> mexp .)
    LT              shift and go to state 121
    GT              shift and go to state 122
    EQUAL           shift and go to state 123
    DIFF            shift and go to state 124

    gexpp                          shift and go to state 120

state 93

    (35) mexp -> t .
    (36) mexp -> t . PLUS mexp
    (37) mexp -> t . MINUS mexp

    LT              reduce using rule 35 (mexp -> t .)
    GT              reduce using rule 35 (mexp -> t .)
    EQUAL           reduce using rule 35 (mexp -> t .)
    DIFF            reduce using rule 35 (mexp -> t .)
    AND             reduce using rule 35 (mexp -> t .)
    OR              reduce using rule 35 (mexp -> t .)
    SEMICOLON       reduce using rule 35 (mexp -> t .)
    RPAREN          reduce using rule 35 (mexp -> t .)
    COMMA           reduce using rule 35 (mexp -> t .)
    PLUS            shift and go to state 125
    MINUS           shift and go to state 126


state 94

    (38) t -> f .
    (39) t -> f . MULT t
    (40) t -> f . DIV t

    PLUS            reduce using rule 38 (t -> f .)
    MINUS           reduce using rule 38 (t -> f .)
    LT              reduce using rule 38 (t -> f .)
    GT              reduce using rule 38 (t -> f .)
    EQUAL           reduce using rule 38 (t -> f .)
    DIFF            reduce using rule 38 (t -> f .)
    AND             reduce using rule 38 (t -> f .)
    OR              reduce using rule 38 (t -> f .)
    SEMICOLON       reduce using rule 38 (t -> f .)
    RPAREN          reduce using rule 38 (t -> f .)
    COMMA           reduce using rule 38 (t -> f .)
    MULT            shift and go to state 127
    DIV             shift and go to state 128


state 95

    (41) f -> LPAREN . exp RPAREN
    (25) exp -> . texp
    (26) exp -> . texp OR exp
    (27) texp -> . gexp
    (28) texp -> . gexp AND texp
    (29) gexp -> . mexp
    (30) gexp -> . mexp gexpp mexp
    (35) mexp -> . t
    (36) mexp -> . t PLUS mexp
    (37) mexp -> . t MINUS mexp
    (38) t -> . f
    (39) t -> . f MULT t
    (40) t -> . f DIV t
    (41) f -> . LPAREN exp RPAREN
    (42) f -> . CTI
    (43) f -> . CTF
    (44) f -> . var
    (45) f -> . call
    (62) var -> . ID
    (63) call -> . ID LPAREN callp RPAREN

    LPAREN          shift and go to state 95
    CTI             shift and go to state 96
    CTF             shift and go to state 97
    ID              shift and go to state 99

    exp                            shift and go to state 129
    texp                           shift and go to state 90
    gexp                           shift and go to state 91
    mexp                           shift and go to state 92
    t                              shift and go to state 93
    f                              shift and go to state 94
    var                            shift and go to state 88
    call                           shift and go to state 98

state 96

    (42) f -> CTI .

    MULT            reduce using rule 42 (f -> CTI .)
    DIV             reduce using rule 42 (f -> CTI .)
    PLUS            reduce using rule 42 (f -> CTI .)
    MINUS           reduce using rule 42 (f -> CTI .)
    LT              reduce using rule 42 (f -> CTI .)
    GT              reduce using rule 42 (f -> CTI .)
    EQUAL           reduce using rule 42 (f -> CTI .)
    DIFF            reduce using rule 42 (f -> CTI .)
    AND             reduce using rule 42 (f -> CTI .)
    OR              reduce using rule 42 (f -> CTI .)
    SEMICOLON       reduce using rule 42 (f -> CTI .)
    RPAREN          reduce using rule 42 (f -> CTI .)
    COMMA           reduce using rule 42 (f -> CTI .)


state 97

    (43) f -> CTF .

    MULT            reduce using rule 43 (f -> CTF .)
    DIV             reduce using rule 43 (f -> CTF .)
    PLUS            reduce using rule 43 (f -> CTF .)
    MINUS           reduce using rule 43 (f -> CTF .)
    LT              reduce using rule 43 (f -> CTF .)
    GT              reduce using rule 43 (f -> CTF .)
    EQUAL           reduce using rule 43 (f -> CTF .)
    DIFF            reduce using rule 43 (f -> CTF .)
    AND             reduce using rule 43 (f -> CTF .)
    OR              reduce using rule 43 (f -> CTF .)
    SEMICOLON       reduce using rule 43 (f -> CTF .)
    RPAREN          reduce using rule 43 (f -> CTF .)
    COMMA           reduce using rule 43 (f -> CTF .)


state 98

    (45) f -> call .

    MULT            reduce using rule 45 (f -> call .)
    DIV             reduce using rule 45 (f -> call .)
    PLUS            reduce using rule 45 (f -> call .)
    MINUS           reduce using rule 45 (f -> call .)
    LT              reduce using rule 45 (f -> call .)
    GT              reduce using rule 45 (f -> call .)
    EQUAL           reduce using rule 45 (f -> call .)
    DIFF            reduce using rule 45 (f -> call .)
    AND             reduce using rule 45 (f -> call .)
    OR              reduce using rule 45 (f -> call .)
    SEMICOLON       reduce using rule 45 (f -> call .)
    RPAREN          reduce using rule 45 (f -> call .)
    COMMA           reduce using rule 45 (f -> call .)


state 99

    (62) var -> ID .
    (63) call -> ID . LPAREN callp RPAREN

    MULT            reduce using rule 62 (var -> ID .)
    DIV             reduce using rule 62 (var -> ID .)
    PLUS            reduce using rule 62 (var -> ID .)
    MINUS           reduce using rule 62 (var -> ID .)
    LT              reduce using rule 62 (var -> ID .)
    GT              reduce using rule 62 (var -> ID .)
    EQUAL           reduce using rule 62 (var -> ID .)
    DIFF            reduce using rule 62 (var -> ID .)
    AND             reduce using rule 62 (var -> ID .)
    OR              reduce using rule 62 (var -> ID .)
    SEMICOLON       reduce using rule 62 (var -> ID .)
    RPAREN          reduce using rule 62 (var -> ID .)
    COMMA           reduce using rule 62 (var -> ID .)
    LPAREN          shift and go to state 75


state 100

    (63) call -> ID LPAREN callp . RPAREN

    RPAREN          shift and go to state 130


state 101

    (64) callp -> exp . SEMICOLON callp
    (65) callp -> exp .

    SEMICOLON       shift and go to state 131
    RPAREN          reduce using rule 65 (callp -> exp .)


state 102

    (95) sequential -> ID . EQUAL SEQUENTIAL LPAREN LBRACKET layers sequentialp

    EQUAL           shift and go to state 132


state 103

    (87) array -> ID EQUAL ARRAY . LPAREN var arrayp

    LPAREN          shift and go to state 133


state 104

    (90) matrix -> ID EQUAL MATRIX . LPAREN array matrixp

    LPAREN          shift and go to state 134


state 105

    (94) layers -> ID EQUAL LAYERS . LPAREN UNITS EQUAL INT RPAREN

    LPAREN          shift and go to state 135


state 106

    (95) sequential -> ID EQUAL SEQUENTIAL . LPAREN LBRACKET layers sequentialp

    LPAREN          shift and go to state 136


state 107

    (99) fit -> ID EQUAL sequential . DOT FIT LPAREN array COMMA array COMMA EPOCHS EQUAL INT COMMA VERBOSE EQUAL fitp
    (102) predict -> ID EQUAL sequential . DOT PREDICT LPAREN LBRACKET predictp

    DOT             shift and go to state 137


state 108

    (59) print -> PRINT LPAREN printp .

    VAR             reduce using rule 59 (print -> PRINT LPAREN printp .)
    FUNCTION        reduce using rule 59 (print -> PRINT LPAREN printp .)
    ID              reduce using rule 59 (print -> PRINT LPAREN printp .)
    READ            reduce using rule 59 (print -> PRINT LPAREN printp .)
    PRINT           reduce using rule 59 (print -> PRINT LPAREN printp .)
    IF              reduce using rule 59 (print -> PRINT LPAREN printp .)
    WHILE           reduce using rule 59 (print -> PRINT LPAREN printp .)
    FOR             reduce using rule 59 (print -> PRINT LPAREN printp .)
    MEAN            reduce using rule 59 (print -> PRINT LPAREN printp .)
    RBRACE          reduce using rule 59 (print -> PRINT LPAREN printp .)
    SEMICOLON       reduce using rule 59 (print -> PRINT LPAREN printp .)
    RBRACKET        reduce using rule 59 (print -> PRINT LPAREN printp .)


state 109

    (60) printp -> exp . RPAREN
    (61) printp -> exp . COMMA printp

    RPAREN          shift and go to state 138
    COMMA           shift and go to state 139


state 110

    (66) if -> IF LPAREN CTI . GT CTI RPAREN quadsIf ifp jumpsIf

    GT              shift and go to state 140


state 111

    (72) while -> WHILE LPAREN exp . RPAREN statements whilep

    RPAREN          shift and go to state 141


state 112

    (75) for -> FOR LPAREN var . SEMICOLON exp SEMICOLON exp RPAREN LBRACKET statements forp

    SEMICOLON       shift and go to state 142


state 113

    (105) getweights -> layers DOT GETWEIGHTS . LPAREN RPAREN

    LPAREN          shift and go to state 143


state 114

    (98) compile -> sequential DOT COMPILE . LPAREN RPAREN

    LPAREN          shift and go to state 144


state 115

    (93) mean -> MEAN LPAREN array . RPAREN

    RPAREN          shift and go to state 145


state 116

    (87) array -> ID . EQUAL ARRAY LPAREN var arrayp

    EQUAL           shift and go to state 146


state 117

    (57) assign -> var EQUAL exp SEMICOLON .

    VAR             reduce using rule 57 (assign -> var EQUAL exp SEMICOLON .)
    FUNCTION        reduce using rule 57 (assign -> var EQUAL exp SEMICOLON .)
    ID              reduce using rule 57 (assign -> var EQUAL exp SEMICOLON .)
    READ            reduce using rule 57 (assign -> var EQUAL exp SEMICOLON .)
    PRINT           reduce using rule 57 (assign -> var EQUAL exp SEMICOLON .)
    IF              reduce using rule 57 (assign -> var EQUAL exp SEMICOLON .)
    WHILE           reduce using rule 57 (assign -> var EQUAL exp SEMICOLON .)
    FOR             reduce using rule 57 (assign -> var EQUAL exp SEMICOLON .)
    MEAN            reduce using rule 57 (assign -> var EQUAL exp SEMICOLON .)
    RBRACE          reduce using rule 57 (assign -> var EQUAL exp SEMICOLON .)
    SEMICOLON       reduce using rule 57 (assign -> var EQUAL exp SEMICOLON .)
    RBRACKET        reduce using rule 57 (assign -> var EQUAL exp SEMICOLON .)


state 118

    (26) exp -> texp OR . exp
    (25) exp -> . texp
    (26) exp -> . texp OR exp
    (27) texp -> . gexp
    (28) texp -> . gexp AND texp
    (29) gexp -> . mexp
    (30) gexp -> . mexp gexpp mexp
    (35) mexp -> . t
    (36) mexp -> . t PLUS mexp
    (37) mexp -> . t MINUS mexp
    (38) t -> . f
    (39) t -> . f MULT t
    (40) t -> . f DIV t
    (41) f -> . LPAREN exp RPAREN
    (42) f -> . CTI
    (43) f -> . CTF
    (44) f -> . var
    (45) f -> . call
    (62) var -> . ID
    (63) call -> . ID LPAREN callp RPAREN

    LPAREN          shift and go to state 95
    CTI             shift and go to state 96
    CTF             shift and go to state 97
    ID              shift and go to state 99

    texp                           shift and go to state 90
    exp                            shift and go to state 147
    gexp                           shift and go to state 91
    mexp                           shift and go to state 92
    t                              shift and go to state 93
    f                              shift and go to state 94
    var                            shift and go to state 88
    call                           shift and go to state 98

state 119

    (28) texp -> gexp AND . texp
    (27) texp -> . gexp
    (28) texp -> . gexp AND texp
    (29) gexp -> . mexp
    (30) gexp -> . mexp gexpp mexp
    (35) mexp -> . t
    (36) mexp -> . t PLUS mexp
    (37) mexp -> . t MINUS mexp
    (38) t -> . f
    (39) t -> . f MULT t
    (40) t -> . f DIV t
    (41) f -> . LPAREN exp RPAREN
    (42) f -> . CTI
    (43) f -> . CTF
    (44) f -> . var
    (45) f -> . call
    (62) var -> . ID
    (63) call -> . ID LPAREN callp RPAREN

    LPAREN          shift and go to state 95
    CTI             shift and go to state 96
    CTF             shift and go to state 97
    ID              shift and go to state 99

    gexp                           shift and go to state 91
    texp                           shift and go to state 148
    mexp                           shift and go to state 92
    t                              shift and go to state 93
    f                              shift and go to state 94
    var                            shift and go to state 88
    call                           shift and go to state 98

state 120

    (30) gexp -> mexp gexpp . mexp
    (35) mexp -> . t
    (36) mexp -> . t PLUS mexp
    (37) mexp -> . t MINUS mexp
    (38) t -> . f
    (39) t -> . f MULT t
    (40) t -> . f DIV t
    (41) f -> . LPAREN exp RPAREN
    (42) f -> . CTI
    (43) f -> . CTF
    (44) f -> . var
    (45) f -> . call
    (62) var -> . ID
    (63) call -> . ID LPAREN callp RPAREN

    LPAREN          shift and go to state 95
    CTI             shift and go to state 96
    CTF             shift and go to state 97
    ID              shift and go to state 99

    mexp                           shift and go to state 149
    t                              shift and go to state 93
    f                              shift and go to state 94
    var                            shift and go to state 88
    call                           shift and go to state 98

state 121

    (31) gexpp -> LT .

    LPAREN          reduce using rule 31 (gexpp -> LT .)
    CTI             reduce using rule 31 (gexpp -> LT .)
    CTF             reduce using rule 31 (gexpp -> LT .)
    ID              reduce using rule 31 (gexpp -> LT .)


state 122

    (32) gexpp -> GT .

    LPAREN          reduce using rule 32 (gexpp -> GT .)
    CTI             reduce using rule 32 (gexpp -> GT .)
    CTF             reduce using rule 32 (gexpp -> GT .)
    ID              reduce using rule 32 (gexpp -> GT .)


state 123

    (33) gexpp -> EQUAL .

    LPAREN          reduce using rule 33 (gexpp -> EQUAL .)
    CTI             reduce using rule 33 (gexpp -> EQUAL .)
    CTF             reduce using rule 33 (gexpp -> EQUAL .)
    ID              reduce using rule 33 (gexpp -> EQUAL .)


state 124

    (34) gexpp -> DIFF .

    LPAREN          reduce using rule 34 (gexpp -> DIFF .)
    CTI             reduce using rule 34 (gexpp -> DIFF .)
    CTF             reduce using rule 34 (gexpp -> DIFF .)
    ID              reduce using rule 34 (gexpp -> DIFF .)


state 125

    (36) mexp -> t PLUS . mexp
    (35) mexp -> . t
    (36) mexp -> . t PLUS mexp
    (37) mexp -> . t MINUS mexp
    (38) t -> . f
    (39) t -> . f MULT t
    (40) t -> . f DIV t
    (41) f -> . LPAREN exp RPAREN
    (42) f -> . CTI
    (43) f -> . CTF
    (44) f -> . var
    (45) f -> . call
    (62) var -> . ID
    (63) call -> . ID LPAREN callp RPAREN

    LPAREN          shift and go to state 95
    CTI             shift and go to state 96
    CTF             shift and go to state 97
    ID              shift and go to state 99

    t                              shift and go to state 93
    mexp                           shift and go to state 150
    f                              shift and go to state 94
    var                            shift and go to state 88
    call                           shift and go to state 98

state 126

    (37) mexp -> t MINUS . mexp
    (35) mexp -> . t
    (36) mexp -> . t PLUS mexp
    (37) mexp -> . t MINUS mexp
    (38) t -> . f
    (39) t -> . f MULT t
    (40) t -> . f DIV t
    (41) f -> . LPAREN exp RPAREN
    (42) f -> . CTI
    (43) f -> . CTF
    (44) f -> . var
    (45) f -> . call
    (62) var -> . ID
    (63) call -> . ID LPAREN callp RPAREN

    LPAREN          shift and go to state 95
    CTI             shift and go to state 96
    CTF             shift and go to state 97
    ID              shift and go to state 99

    t                              shift and go to state 93
    mexp                           shift and go to state 151
    f                              shift and go to state 94
    var                            shift and go to state 88
    call                           shift and go to state 98

state 127

    (39) t -> f MULT . t
    (38) t -> . f
    (39) t -> . f MULT t
    (40) t -> . f DIV t
    (41) f -> . LPAREN exp RPAREN
    (42) f -> . CTI
    (43) f -> . CTF
    (44) f -> . var
    (45) f -> . call
    (62) var -> . ID
    (63) call -> . ID LPAREN callp RPAREN

    LPAREN          shift and go to state 95
    CTI             shift and go to state 96
    CTF             shift and go to state 97
    ID              shift and go to state 99

    f                              shift and go to state 94
    t                              shift and go to state 152
    var                            shift and go to state 88
    call                           shift and go to state 98

state 128

    (40) t -> f DIV . t
    (38) t -> . f
    (39) t -> . f MULT t
    (40) t -> . f DIV t
    (41) f -> . LPAREN exp RPAREN
    (42) f -> . CTI
    (43) f -> . CTF
    (44) f -> . var
    (45) f -> . call
    (62) var -> . ID
    (63) call -> . ID LPAREN callp RPAREN

    LPAREN          shift and go to state 95
    CTI             shift and go to state 96
    CTF             shift and go to state 97
    ID              shift and go to state 99

    f                              shift and go to state 94
    t                              shift and go to state 153
    var                            shift and go to state 88
    call                           shift and go to state 98

state 129

    (41) f -> LPAREN exp . RPAREN

    RPAREN          shift and go to state 154


state 130

    (63) call -> ID LPAREN callp RPAREN .

    VAR             reduce using rule 63 (call -> ID LPAREN callp RPAREN .)
    FUNCTION        reduce using rule 63 (call -> ID LPAREN callp RPAREN .)
    ID              reduce using rule 63 (call -> ID LPAREN callp RPAREN .)
    READ            reduce using rule 63 (call -> ID LPAREN callp RPAREN .)
    PRINT           reduce using rule 63 (call -> ID LPAREN callp RPAREN .)
    IF              reduce using rule 63 (call -> ID LPAREN callp RPAREN .)
    WHILE           reduce using rule 63 (call -> ID LPAREN callp RPAREN .)
    FOR             reduce using rule 63 (call -> ID LPAREN callp RPAREN .)
    MEAN            reduce using rule 63 (call -> ID LPAREN callp RPAREN .)
    RBRACE          reduce using rule 63 (call -> ID LPAREN callp RPAREN .)
    MULT            reduce using rule 63 (call -> ID LPAREN callp RPAREN .)
    DIV             reduce using rule 63 (call -> ID LPAREN callp RPAREN .)
    PLUS            reduce using rule 63 (call -> ID LPAREN callp RPAREN .)
    MINUS           reduce using rule 63 (call -> ID LPAREN callp RPAREN .)
    LT              reduce using rule 63 (call -> ID LPAREN callp RPAREN .)
    GT              reduce using rule 63 (call -> ID LPAREN callp RPAREN .)
    EQUAL           reduce using rule 63 (call -> ID LPAREN callp RPAREN .)
    DIFF            reduce using rule 63 (call -> ID LPAREN callp RPAREN .)
    AND             reduce using rule 63 (call -> ID LPAREN callp RPAREN .)
    OR              reduce using rule 63 (call -> ID LPAREN callp RPAREN .)
    SEMICOLON       reduce using rule 63 (call -> ID LPAREN callp RPAREN .)
    RPAREN          reduce using rule 63 (call -> ID LPAREN callp RPAREN .)
    COMMA           reduce using rule 63 (call -> ID LPAREN callp RPAREN .)
    RBRACKET        reduce using rule 63 (call -> ID LPAREN callp RPAREN .)


state 131

    (64) callp -> exp SEMICOLON . callp
    (64) callp -> . exp SEMICOLON callp
    (65) callp -> . exp
    (25) exp -> . texp
    (26) exp -> . texp OR exp
    (27) texp -> . gexp
    (28) texp -> . gexp AND texp
    (29) gexp -> . mexp
    (30) gexp -> . mexp gexpp mexp
    (35) mexp -> . t
    (36) mexp -> . t PLUS mexp
    (37) mexp -> . t MINUS mexp
    (38) t -> . f
    (39) t -> . f MULT t
    (40) t -> . f DIV t
    (41) f -> . LPAREN exp RPAREN
    (42) f -> . CTI
    (43) f -> . CTF
    (44) f -> . var
    (45) f -> . call
    (62) var -> . ID
    (63) call -> . ID LPAREN callp RPAREN

    LPAREN          shift and go to state 95
    CTI             shift and go to state 96
    CTF             shift and go to state 97
    ID              shift and go to state 99

    exp                            shift and go to state 101
    callp                          shift and go to state 155
    texp                           shift and go to state 90
    gexp                           shift and go to state 91
    mexp                           shift and go to state 92
    t                              shift and go to state 93
    f                              shift and go to state 94
    var                            shift and go to state 88
    call                           shift and go to state 98

state 132

    (95) sequential -> ID EQUAL . SEQUENTIAL LPAREN LBRACKET layers sequentialp

    SEQUENTIAL      shift and go to state 106


state 133

    (87) array -> ID EQUAL ARRAY LPAREN . var arrayp
    (62) var -> . ID

    ID              shift and go to state 78

    var                            shift and go to state 156

state 134

    (90) matrix -> ID EQUAL MATRIX LPAREN . array matrixp
    (87) array -> . ID EQUAL ARRAY LPAREN var arrayp

    ID              shift and go to state 116

    array                          shift and go to state 157

state 135

    (94) layers -> ID EQUAL LAYERS LPAREN . UNITS EQUAL INT RPAREN

    UNITS           shift and go to state 158


state 136

    (95) sequential -> ID EQUAL SEQUENTIAL LPAREN . LBRACKET layers sequentialp

    LBRACKET        shift and go to state 159


state 137

    (99) fit -> ID EQUAL sequential DOT . FIT LPAREN array COMMA array COMMA EPOCHS EQUAL INT COMMA VERBOSE EQUAL fitp
    (102) predict -> ID EQUAL sequential DOT . PREDICT LPAREN LBRACKET predictp

    FIT             shift and go to state 160
    PREDICT         shift and go to state 161


state 138

    (60) printp -> exp RPAREN .

    VAR             reduce using rule 60 (printp -> exp RPAREN .)
    FUNCTION        reduce using rule 60 (printp -> exp RPAREN .)
    ID              reduce using rule 60 (printp -> exp RPAREN .)
    READ            reduce using rule 60 (printp -> exp RPAREN .)
    PRINT           reduce using rule 60 (printp -> exp RPAREN .)
    IF              reduce using rule 60 (printp -> exp RPAREN .)
    WHILE           reduce using rule 60 (printp -> exp RPAREN .)
    FOR             reduce using rule 60 (printp -> exp RPAREN .)
    MEAN            reduce using rule 60 (printp -> exp RPAREN .)
    RBRACE          reduce using rule 60 (printp -> exp RPAREN .)
    SEMICOLON       reduce using rule 60 (printp -> exp RPAREN .)
    RBRACKET        reduce using rule 60 (printp -> exp RPAREN .)


state 139

    (61) printp -> exp COMMA . printp
    (60) printp -> . exp RPAREN
    (61) printp -> . exp COMMA printp
    (25) exp -> . texp
    (26) exp -> . texp OR exp
    (27) texp -> . gexp
    (28) texp -> . gexp AND texp
    (29) gexp -> . mexp
    (30) gexp -> . mexp gexpp mexp
    (35) mexp -> . t
    (36) mexp -> . t PLUS mexp
    (37) mexp -> . t MINUS mexp
    (38) t -> . f
    (39) t -> . f MULT t
    (40) t -> . f DIV t
    (41) f -> . LPAREN exp RPAREN
    (42) f -> . CTI
    (43) f -> . CTF
    (44) f -> . var
    (45) f -> . call
    (62) var -> . ID
    (63) call -> . ID LPAREN callp RPAREN

    LPAREN          shift and go to state 95
    CTI             shift and go to state 96
    CTF             shift and go to state 97
    ID              shift and go to state 99

    exp                            shift and go to state 109
    printp                         shift and go to state 162
    texp                           shift and go to state 90
    gexp                           shift and go to state 91
    mexp                           shift and go to state 92
    t                              shift and go to state 93
    f                              shift and go to state 94
    var                            shift and go to state 88
    call                           shift and go to state 98

state 140

    (66) if -> IF LPAREN CTI GT . CTI RPAREN quadsIf ifp jumpsIf

    CTI             shift and go to state 163


state 141

    (72) while -> WHILE LPAREN exp RPAREN . statements whilep
    (46) statements -> . assign
    (47) statements -> . function
    (48) statements -> . voidfunction
    (49) statements -> . call
    (50) statements -> . read
    (51) statements -> . print
    (52) statements -> . if
    (53) statements -> . while
    (54) statements -> . for
    (55) statements -> . funcesp
    (56) statements -> .
    (57) assign -> . var EQUAL exp SEMICOLON
    (10) function -> . FUNCTION type decfunc LPAREN param RPAREN LBRACE body RBRACE
    (12) voidfunction -> . FUNCTION VOID decfunc LPAREN param RPAREN LBRACE body RBRACE
    (63) call -> . ID LPAREN callp RPAREN
    (58) read -> . READ var
    (59) print -> . PRINT LPAREN printp
    (66) if -> . IF LPAREN CTI GT CTI RPAREN quadsIf ifp jumpsIf
    (72) while -> . WHILE LPAREN exp RPAREN statements whilep
    (75) for -> . FOR LPAREN var SEMICOLON exp SEMICOLON exp RPAREN LBRACKET statements forp
    (78) funcesp -> . array
    (79) funcesp -> . matrix
    (80) funcesp -> . mean
    (81) funcesp -> . layers
    (82) funcesp -> . sequential
    (83) funcesp -> . compile
    (84) funcesp -> . fit
    (85) funcesp -> . predict
    (86) funcesp -> . getweights
    (62) var -> . ID
    (87) array -> . ID EQUAL ARRAY LPAREN var arrayp
    (90) matrix -> . ID EQUAL MATRIX LPAREN array matrixp
    (93) mean -> . MEAN LPAREN array RPAREN
    (94) layers -> . ID EQUAL LAYERS LPAREN UNITS EQUAL INT RPAREN
    (95) sequential -> . ID EQUAL SEQUENTIAL LPAREN LBRACKET layers sequentialp
    (98) compile -> . sequential DOT COMPILE LPAREN RPAREN
    (99) fit -> . ID EQUAL sequential DOT FIT LPAREN array COMMA array COMMA EPOCHS EQUAL INT COMMA VERBOSE EQUAL fitp
    (102) predict -> . ID EQUAL sequential DOT PREDICT LPAREN LBRACKET predictp
    (105) getweights -> . layers DOT GETWEIGHTS LPAREN RPAREN

  ! shift/reduce conflict for FUNCTION resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for READ resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for MEAN resolved as shift
    SEMICOLON       reduce using rule 56 (statements -> .)
    FUNCTION        shift and go to state 10
    ID              shift and go to state 54
    READ            shift and go to state 55
    PRINT           shift and go to state 56
    IF              shift and go to state 57
    WHILE           shift and go to state 58
    FOR             shift and go to state 59
    MEAN            shift and go to state 69

  ! FUNCTION        [ reduce using rule 56 (statements -> .) ]
  ! ID              [ reduce using rule 56 (statements -> .) ]
  ! READ            [ reduce using rule 56 (statements -> .) ]
  ! PRINT           [ reduce using rule 56 (statements -> .) ]
  ! IF              [ reduce using rule 56 (statements -> .) ]
  ! WHILE           [ reduce using rule 56 (statements -> .) ]
  ! FOR             [ reduce using rule 56 (statements -> .) ]
  ! MEAN            [ reduce using rule 56 (statements -> .) ]

    statements                     shift and go to state 164
    assign                         shift and go to state 43
    function                       shift and go to state 44
    voidfunction                   shift and go to state 45
    call                           shift and go to state 46
    read                           shift and go to state 47
    print                          shift and go to state 48
    if                             shift and go to state 49
    while                          shift and go to state 50
    for                            shift and go to state 51
    funcesp                        shift and go to state 52
    var                            shift and go to state 53
    array                          shift and go to state 60
    matrix                         shift and go to state 61
    mean                           shift and go to state 62
    layers                         shift and go to state 63
    sequential                     shift and go to state 64
    compile                        shift and go to state 65
    fit                            shift and go to state 66
    predict                        shift and go to state 67
    getweights                     shift and go to state 68

state 142

    (75) for -> FOR LPAREN var SEMICOLON . exp SEMICOLON exp RPAREN LBRACKET statements forp
    (25) exp -> . texp
    (26) exp -> . texp OR exp
    (27) texp -> . gexp
    (28) texp -> . gexp AND texp
    (29) gexp -> . mexp
    (30) gexp -> . mexp gexpp mexp
    (35) mexp -> . t
    (36) mexp -> . t PLUS mexp
    (37) mexp -> . t MINUS mexp
    (38) t -> . f
    (39) t -> . f MULT t
    (40) t -> . f DIV t
    (41) f -> . LPAREN exp RPAREN
    (42) f -> . CTI
    (43) f -> . CTF
    (44) f -> . var
    (45) f -> . call
    (62) var -> . ID
    (63) call -> . ID LPAREN callp RPAREN

    LPAREN          shift and go to state 95
    CTI             shift and go to state 96
    CTF             shift and go to state 97
    ID              shift and go to state 99

    var                            shift and go to state 88
    exp                            shift and go to state 165
    texp                           shift and go to state 90
    gexp                           shift and go to state 91
    mexp                           shift and go to state 92
    t                              shift and go to state 93
    f                              shift and go to state 94
    call                           shift and go to state 98

state 143

    (105) getweights -> layers DOT GETWEIGHTS LPAREN . RPAREN

    RPAREN          shift and go to state 166


state 144

    (98) compile -> sequential DOT COMPILE LPAREN . RPAREN

    RPAREN          shift and go to state 167


state 145

    (93) mean -> MEAN LPAREN array RPAREN .

    VAR             reduce using rule 93 (mean -> MEAN LPAREN array RPAREN .)
    FUNCTION        reduce using rule 93 (mean -> MEAN LPAREN array RPAREN .)
    ID              reduce using rule 93 (mean -> MEAN LPAREN array RPAREN .)
    READ            reduce using rule 93 (mean -> MEAN LPAREN array RPAREN .)
    PRINT           reduce using rule 93 (mean -> MEAN LPAREN array RPAREN .)
    IF              reduce using rule 93 (mean -> MEAN LPAREN array RPAREN .)
    WHILE           reduce using rule 93 (mean -> MEAN LPAREN array RPAREN .)
    FOR             reduce using rule 93 (mean -> MEAN LPAREN array RPAREN .)
    MEAN            reduce using rule 93 (mean -> MEAN LPAREN array RPAREN .)
    RBRACE          reduce using rule 93 (mean -> MEAN LPAREN array RPAREN .)
    SEMICOLON       reduce using rule 93 (mean -> MEAN LPAREN array RPAREN .)
    RBRACKET        reduce using rule 93 (mean -> MEAN LPAREN array RPAREN .)


state 146

    (87) array -> ID EQUAL . ARRAY LPAREN var arrayp

    ARRAY           shift and go to state 103


state 147

    (26) exp -> texp OR exp .

    SEMICOLON       reduce using rule 26 (exp -> texp OR exp .)
    RPAREN          reduce using rule 26 (exp -> texp OR exp .)
    COMMA           reduce using rule 26 (exp -> texp OR exp .)


state 148

    (28) texp -> gexp AND texp .

    OR              reduce using rule 28 (texp -> gexp AND texp .)
    SEMICOLON       reduce using rule 28 (texp -> gexp AND texp .)
    RPAREN          reduce using rule 28 (texp -> gexp AND texp .)
    COMMA           reduce using rule 28 (texp -> gexp AND texp .)


state 149

    (30) gexp -> mexp gexpp mexp .

    AND             reduce using rule 30 (gexp -> mexp gexpp mexp .)
    OR              reduce using rule 30 (gexp -> mexp gexpp mexp .)
    SEMICOLON       reduce using rule 30 (gexp -> mexp gexpp mexp .)
    RPAREN          reduce using rule 30 (gexp -> mexp gexpp mexp .)
    COMMA           reduce using rule 30 (gexp -> mexp gexpp mexp .)


state 150

    (36) mexp -> t PLUS mexp .

    LT              reduce using rule 36 (mexp -> t PLUS mexp .)
    GT              reduce using rule 36 (mexp -> t PLUS mexp .)
    EQUAL           reduce using rule 36 (mexp -> t PLUS mexp .)
    DIFF            reduce using rule 36 (mexp -> t PLUS mexp .)
    AND             reduce using rule 36 (mexp -> t PLUS mexp .)
    OR              reduce using rule 36 (mexp -> t PLUS mexp .)
    SEMICOLON       reduce using rule 36 (mexp -> t PLUS mexp .)
    RPAREN          reduce using rule 36 (mexp -> t PLUS mexp .)
    COMMA           reduce using rule 36 (mexp -> t PLUS mexp .)


state 151

    (37) mexp -> t MINUS mexp .

    LT              reduce using rule 37 (mexp -> t MINUS mexp .)
    GT              reduce using rule 37 (mexp -> t MINUS mexp .)
    EQUAL           reduce using rule 37 (mexp -> t MINUS mexp .)
    DIFF            reduce using rule 37 (mexp -> t MINUS mexp .)
    AND             reduce using rule 37 (mexp -> t MINUS mexp .)
    OR              reduce using rule 37 (mexp -> t MINUS mexp .)
    SEMICOLON       reduce using rule 37 (mexp -> t MINUS mexp .)
    RPAREN          reduce using rule 37 (mexp -> t MINUS mexp .)
    COMMA           reduce using rule 37 (mexp -> t MINUS mexp .)


state 152

    (39) t -> f MULT t .

    PLUS            reduce using rule 39 (t -> f MULT t .)
    MINUS           reduce using rule 39 (t -> f MULT t .)
    LT              reduce using rule 39 (t -> f MULT t .)
    GT              reduce using rule 39 (t -> f MULT t .)
    EQUAL           reduce using rule 39 (t -> f MULT t .)
    DIFF            reduce using rule 39 (t -> f MULT t .)
    AND             reduce using rule 39 (t -> f MULT t .)
    OR              reduce using rule 39 (t -> f MULT t .)
    SEMICOLON       reduce using rule 39 (t -> f MULT t .)
    RPAREN          reduce using rule 39 (t -> f MULT t .)
    COMMA           reduce using rule 39 (t -> f MULT t .)


state 153

    (40) t -> f DIV t .

    PLUS            reduce using rule 40 (t -> f DIV t .)
    MINUS           reduce using rule 40 (t -> f DIV t .)
    LT              reduce using rule 40 (t -> f DIV t .)
    GT              reduce using rule 40 (t -> f DIV t .)
    EQUAL           reduce using rule 40 (t -> f DIV t .)
    DIFF            reduce using rule 40 (t -> f DIV t .)
    AND             reduce using rule 40 (t -> f DIV t .)
    OR              reduce using rule 40 (t -> f DIV t .)
    SEMICOLON       reduce using rule 40 (t -> f DIV t .)
    RPAREN          reduce using rule 40 (t -> f DIV t .)
    COMMA           reduce using rule 40 (t -> f DIV t .)


state 154

    (41) f -> LPAREN exp RPAREN .

    MULT            reduce using rule 41 (f -> LPAREN exp RPAREN .)
    DIV             reduce using rule 41 (f -> LPAREN exp RPAREN .)
    PLUS            reduce using rule 41 (f -> LPAREN exp RPAREN .)
    MINUS           reduce using rule 41 (f -> LPAREN exp RPAREN .)
    LT              reduce using rule 41 (f -> LPAREN exp RPAREN .)
    GT              reduce using rule 41 (f -> LPAREN exp RPAREN .)
    EQUAL           reduce using rule 41 (f -> LPAREN exp RPAREN .)
    DIFF            reduce using rule 41 (f -> LPAREN exp RPAREN .)
    AND             reduce using rule 41 (f -> LPAREN exp RPAREN .)
    OR              reduce using rule 41 (f -> LPAREN exp RPAREN .)
    SEMICOLON       reduce using rule 41 (f -> LPAREN exp RPAREN .)
    RPAREN          reduce using rule 41 (f -> LPAREN exp RPAREN .)
    COMMA           reduce using rule 41 (f -> LPAREN exp RPAREN .)


state 155

    (64) callp -> exp SEMICOLON callp .

    RPAREN          reduce using rule 64 (callp -> exp SEMICOLON callp .)


state 156

    (87) array -> ID EQUAL ARRAY LPAREN var . arrayp
    (88) arrayp -> . RPAREN
    (89) arrayp -> . COMMA var RPAREN

    RPAREN          shift and go to state 169
    COMMA           shift and go to state 170

    arrayp                         shift and go to state 168

state 157

    (90) matrix -> ID EQUAL MATRIX LPAREN array . matrixp
    (91) matrixp -> . RPAREN
    (92) matrixp -> . COMMA array RPAREN

    RPAREN          shift and go to state 172
    COMMA           shift and go to state 173

    matrixp                        shift and go to state 171

state 158

    (94) layers -> ID EQUAL LAYERS LPAREN UNITS . EQUAL INT RPAREN

    EQUAL           shift and go to state 174


state 159

    (95) sequential -> ID EQUAL SEQUENTIAL LPAREN LBRACKET . layers sequentialp
    (94) layers -> . ID EQUAL LAYERS LPAREN UNITS EQUAL INT RPAREN

    ID              shift and go to state 175

    layers                         shift and go to state 176

state 160

    (99) fit -> ID EQUAL sequential DOT FIT . LPAREN array COMMA array COMMA EPOCHS EQUAL INT COMMA VERBOSE EQUAL fitp

    LPAREN          shift and go to state 177


state 161

    (102) predict -> ID EQUAL sequential DOT PREDICT . LPAREN LBRACKET predictp

    LPAREN          shift and go to state 178


state 162

    (61) printp -> exp COMMA printp .

    VAR             reduce using rule 61 (printp -> exp COMMA printp .)
    FUNCTION        reduce using rule 61 (printp -> exp COMMA printp .)
    ID              reduce using rule 61 (printp -> exp COMMA printp .)
    READ            reduce using rule 61 (printp -> exp COMMA printp .)
    PRINT           reduce using rule 61 (printp -> exp COMMA printp .)
    IF              reduce using rule 61 (printp -> exp COMMA printp .)
    WHILE           reduce using rule 61 (printp -> exp COMMA printp .)
    FOR             reduce using rule 61 (printp -> exp COMMA printp .)
    MEAN            reduce using rule 61 (printp -> exp COMMA printp .)
    RBRACE          reduce using rule 61 (printp -> exp COMMA printp .)
    SEMICOLON       reduce using rule 61 (printp -> exp COMMA printp .)
    RBRACKET        reduce using rule 61 (printp -> exp COMMA printp .)


state 163

    (66) if -> IF LPAREN CTI GT CTI . RPAREN quadsIf ifp jumpsIf

    RPAREN          shift and go to state 179


state 164

    (72) while -> WHILE LPAREN exp RPAREN statements . whilep
    (73) whilep -> . SEMICOLON
    (74) whilep -> . statements whilep
    (46) statements -> . assign
    (47) statements -> . function
    (48) statements -> . voidfunction
    (49) statements -> . call
    (50) statements -> . read
    (51) statements -> . print
    (52) statements -> . if
    (53) statements -> . while
    (54) statements -> . for
    (55) statements -> . funcesp
    (56) statements -> .
    (57) assign -> . var EQUAL exp SEMICOLON
    (10) function -> . FUNCTION type decfunc LPAREN param RPAREN LBRACE body RBRACE
    (12) voidfunction -> . FUNCTION VOID decfunc LPAREN param RPAREN LBRACE body RBRACE
    (63) call -> . ID LPAREN callp RPAREN
    (58) read -> . READ var
    (59) print -> . PRINT LPAREN printp
    (66) if -> . IF LPAREN CTI GT CTI RPAREN quadsIf ifp jumpsIf
    (72) while -> . WHILE LPAREN exp RPAREN statements whilep
    (75) for -> . FOR LPAREN var SEMICOLON exp SEMICOLON exp RPAREN LBRACKET statements forp
    (78) funcesp -> . array
    (79) funcesp -> . matrix
    (80) funcesp -> . mean
    (81) funcesp -> . layers
    (82) funcesp -> . sequential
    (83) funcesp -> . compile
    (84) funcesp -> . fit
    (85) funcesp -> . predict
    (86) funcesp -> . getweights
    (62) var -> . ID
    (87) array -> . ID EQUAL ARRAY LPAREN var arrayp
    (90) matrix -> . ID EQUAL MATRIX LPAREN array matrixp
    (93) mean -> . MEAN LPAREN array RPAREN
    (94) layers -> . ID EQUAL LAYERS LPAREN UNITS EQUAL INT RPAREN
    (95) sequential -> . ID EQUAL SEQUENTIAL LPAREN LBRACKET layers sequentialp
    (98) compile -> . sequential DOT COMPILE LPAREN RPAREN
    (99) fit -> . ID EQUAL sequential DOT FIT LPAREN array COMMA array COMMA EPOCHS EQUAL INT COMMA VERBOSE EQUAL fitp
    (102) predict -> . ID EQUAL sequential DOT PREDICT LPAREN LBRACKET predictp
    (105) getweights -> . layers DOT GETWEIGHTS LPAREN RPAREN

  ! shift/reduce conflict for SEMICOLON resolved as shift
  ! shift/reduce conflict for FUNCTION resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for READ resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for MEAN resolved as shift
    SEMICOLON       shift and go to state 182
    FUNCTION        shift and go to state 10
    ID              shift and go to state 54
    READ            shift and go to state 55
    PRINT           shift and go to state 56
    IF              shift and go to state 57
    WHILE           shift and go to state 58
    FOR             shift and go to state 59
    MEAN            shift and go to state 69

  ! SEMICOLON       [ reduce using rule 56 (statements -> .) ]
  ! FUNCTION        [ reduce using rule 56 (statements -> .) ]
  ! ID              [ reduce using rule 56 (statements -> .) ]
  ! READ            [ reduce using rule 56 (statements -> .) ]
  ! PRINT           [ reduce using rule 56 (statements -> .) ]
  ! IF              [ reduce using rule 56 (statements -> .) ]
  ! WHILE           [ reduce using rule 56 (statements -> .) ]
  ! FOR             [ reduce using rule 56 (statements -> .) ]
  ! MEAN            [ reduce using rule 56 (statements -> .) ]

    statements                     shift and go to state 180
    whilep                         shift and go to state 181
    assign                         shift and go to state 43
    function                       shift and go to state 44
    voidfunction                   shift and go to state 45
    call                           shift and go to state 46
    read                           shift and go to state 47
    print                          shift and go to state 48
    if                             shift and go to state 49
    while                          shift and go to state 50
    for                            shift and go to state 51
    funcesp                        shift and go to state 52
    var                            shift and go to state 53
    array                          shift and go to state 60
    matrix                         shift and go to state 61
    mean                           shift and go to state 62
    layers                         shift and go to state 63
    sequential                     shift and go to state 64
    compile                        shift and go to state 65
    fit                            shift and go to state 66
    predict                        shift and go to state 67
    getweights                     shift and go to state 68

state 165

    (75) for -> FOR LPAREN var SEMICOLON exp . SEMICOLON exp RPAREN LBRACKET statements forp

    SEMICOLON       shift and go to state 183


state 166

    (105) getweights -> layers DOT GETWEIGHTS LPAREN RPAREN .

    VAR             reduce using rule 105 (getweights -> layers DOT GETWEIGHTS LPAREN RPAREN .)
    FUNCTION        reduce using rule 105 (getweights -> layers DOT GETWEIGHTS LPAREN RPAREN .)
    ID              reduce using rule 105 (getweights -> layers DOT GETWEIGHTS LPAREN RPAREN .)
    READ            reduce using rule 105 (getweights -> layers DOT GETWEIGHTS LPAREN RPAREN .)
    PRINT           reduce using rule 105 (getweights -> layers DOT GETWEIGHTS LPAREN RPAREN .)
    IF              reduce using rule 105 (getweights -> layers DOT GETWEIGHTS LPAREN RPAREN .)
    WHILE           reduce using rule 105 (getweights -> layers DOT GETWEIGHTS LPAREN RPAREN .)
    FOR             reduce using rule 105 (getweights -> layers DOT GETWEIGHTS LPAREN RPAREN .)
    MEAN            reduce using rule 105 (getweights -> layers DOT GETWEIGHTS LPAREN RPAREN .)
    RBRACE          reduce using rule 105 (getweights -> layers DOT GETWEIGHTS LPAREN RPAREN .)
    SEMICOLON       reduce using rule 105 (getweights -> layers DOT GETWEIGHTS LPAREN RPAREN .)
    RBRACKET        reduce using rule 105 (getweights -> layers DOT GETWEIGHTS LPAREN RPAREN .)


state 167

    (98) compile -> sequential DOT COMPILE LPAREN RPAREN .

    VAR             reduce using rule 98 (compile -> sequential DOT COMPILE LPAREN RPAREN .)
    FUNCTION        reduce using rule 98 (compile -> sequential DOT COMPILE LPAREN RPAREN .)
    ID              reduce using rule 98 (compile -> sequential DOT COMPILE LPAREN RPAREN .)
    READ            reduce using rule 98 (compile -> sequential DOT COMPILE LPAREN RPAREN .)
    PRINT           reduce using rule 98 (compile -> sequential DOT COMPILE LPAREN RPAREN .)
    IF              reduce using rule 98 (compile -> sequential DOT COMPILE LPAREN RPAREN .)
    WHILE           reduce using rule 98 (compile -> sequential DOT COMPILE LPAREN RPAREN .)
    FOR             reduce using rule 98 (compile -> sequential DOT COMPILE LPAREN RPAREN .)
    MEAN            reduce using rule 98 (compile -> sequential DOT COMPILE LPAREN RPAREN .)
    RBRACE          reduce using rule 98 (compile -> sequential DOT COMPILE LPAREN RPAREN .)
    SEMICOLON       reduce using rule 98 (compile -> sequential DOT COMPILE LPAREN RPAREN .)
    RBRACKET        reduce using rule 98 (compile -> sequential DOT COMPILE LPAREN RPAREN .)


state 168

    (87) array -> ID EQUAL ARRAY LPAREN var arrayp .

    VAR             reduce using rule 87 (array -> ID EQUAL ARRAY LPAREN var arrayp .)
    FUNCTION        reduce using rule 87 (array -> ID EQUAL ARRAY LPAREN var arrayp .)
    ID              reduce using rule 87 (array -> ID EQUAL ARRAY LPAREN var arrayp .)
    READ            reduce using rule 87 (array -> ID EQUAL ARRAY LPAREN var arrayp .)
    PRINT           reduce using rule 87 (array -> ID EQUAL ARRAY LPAREN var arrayp .)
    IF              reduce using rule 87 (array -> ID EQUAL ARRAY LPAREN var arrayp .)
    WHILE           reduce using rule 87 (array -> ID EQUAL ARRAY LPAREN var arrayp .)
    FOR             reduce using rule 87 (array -> ID EQUAL ARRAY LPAREN var arrayp .)
    MEAN            reduce using rule 87 (array -> ID EQUAL ARRAY LPAREN var arrayp .)
    RBRACE          reduce using rule 87 (array -> ID EQUAL ARRAY LPAREN var arrayp .)
    RPAREN          reduce using rule 87 (array -> ID EQUAL ARRAY LPAREN var arrayp .)
    COMMA           reduce using rule 87 (array -> ID EQUAL ARRAY LPAREN var arrayp .)
    SEMICOLON       reduce using rule 87 (array -> ID EQUAL ARRAY LPAREN var arrayp .)
    RBRACKET        reduce using rule 87 (array -> ID EQUAL ARRAY LPAREN var arrayp .)


state 169

    (88) arrayp -> RPAREN .

    VAR             reduce using rule 88 (arrayp -> RPAREN .)
    FUNCTION        reduce using rule 88 (arrayp -> RPAREN .)
    ID              reduce using rule 88 (arrayp -> RPAREN .)
    READ            reduce using rule 88 (arrayp -> RPAREN .)
    PRINT           reduce using rule 88 (arrayp -> RPAREN .)
    IF              reduce using rule 88 (arrayp -> RPAREN .)
    WHILE           reduce using rule 88 (arrayp -> RPAREN .)
    FOR             reduce using rule 88 (arrayp -> RPAREN .)
    MEAN            reduce using rule 88 (arrayp -> RPAREN .)
    RBRACE          reduce using rule 88 (arrayp -> RPAREN .)
    RPAREN          reduce using rule 88 (arrayp -> RPAREN .)
    COMMA           reduce using rule 88 (arrayp -> RPAREN .)
    SEMICOLON       reduce using rule 88 (arrayp -> RPAREN .)
    RBRACKET        reduce using rule 88 (arrayp -> RPAREN .)


state 170

    (89) arrayp -> COMMA . var RPAREN
    (62) var -> . ID

    ID              shift and go to state 78

    var                            shift and go to state 184

state 171

    (90) matrix -> ID EQUAL MATRIX LPAREN array matrixp .

    VAR             reduce using rule 90 (matrix -> ID EQUAL MATRIX LPAREN array matrixp .)
    FUNCTION        reduce using rule 90 (matrix -> ID EQUAL MATRIX LPAREN array matrixp .)
    ID              reduce using rule 90 (matrix -> ID EQUAL MATRIX LPAREN array matrixp .)
    READ            reduce using rule 90 (matrix -> ID EQUAL MATRIX LPAREN array matrixp .)
    PRINT           reduce using rule 90 (matrix -> ID EQUAL MATRIX LPAREN array matrixp .)
    IF              reduce using rule 90 (matrix -> ID EQUAL MATRIX LPAREN array matrixp .)
    WHILE           reduce using rule 90 (matrix -> ID EQUAL MATRIX LPAREN array matrixp .)
    FOR             reduce using rule 90 (matrix -> ID EQUAL MATRIX LPAREN array matrixp .)
    MEAN            reduce using rule 90 (matrix -> ID EQUAL MATRIX LPAREN array matrixp .)
    RBRACE          reduce using rule 90 (matrix -> ID EQUAL MATRIX LPAREN array matrixp .)
    SEMICOLON       reduce using rule 90 (matrix -> ID EQUAL MATRIX LPAREN array matrixp .)
    RBRACKET        reduce using rule 90 (matrix -> ID EQUAL MATRIX LPAREN array matrixp .)


state 172

    (91) matrixp -> RPAREN .

    VAR             reduce using rule 91 (matrixp -> RPAREN .)
    FUNCTION        reduce using rule 91 (matrixp -> RPAREN .)
    ID              reduce using rule 91 (matrixp -> RPAREN .)
    READ            reduce using rule 91 (matrixp -> RPAREN .)
    PRINT           reduce using rule 91 (matrixp -> RPAREN .)
    IF              reduce using rule 91 (matrixp -> RPAREN .)
    WHILE           reduce using rule 91 (matrixp -> RPAREN .)
    FOR             reduce using rule 91 (matrixp -> RPAREN .)
    MEAN            reduce using rule 91 (matrixp -> RPAREN .)
    RBRACE          reduce using rule 91 (matrixp -> RPAREN .)
    SEMICOLON       reduce using rule 91 (matrixp -> RPAREN .)
    RBRACKET        reduce using rule 91 (matrixp -> RPAREN .)


state 173

    (92) matrixp -> COMMA . array RPAREN
    (87) array -> . ID EQUAL ARRAY LPAREN var arrayp

    ID              shift and go to state 116

    array                          shift and go to state 185

state 174

    (94) layers -> ID EQUAL LAYERS LPAREN UNITS EQUAL . INT RPAREN

    INT             shift and go to state 186


state 175

    (94) layers -> ID . EQUAL LAYERS LPAREN UNITS EQUAL INT RPAREN

    EQUAL           shift and go to state 187


state 176

    (95) sequential -> ID EQUAL SEQUENTIAL LPAREN LBRACKET layers . sequentialp
    (96) sequentialp -> . RBRACKET RPAREN
    (97) sequentialp -> . COMMA layers sequentialp

    RBRACKET        shift and go to state 189
    COMMA           shift and go to state 190

    sequentialp                    shift and go to state 188

state 177

    (99) fit -> ID EQUAL sequential DOT FIT LPAREN . array COMMA array COMMA EPOCHS EQUAL INT COMMA VERBOSE EQUAL fitp
    (87) array -> . ID EQUAL ARRAY LPAREN var arrayp

    ID              shift and go to state 116

    array                          shift and go to state 191

state 178

    (102) predict -> ID EQUAL sequential DOT PREDICT LPAREN . LBRACKET predictp

    LBRACKET        shift and go to state 192


state 179

    (66) if -> IF LPAREN CTI GT CTI RPAREN . quadsIf ifp jumpsIf
    (69) quadsIf -> .

    ELSE            reduce using rule 69 (quadsIf -> .)
    VAR             reduce using rule 69 (quadsIf -> .)
    FUNCTION        reduce using rule 69 (quadsIf -> .)
    ID              reduce using rule 69 (quadsIf -> .)
    READ            reduce using rule 69 (quadsIf -> .)
    PRINT           reduce using rule 69 (quadsIf -> .)
    IF              reduce using rule 69 (quadsIf -> .)
    WHILE           reduce using rule 69 (quadsIf -> .)
    FOR             reduce using rule 69 (quadsIf -> .)
    MEAN            reduce using rule 69 (quadsIf -> .)
    RBRACE          reduce using rule 69 (quadsIf -> .)
    SEMICOLON       reduce using rule 69 (quadsIf -> .)
    RBRACKET        reduce using rule 69 (quadsIf -> .)

    quadsIf                        shift and go to state 193

state 180

    (74) whilep -> statements . whilep
    (73) whilep -> . SEMICOLON
    (74) whilep -> . statements whilep
    (46) statements -> . assign
    (47) statements -> . function
    (48) statements -> . voidfunction
    (49) statements -> . call
    (50) statements -> . read
    (51) statements -> . print
    (52) statements -> . if
    (53) statements -> . while
    (54) statements -> . for
    (55) statements -> . funcesp
    (56) statements -> .
    (57) assign -> . var EQUAL exp SEMICOLON
    (10) function -> . FUNCTION type decfunc LPAREN param RPAREN LBRACE body RBRACE
    (12) voidfunction -> . FUNCTION VOID decfunc LPAREN param RPAREN LBRACE body RBRACE
    (63) call -> . ID LPAREN callp RPAREN
    (58) read -> . READ var
    (59) print -> . PRINT LPAREN printp
    (66) if -> . IF LPAREN CTI GT CTI RPAREN quadsIf ifp jumpsIf
    (72) while -> . WHILE LPAREN exp RPAREN statements whilep
    (75) for -> . FOR LPAREN var SEMICOLON exp SEMICOLON exp RPAREN LBRACKET statements forp
    (78) funcesp -> . array
    (79) funcesp -> . matrix
    (80) funcesp -> . mean
    (81) funcesp -> . layers
    (82) funcesp -> . sequential
    (83) funcesp -> . compile
    (84) funcesp -> . fit
    (85) funcesp -> . predict
    (86) funcesp -> . getweights
    (62) var -> . ID
    (87) array -> . ID EQUAL ARRAY LPAREN var arrayp
    (90) matrix -> . ID EQUAL MATRIX LPAREN array matrixp
    (93) mean -> . MEAN LPAREN array RPAREN
    (94) layers -> . ID EQUAL LAYERS LPAREN UNITS EQUAL INT RPAREN
    (95) sequential -> . ID EQUAL SEQUENTIAL LPAREN LBRACKET layers sequentialp
    (98) compile -> . sequential DOT COMPILE LPAREN RPAREN
    (99) fit -> . ID EQUAL sequential DOT FIT LPAREN array COMMA array COMMA EPOCHS EQUAL INT COMMA VERBOSE EQUAL fitp
    (102) predict -> . ID EQUAL sequential DOT PREDICT LPAREN LBRACKET predictp
    (105) getweights -> . layers DOT GETWEIGHTS LPAREN RPAREN

  ! shift/reduce conflict for SEMICOLON resolved as shift
  ! shift/reduce conflict for FUNCTION resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for READ resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for MEAN resolved as shift
    SEMICOLON       shift and go to state 182
    FUNCTION        shift and go to state 10
    ID              shift and go to state 54
    READ            shift and go to state 55
    PRINT           shift and go to state 56
    IF              shift and go to state 57
    WHILE           shift and go to state 58
    FOR             shift and go to state 59
    MEAN            shift and go to state 69

  ! SEMICOLON       [ reduce using rule 56 (statements -> .) ]
  ! FUNCTION        [ reduce using rule 56 (statements -> .) ]
  ! ID              [ reduce using rule 56 (statements -> .) ]
  ! READ            [ reduce using rule 56 (statements -> .) ]
  ! PRINT           [ reduce using rule 56 (statements -> .) ]
  ! IF              [ reduce using rule 56 (statements -> .) ]
  ! WHILE           [ reduce using rule 56 (statements -> .) ]
  ! FOR             [ reduce using rule 56 (statements -> .) ]
  ! MEAN            [ reduce using rule 56 (statements -> .) ]

    statements                     shift and go to state 180
    whilep                         shift and go to state 194
    assign                         shift and go to state 43
    function                       shift and go to state 44
    voidfunction                   shift and go to state 45
    call                           shift and go to state 46
    read                           shift and go to state 47
    print                          shift and go to state 48
    if                             shift and go to state 49
    while                          shift and go to state 50
    for                            shift and go to state 51
    funcesp                        shift and go to state 52
    var                            shift and go to state 53
    array                          shift and go to state 60
    matrix                         shift and go to state 61
    mean                           shift and go to state 62
    layers                         shift and go to state 63
    sequential                     shift and go to state 64
    compile                        shift and go to state 65
    fit                            shift and go to state 66
    predict                        shift and go to state 67
    getweights                     shift and go to state 68

state 181

    (72) while -> WHILE LPAREN exp RPAREN statements whilep .

    VAR             reduce using rule 72 (while -> WHILE LPAREN exp RPAREN statements whilep .)
    FUNCTION        reduce using rule 72 (while -> WHILE LPAREN exp RPAREN statements whilep .)
    ID              reduce using rule 72 (while -> WHILE LPAREN exp RPAREN statements whilep .)
    READ            reduce using rule 72 (while -> WHILE LPAREN exp RPAREN statements whilep .)
    PRINT           reduce using rule 72 (while -> WHILE LPAREN exp RPAREN statements whilep .)
    IF              reduce using rule 72 (while -> WHILE LPAREN exp RPAREN statements whilep .)
    WHILE           reduce using rule 72 (while -> WHILE LPAREN exp RPAREN statements whilep .)
    FOR             reduce using rule 72 (while -> WHILE LPAREN exp RPAREN statements whilep .)
    MEAN            reduce using rule 72 (while -> WHILE LPAREN exp RPAREN statements whilep .)
    RBRACE          reduce using rule 72 (while -> WHILE LPAREN exp RPAREN statements whilep .)
    SEMICOLON       reduce using rule 72 (while -> WHILE LPAREN exp RPAREN statements whilep .)
    RBRACKET        reduce using rule 72 (while -> WHILE LPAREN exp RPAREN statements whilep .)


state 182

    (73) whilep -> SEMICOLON .

    VAR             reduce using rule 73 (whilep -> SEMICOLON .)
    FUNCTION        reduce using rule 73 (whilep -> SEMICOLON .)
    ID              reduce using rule 73 (whilep -> SEMICOLON .)
    READ            reduce using rule 73 (whilep -> SEMICOLON .)
    PRINT           reduce using rule 73 (whilep -> SEMICOLON .)
    IF              reduce using rule 73 (whilep -> SEMICOLON .)
    WHILE           reduce using rule 73 (whilep -> SEMICOLON .)
    FOR             reduce using rule 73 (whilep -> SEMICOLON .)
    MEAN            reduce using rule 73 (whilep -> SEMICOLON .)
    RBRACE          reduce using rule 73 (whilep -> SEMICOLON .)
    SEMICOLON       reduce using rule 73 (whilep -> SEMICOLON .)
    RBRACKET        reduce using rule 73 (whilep -> SEMICOLON .)


state 183

    (75) for -> FOR LPAREN var SEMICOLON exp SEMICOLON . exp RPAREN LBRACKET statements forp
    (25) exp -> . texp
    (26) exp -> . texp OR exp
    (27) texp -> . gexp
    (28) texp -> . gexp AND texp
    (29) gexp -> . mexp
    (30) gexp -> . mexp gexpp mexp
    (35) mexp -> . t
    (36) mexp -> . t PLUS mexp
    (37) mexp -> . t MINUS mexp
    (38) t -> . f
    (39) t -> . f MULT t
    (40) t -> . f DIV t
    (41) f -> . LPAREN exp RPAREN
    (42) f -> . CTI
    (43) f -> . CTF
    (44) f -> . var
    (45) f -> . call
    (62) var -> . ID
    (63) call -> . ID LPAREN callp RPAREN

    LPAREN          shift and go to state 95
    CTI             shift and go to state 96
    CTF             shift and go to state 97
    ID              shift and go to state 99

    var                            shift and go to state 88
    exp                            shift and go to state 195
    texp                           shift and go to state 90
    gexp                           shift and go to state 91
    mexp                           shift and go to state 92
    t                              shift and go to state 93
    f                              shift and go to state 94
    call                           shift and go to state 98

state 184

    (89) arrayp -> COMMA var . RPAREN

    RPAREN          shift and go to state 196


state 185

    (92) matrixp -> COMMA array . RPAREN

    RPAREN          shift and go to state 197


state 186

    (94) layers -> ID EQUAL LAYERS LPAREN UNITS EQUAL INT . RPAREN

    RPAREN          shift and go to state 198


state 187

    (94) layers -> ID EQUAL . LAYERS LPAREN UNITS EQUAL INT RPAREN

    LAYERS          shift and go to state 105


state 188

    (95) sequential -> ID EQUAL SEQUENTIAL LPAREN LBRACKET layers sequentialp .

    DOT             reduce using rule 95 (sequential -> ID EQUAL SEQUENTIAL LPAREN LBRACKET layers sequentialp .)
    VAR             reduce using rule 95 (sequential -> ID EQUAL SEQUENTIAL LPAREN LBRACKET layers sequentialp .)
    FUNCTION        reduce using rule 95 (sequential -> ID EQUAL SEQUENTIAL LPAREN LBRACKET layers sequentialp .)
    ID              reduce using rule 95 (sequential -> ID EQUAL SEQUENTIAL LPAREN LBRACKET layers sequentialp .)
    READ            reduce using rule 95 (sequential -> ID EQUAL SEQUENTIAL LPAREN LBRACKET layers sequentialp .)
    PRINT           reduce using rule 95 (sequential -> ID EQUAL SEQUENTIAL LPAREN LBRACKET layers sequentialp .)
    IF              reduce using rule 95 (sequential -> ID EQUAL SEQUENTIAL LPAREN LBRACKET layers sequentialp .)
    WHILE           reduce using rule 95 (sequential -> ID EQUAL SEQUENTIAL LPAREN LBRACKET layers sequentialp .)
    FOR             reduce using rule 95 (sequential -> ID EQUAL SEQUENTIAL LPAREN LBRACKET layers sequentialp .)
    MEAN            reduce using rule 95 (sequential -> ID EQUAL SEQUENTIAL LPAREN LBRACKET layers sequentialp .)
    RBRACE          reduce using rule 95 (sequential -> ID EQUAL SEQUENTIAL LPAREN LBRACKET layers sequentialp .)
    SEMICOLON       reduce using rule 95 (sequential -> ID EQUAL SEQUENTIAL LPAREN LBRACKET layers sequentialp .)
    RBRACKET        reduce using rule 95 (sequential -> ID EQUAL SEQUENTIAL LPAREN LBRACKET layers sequentialp .)


state 189

    (96) sequentialp -> RBRACKET . RPAREN

    RPAREN          shift and go to state 199


state 190

    (97) sequentialp -> COMMA . layers sequentialp
    (94) layers -> . ID EQUAL LAYERS LPAREN UNITS EQUAL INT RPAREN

    ID              shift and go to state 175

    layers                         shift and go to state 200

state 191

    (99) fit -> ID EQUAL sequential DOT FIT LPAREN array . COMMA array COMMA EPOCHS EQUAL INT COMMA VERBOSE EQUAL fitp

    COMMA           shift and go to state 201


state 192

    (102) predict -> ID EQUAL sequential DOT PREDICT LPAREN LBRACKET . predictp
    (103) predictp -> . INT RBRACKET RPAREN
    (104) predictp -> . FLOAT RBRACKET RPAREN

    INT             shift and go to state 203
    FLOAT           shift and go to state 204

    predictp                       shift and go to state 202

state 193

    (66) if -> IF LPAREN CTI GT CTI RPAREN quadsIf . ifp jumpsIf
    (67) ifp -> .
    (68) ifp -> . ELSE quadsElse statements

    VAR             reduce using rule 67 (ifp -> .)
    FUNCTION        reduce using rule 67 (ifp -> .)
    ID              reduce using rule 67 (ifp -> .)
    READ            reduce using rule 67 (ifp -> .)
    PRINT           reduce using rule 67 (ifp -> .)
    IF              reduce using rule 67 (ifp -> .)
    WHILE           reduce using rule 67 (ifp -> .)
    FOR             reduce using rule 67 (ifp -> .)
    MEAN            reduce using rule 67 (ifp -> .)
    RBRACE          reduce using rule 67 (ifp -> .)
    SEMICOLON       reduce using rule 67 (ifp -> .)
    RBRACKET        reduce using rule 67 (ifp -> .)
    ELSE            shift and go to state 206

    ifp                            shift and go to state 205

state 194

    (74) whilep -> statements whilep .

    VAR             reduce using rule 74 (whilep -> statements whilep .)
    FUNCTION        reduce using rule 74 (whilep -> statements whilep .)
    ID              reduce using rule 74 (whilep -> statements whilep .)
    READ            reduce using rule 74 (whilep -> statements whilep .)
    PRINT           reduce using rule 74 (whilep -> statements whilep .)
    IF              reduce using rule 74 (whilep -> statements whilep .)
    WHILE           reduce using rule 74 (whilep -> statements whilep .)
    FOR             reduce using rule 74 (whilep -> statements whilep .)
    MEAN            reduce using rule 74 (whilep -> statements whilep .)
    RBRACE          reduce using rule 74 (whilep -> statements whilep .)
    SEMICOLON       reduce using rule 74 (whilep -> statements whilep .)
    RBRACKET        reduce using rule 74 (whilep -> statements whilep .)


state 195

    (75) for -> FOR LPAREN var SEMICOLON exp SEMICOLON exp . RPAREN LBRACKET statements forp

    RPAREN          shift and go to state 207


state 196

    (89) arrayp -> COMMA var RPAREN .

    VAR             reduce using rule 89 (arrayp -> COMMA var RPAREN .)
    FUNCTION        reduce using rule 89 (arrayp -> COMMA var RPAREN .)
    ID              reduce using rule 89 (arrayp -> COMMA var RPAREN .)
    READ            reduce using rule 89 (arrayp -> COMMA var RPAREN .)
    PRINT           reduce using rule 89 (arrayp -> COMMA var RPAREN .)
    IF              reduce using rule 89 (arrayp -> COMMA var RPAREN .)
    WHILE           reduce using rule 89 (arrayp -> COMMA var RPAREN .)
    FOR             reduce using rule 89 (arrayp -> COMMA var RPAREN .)
    MEAN            reduce using rule 89 (arrayp -> COMMA var RPAREN .)
    RBRACE          reduce using rule 89 (arrayp -> COMMA var RPAREN .)
    RPAREN          reduce using rule 89 (arrayp -> COMMA var RPAREN .)
    COMMA           reduce using rule 89 (arrayp -> COMMA var RPAREN .)
    SEMICOLON       reduce using rule 89 (arrayp -> COMMA var RPAREN .)
    RBRACKET        reduce using rule 89 (arrayp -> COMMA var RPAREN .)


state 197

    (92) matrixp -> COMMA array RPAREN .

    VAR             reduce using rule 92 (matrixp -> COMMA array RPAREN .)
    FUNCTION        reduce using rule 92 (matrixp -> COMMA array RPAREN .)
    ID              reduce using rule 92 (matrixp -> COMMA array RPAREN .)
    READ            reduce using rule 92 (matrixp -> COMMA array RPAREN .)
    PRINT           reduce using rule 92 (matrixp -> COMMA array RPAREN .)
    IF              reduce using rule 92 (matrixp -> COMMA array RPAREN .)
    WHILE           reduce using rule 92 (matrixp -> COMMA array RPAREN .)
    FOR             reduce using rule 92 (matrixp -> COMMA array RPAREN .)
    MEAN            reduce using rule 92 (matrixp -> COMMA array RPAREN .)
    RBRACE          reduce using rule 92 (matrixp -> COMMA array RPAREN .)
    SEMICOLON       reduce using rule 92 (matrixp -> COMMA array RPAREN .)
    RBRACKET        reduce using rule 92 (matrixp -> COMMA array RPAREN .)


state 198

    (94) layers -> ID EQUAL LAYERS LPAREN UNITS EQUAL INT RPAREN .

    DOT             reduce using rule 94 (layers -> ID EQUAL LAYERS LPAREN UNITS EQUAL INT RPAREN .)
    VAR             reduce using rule 94 (layers -> ID EQUAL LAYERS LPAREN UNITS EQUAL INT RPAREN .)
    FUNCTION        reduce using rule 94 (layers -> ID EQUAL LAYERS LPAREN UNITS EQUAL INT RPAREN .)
    ID              reduce using rule 94 (layers -> ID EQUAL LAYERS LPAREN UNITS EQUAL INT RPAREN .)
    READ            reduce using rule 94 (layers -> ID EQUAL LAYERS LPAREN UNITS EQUAL INT RPAREN .)
    PRINT           reduce using rule 94 (layers -> ID EQUAL LAYERS LPAREN UNITS EQUAL INT RPAREN .)
    IF              reduce using rule 94 (layers -> ID EQUAL LAYERS LPAREN UNITS EQUAL INT RPAREN .)
    WHILE           reduce using rule 94 (layers -> ID EQUAL LAYERS LPAREN UNITS EQUAL INT RPAREN .)
    FOR             reduce using rule 94 (layers -> ID EQUAL LAYERS LPAREN UNITS EQUAL INT RPAREN .)
    MEAN            reduce using rule 94 (layers -> ID EQUAL LAYERS LPAREN UNITS EQUAL INT RPAREN .)
    RBRACE          reduce using rule 94 (layers -> ID EQUAL LAYERS LPAREN UNITS EQUAL INT RPAREN .)
    SEMICOLON       reduce using rule 94 (layers -> ID EQUAL LAYERS LPAREN UNITS EQUAL INT RPAREN .)
    RBRACKET        reduce using rule 94 (layers -> ID EQUAL LAYERS LPAREN UNITS EQUAL INT RPAREN .)
    COMMA           reduce using rule 94 (layers -> ID EQUAL LAYERS LPAREN UNITS EQUAL INT RPAREN .)


state 199

    (96) sequentialp -> RBRACKET RPAREN .

    DOT             reduce using rule 96 (sequentialp -> RBRACKET RPAREN .)
    VAR             reduce using rule 96 (sequentialp -> RBRACKET RPAREN .)
    FUNCTION        reduce using rule 96 (sequentialp -> RBRACKET RPAREN .)
    ID              reduce using rule 96 (sequentialp -> RBRACKET RPAREN .)
    READ            reduce using rule 96 (sequentialp -> RBRACKET RPAREN .)
    PRINT           reduce using rule 96 (sequentialp -> RBRACKET RPAREN .)
    IF              reduce using rule 96 (sequentialp -> RBRACKET RPAREN .)
    WHILE           reduce using rule 96 (sequentialp -> RBRACKET RPAREN .)
    FOR             reduce using rule 96 (sequentialp -> RBRACKET RPAREN .)
    MEAN            reduce using rule 96 (sequentialp -> RBRACKET RPAREN .)
    RBRACE          reduce using rule 96 (sequentialp -> RBRACKET RPAREN .)
    SEMICOLON       reduce using rule 96 (sequentialp -> RBRACKET RPAREN .)
    RBRACKET        reduce using rule 96 (sequentialp -> RBRACKET RPAREN .)


state 200

    (97) sequentialp -> COMMA layers . sequentialp
    (96) sequentialp -> . RBRACKET RPAREN
    (97) sequentialp -> . COMMA layers sequentialp

    RBRACKET        shift and go to state 189
    COMMA           shift and go to state 190

    sequentialp                    shift and go to state 208

state 201

    (99) fit -> ID EQUAL sequential DOT FIT LPAREN array COMMA . array COMMA EPOCHS EQUAL INT COMMA VERBOSE EQUAL fitp
    (87) array -> . ID EQUAL ARRAY LPAREN var arrayp

    ID              shift and go to state 116

    array                          shift and go to state 209

state 202

    (102) predict -> ID EQUAL sequential DOT PREDICT LPAREN LBRACKET predictp .

    VAR             reduce using rule 102 (predict -> ID EQUAL sequential DOT PREDICT LPAREN LBRACKET predictp .)
    FUNCTION        reduce using rule 102 (predict -> ID EQUAL sequential DOT PREDICT LPAREN LBRACKET predictp .)
    ID              reduce using rule 102 (predict -> ID EQUAL sequential DOT PREDICT LPAREN LBRACKET predictp .)
    READ            reduce using rule 102 (predict -> ID EQUAL sequential DOT PREDICT LPAREN LBRACKET predictp .)
    PRINT           reduce using rule 102 (predict -> ID EQUAL sequential DOT PREDICT LPAREN LBRACKET predictp .)
    IF              reduce using rule 102 (predict -> ID EQUAL sequential DOT PREDICT LPAREN LBRACKET predictp .)
    WHILE           reduce using rule 102 (predict -> ID EQUAL sequential DOT PREDICT LPAREN LBRACKET predictp .)
    FOR             reduce using rule 102 (predict -> ID EQUAL sequential DOT PREDICT LPAREN LBRACKET predictp .)
    MEAN            reduce using rule 102 (predict -> ID EQUAL sequential DOT PREDICT LPAREN LBRACKET predictp .)
    RBRACE          reduce using rule 102 (predict -> ID EQUAL sequential DOT PREDICT LPAREN LBRACKET predictp .)
    SEMICOLON       reduce using rule 102 (predict -> ID EQUAL sequential DOT PREDICT LPAREN LBRACKET predictp .)
    RBRACKET        reduce using rule 102 (predict -> ID EQUAL sequential DOT PREDICT LPAREN LBRACKET predictp .)


state 203

    (103) predictp -> INT . RBRACKET RPAREN

    RBRACKET        shift and go to state 210


state 204

    (104) predictp -> FLOAT . RBRACKET RPAREN

    RBRACKET        shift and go to state 211


state 205

    (66) if -> IF LPAREN CTI GT CTI RPAREN quadsIf ifp . jumpsIf
    (70) jumpsIf -> .

    VAR             reduce using rule 70 (jumpsIf -> .)
    FUNCTION        reduce using rule 70 (jumpsIf -> .)
    ID              reduce using rule 70 (jumpsIf -> .)
    READ            reduce using rule 70 (jumpsIf -> .)
    PRINT           reduce using rule 70 (jumpsIf -> .)
    IF              reduce using rule 70 (jumpsIf -> .)
    WHILE           reduce using rule 70 (jumpsIf -> .)
    FOR             reduce using rule 70 (jumpsIf -> .)
    MEAN            reduce using rule 70 (jumpsIf -> .)
    RBRACE          reduce using rule 70 (jumpsIf -> .)
    SEMICOLON       reduce using rule 70 (jumpsIf -> .)
    RBRACKET        reduce using rule 70 (jumpsIf -> .)

    jumpsIf                        shift and go to state 212

state 206

    (68) ifp -> ELSE . quadsElse statements
    (71) quadsElse -> .

    FUNCTION        reduce using rule 71 (quadsElse -> .)
    ID              reduce using rule 71 (quadsElse -> .)
    READ            reduce using rule 71 (quadsElse -> .)
    PRINT           reduce using rule 71 (quadsElse -> .)
    IF              reduce using rule 71 (quadsElse -> .)
    WHILE           reduce using rule 71 (quadsElse -> .)
    FOR             reduce using rule 71 (quadsElse -> .)
    MEAN            reduce using rule 71 (quadsElse -> .)
    VAR             reduce using rule 71 (quadsElse -> .)
    RBRACE          reduce using rule 71 (quadsElse -> .)
    SEMICOLON       reduce using rule 71 (quadsElse -> .)
    RBRACKET        reduce using rule 71 (quadsElse -> .)

    quadsElse                      shift and go to state 213

state 207

    (75) for -> FOR LPAREN var SEMICOLON exp SEMICOLON exp RPAREN . LBRACKET statements forp

    LBRACKET        shift and go to state 214


state 208

    (97) sequentialp -> COMMA layers sequentialp .

    DOT             reduce using rule 97 (sequentialp -> COMMA layers sequentialp .)
    VAR             reduce using rule 97 (sequentialp -> COMMA layers sequentialp .)
    FUNCTION        reduce using rule 97 (sequentialp -> COMMA layers sequentialp .)
    ID              reduce using rule 97 (sequentialp -> COMMA layers sequentialp .)
    READ            reduce using rule 97 (sequentialp -> COMMA layers sequentialp .)
    PRINT           reduce using rule 97 (sequentialp -> COMMA layers sequentialp .)
    IF              reduce using rule 97 (sequentialp -> COMMA layers sequentialp .)
    WHILE           reduce using rule 97 (sequentialp -> COMMA layers sequentialp .)
    FOR             reduce using rule 97 (sequentialp -> COMMA layers sequentialp .)
    MEAN            reduce using rule 97 (sequentialp -> COMMA layers sequentialp .)
    RBRACE          reduce using rule 97 (sequentialp -> COMMA layers sequentialp .)
    SEMICOLON       reduce using rule 97 (sequentialp -> COMMA layers sequentialp .)
    RBRACKET        reduce using rule 97 (sequentialp -> COMMA layers sequentialp .)


state 209

    (99) fit -> ID EQUAL sequential DOT FIT LPAREN array COMMA array . COMMA EPOCHS EQUAL INT COMMA VERBOSE EQUAL fitp

    COMMA           shift and go to state 215


state 210

    (103) predictp -> INT RBRACKET . RPAREN

    RPAREN          shift and go to state 216


state 211

    (104) predictp -> FLOAT RBRACKET . RPAREN

    RPAREN          shift and go to state 217


state 212

    (66) if -> IF LPAREN CTI GT CTI RPAREN quadsIf ifp jumpsIf .

    VAR             reduce using rule 66 (if -> IF LPAREN CTI GT CTI RPAREN quadsIf ifp jumpsIf .)
    FUNCTION        reduce using rule 66 (if -> IF LPAREN CTI GT CTI RPAREN quadsIf ifp jumpsIf .)
    ID              reduce using rule 66 (if -> IF LPAREN CTI GT CTI RPAREN quadsIf ifp jumpsIf .)
    READ            reduce using rule 66 (if -> IF LPAREN CTI GT CTI RPAREN quadsIf ifp jumpsIf .)
    PRINT           reduce using rule 66 (if -> IF LPAREN CTI GT CTI RPAREN quadsIf ifp jumpsIf .)
    IF              reduce using rule 66 (if -> IF LPAREN CTI GT CTI RPAREN quadsIf ifp jumpsIf .)
    WHILE           reduce using rule 66 (if -> IF LPAREN CTI GT CTI RPAREN quadsIf ifp jumpsIf .)
    FOR             reduce using rule 66 (if -> IF LPAREN CTI GT CTI RPAREN quadsIf ifp jumpsIf .)
    MEAN            reduce using rule 66 (if -> IF LPAREN CTI GT CTI RPAREN quadsIf ifp jumpsIf .)
    RBRACE          reduce using rule 66 (if -> IF LPAREN CTI GT CTI RPAREN quadsIf ifp jumpsIf .)
    SEMICOLON       reduce using rule 66 (if -> IF LPAREN CTI GT CTI RPAREN quadsIf ifp jumpsIf .)
    RBRACKET        reduce using rule 66 (if -> IF LPAREN CTI GT CTI RPAREN quadsIf ifp jumpsIf .)


state 213

    (68) ifp -> ELSE quadsElse . statements
    (46) statements -> . assign
    (47) statements -> . function
    (48) statements -> . voidfunction
    (49) statements -> . call
    (50) statements -> . read
    (51) statements -> . print
    (52) statements -> . if
    (53) statements -> . while
    (54) statements -> . for
    (55) statements -> . funcesp
    (56) statements -> .
    (57) assign -> . var EQUAL exp SEMICOLON
    (10) function -> . FUNCTION type decfunc LPAREN param RPAREN LBRACE body RBRACE
    (12) voidfunction -> . FUNCTION VOID decfunc LPAREN param RPAREN LBRACE body RBRACE
    (63) call -> . ID LPAREN callp RPAREN
    (58) read -> . READ var
    (59) print -> . PRINT LPAREN printp
    (66) if -> . IF LPAREN CTI GT CTI RPAREN quadsIf ifp jumpsIf
    (72) while -> . WHILE LPAREN exp RPAREN statements whilep
    (75) for -> . FOR LPAREN var SEMICOLON exp SEMICOLON exp RPAREN LBRACKET statements forp
    (78) funcesp -> . array
    (79) funcesp -> . matrix
    (80) funcesp -> . mean
    (81) funcesp -> . layers
    (82) funcesp -> . sequential
    (83) funcesp -> . compile
    (84) funcesp -> . fit
    (85) funcesp -> . predict
    (86) funcesp -> . getweights
    (62) var -> . ID
    (87) array -> . ID EQUAL ARRAY LPAREN var arrayp
    (90) matrix -> . ID EQUAL MATRIX LPAREN array matrixp
    (93) mean -> . MEAN LPAREN array RPAREN
    (94) layers -> . ID EQUAL LAYERS LPAREN UNITS EQUAL INT RPAREN
    (95) sequential -> . ID EQUAL SEQUENTIAL LPAREN LBRACKET layers sequentialp
    (98) compile -> . sequential DOT COMPILE LPAREN RPAREN
    (99) fit -> . ID EQUAL sequential DOT FIT LPAREN array COMMA array COMMA EPOCHS EQUAL INT COMMA VERBOSE EQUAL fitp
    (102) predict -> . ID EQUAL sequential DOT PREDICT LPAREN LBRACKET predictp
    (105) getweights -> . layers DOT GETWEIGHTS LPAREN RPAREN

  ! shift/reduce conflict for FUNCTION resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for READ resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for MEAN resolved as shift
    VAR             reduce using rule 56 (statements -> .)
    RBRACE          reduce using rule 56 (statements -> .)
    SEMICOLON       reduce using rule 56 (statements -> .)
    RBRACKET        reduce using rule 56 (statements -> .)
    FUNCTION        shift and go to state 10
    ID              shift and go to state 54
    READ            shift and go to state 55
    PRINT           shift and go to state 56
    IF              shift and go to state 57
    WHILE           shift and go to state 58
    FOR             shift and go to state 59
    MEAN            shift and go to state 69

  ! FUNCTION        [ reduce using rule 56 (statements -> .) ]
  ! ID              [ reduce using rule 56 (statements -> .) ]
  ! READ            [ reduce using rule 56 (statements -> .) ]
  ! PRINT           [ reduce using rule 56 (statements -> .) ]
  ! IF              [ reduce using rule 56 (statements -> .) ]
  ! WHILE           [ reduce using rule 56 (statements -> .) ]
  ! FOR             [ reduce using rule 56 (statements -> .) ]
  ! MEAN            [ reduce using rule 56 (statements -> .) ]

    statements                     shift and go to state 218
    assign                         shift and go to state 43
    function                       shift and go to state 44
    voidfunction                   shift and go to state 45
    call                           shift and go to state 46
    read                           shift and go to state 47
    print                          shift and go to state 48
    if                             shift and go to state 49
    while                          shift and go to state 50
    for                            shift and go to state 51
    funcesp                        shift and go to state 52
    var                            shift and go to state 53
    array                          shift and go to state 60
    matrix                         shift and go to state 61
    mean                           shift and go to state 62
    layers                         shift and go to state 63
    sequential                     shift and go to state 64
    compile                        shift and go to state 65
    fit                            shift and go to state 66
    predict                        shift and go to state 67
    getweights                     shift and go to state 68

state 214

    (75) for -> FOR LPAREN var SEMICOLON exp SEMICOLON exp RPAREN LBRACKET . statements forp
    (46) statements -> . assign
    (47) statements -> . function
    (48) statements -> . voidfunction
    (49) statements -> . call
    (50) statements -> . read
    (51) statements -> . print
    (52) statements -> . if
    (53) statements -> . while
    (54) statements -> . for
    (55) statements -> . funcesp
    (56) statements -> .
    (57) assign -> . var EQUAL exp SEMICOLON
    (10) function -> . FUNCTION type decfunc LPAREN param RPAREN LBRACE body RBRACE
    (12) voidfunction -> . FUNCTION VOID decfunc LPAREN param RPAREN LBRACE body RBRACE
    (63) call -> . ID LPAREN callp RPAREN
    (58) read -> . READ var
    (59) print -> . PRINT LPAREN printp
    (66) if -> . IF LPAREN CTI GT CTI RPAREN quadsIf ifp jumpsIf
    (72) while -> . WHILE LPAREN exp RPAREN statements whilep
    (75) for -> . FOR LPAREN var SEMICOLON exp SEMICOLON exp RPAREN LBRACKET statements forp
    (78) funcesp -> . array
    (79) funcesp -> . matrix
    (80) funcesp -> . mean
    (81) funcesp -> . layers
    (82) funcesp -> . sequential
    (83) funcesp -> . compile
    (84) funcesp -> . fit
    (85) funcesp -> . predict
    (86) funcesp -> . getweights
    (62) var -> . ID
    (87) array -> . ID EQUAL ARRAY LPAREN var arrayp
    (90) matrix -> . ID EQUAL MATRIX LPAREN array matrixp
    (93) mean -> . MEAN LPAREN array RPAREN
    (94) layers -> . ID EQUAL LAYERS LPAREN UNITS EQUAL INT RPAREN
    (95) sequential -> . ID EQUAL SEQUENTIAL LPAREN LBRACKET layers sequentialp
    (98) compile -> . sequential DOT COMPILE LPAREN RPAREN
    (99) fit -> . ID EQUAL sequential DOT FIT LPAREN array COMMA array COMMA EPOCHS EQUAL INT COMMA VERBOSE EQUAL fitp
    (102) predict -> . ID EQUAL sequential DOT PREDICT LPAREN LBRACKET predictp
    (105) getweights -> . layers DOT GETWEIGHTS LPAREN RPAREN

  ! shift/reduce conflict for FUNCTION resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for READ resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for MEAN resolved as shift
    RBRACKET        reduce using rule 56 (statements -> .)
    FUNCTION        shift and go to state 10
    ID              shift and go to state 54
    READ            shift and go to state 55
    PRINT           shift and go to state 56
    IF              shift and go to state 57
    WHILE           shift and go to state 58
    FOR             shift and go to state 59
    MEAN            shift and go to state 69

  ! FUNCTION        [ reduce using rule 56 (statements -> .) ]
  ! ID              [ reduce using rule 56 (statements -> .) ]
  ! READ            [ reduce using rule 56 (statements -> .) ]
  ! PRINT           [ reduce using rule 56 (statements -> .) ]
  ! IF              [ reduce using rule 56 (statements -> .) ]
  ! WHILE           [ reduce using rule 56 (statements -> .) ]
  ! FOR             [ reduce using rule 56 (statements -> .) ]
  ! MEAN            [ reduce using rule 56 (statements -> .) ]

    var                            shift and go to state 53
    statements                     shift and go to state 219
    assign                         shift and go to state 43
    function                       shift and go to state 44
    voidfunction                   shift and go to state 45
    call                           shift and go to state 46
    read                           shift and go to state 47
    print                          shift and go to state 48
    if                             shift and go to state 49
    while                          shift and go to state 50
    for                            shift and go to state 51
    funcesp                        shift and go to state 52
    array                          shift and go to state 60
    matrix                         shift and go to state 61
    mean                           shift and go to state 62
    layers                         shift and go to state 63
    sequential                     shift and go to state 64
    compile                        shift and go to state 65
    fit                            shift and go to state 66
    predict                        shift and go to state 67
    getweights                     shift and go to state 68

state 215

    (99) fit -> ID EQUAL sequential DOT FIT LPAREN array COMMA array COMMA . EPOCHS EQUAL INT COMMA VERBOSE EQUAL fitp

    EPOCHS          shift and go to state 220


state 216

    (103) predictp -> INT RBRACKET RPAREN .

    VAR             reduce using rule 103 (predictp -> INT RBRACKET RPAREN .)
    FUNCTION        reduce using rule 103 (predictp -> INT RBRACKET RPAREN .)
    ID              reduce using rule 103 (predictp -> INT RBRACKET RPAREN .)
    READ            reduce using rule 103 (predictp -> INT RBRACKET RPAREN .)
    PRINT           reduce using rule 103 (predictp -> INT RBRACKET RPAREN .)
    IF              reduce using rule 103 (predictp -> INT RBRACKET RPAREN .)
    WHILE           reduce using rule 103 (predictp -> INT RBRACKET RPAREN .)
    FOR             reduce using rule 103 (predictp -> INT RBRACKET RPAREN .)
    MEAN            reduce using rule 103 (predictp -> INT RBRACKET RPAREN .)
    RBRACE          reduce using rule 103 (predictp -> INT RBRACKET RPAREN .)
    SEMICOLON       reduce using rule 103 (predictp -> INT RBRACKET RPAREN .)
    RBRACKET        reduce using rule 103 (predictp -> INT RBRACKET RPAREN .)


state 217

    (104) predictp -> FLOAT RBRACKET RPAREN .

    VAR             reduce using rule 104 (predictp -> FLOAT RBRACKET RPAREN .)
    FUNCTION        reduce using rule 104 (predictp -> FLOAT RBRACKET RPAREN .)
    ID              reduce using rule 104 (predictp -> FLOAT RBRACKET RPAREN .)
    READ            reduce using rule 104 (predictp -> FLOAT RBRACKET RPAREN .)
    PRINT           reduce using rule 104 (predictp -> FLOAT RBRACKET RPAREN .)
    IF              reduce using rule 104 (predictp -> FLOAT RBRACKET RPAREN .)
    WHILE           reduce using rule 104 (predictp -> FLOAT RBRACKET RPAREN .)
    FOR             reduce using rule 104 (predictp -> FLOAT RBRACKET RPAREN .)
    MEAN            reduce using rule 104 (predictp -> FLOAT RBRACKET RPAREN .)
    RBRACE          reduce using rule 104 (predictp -> FLOAT RBRACKET RPAREN .)
    SEMICOLON       reduce using rule 104 (predictp -> FLOAT RBRACKET RPAREN .)
    RBRACKET        reduce using rule 104 (predictp -> FLOAT RBRACKET RPAREN .)


state 218

    (68) ifp -> ELSE quadsElse statements .

    VAR             reduce using rule 68 (ifp -> ELSE quadsElse statements .)
    FUNCTION        reduce using rule 68 (ifp -> ELSE quadsElse statements .)
    ID              reduce using rule 68 (ifp -> ELSE quadsElse statements .)
    READ            reduce using rule 68 (ifp -> ELSE quadsElse statements .)
    PRINT           reduce using rule 68 (ifp -> ELSE quadsElse statements .)
    IF              reduce using rule 68 (ifp -> ELSE quadsElse statements .)
    WHILE           reduce using rule 68 (ifp -> ELSE quadsElse statements .)
    FOR             reduce using rule 68 (ifp -> ELSE quadsElse statements .)
    MEAN            reduce using rule 68 (ifp -> ELSE quadsElse statements .)
    RBRACE          reduce using rule 68 (ifp -> ELSE quadsElse statements .)
    SEMICOLON       reduce using rule 68 (ifp -> ELSE quadsElse statements .)
    RBRACKET        reduce using rule 68 (ifp -> ELSE quadsElse statements .)


state 219

    (75) for -> FOR LPAREN var SEMICOLON exp SEMICOLON exp RPAREN LBRACKET statements . forp
    (76) forp -> . RBRACKET
    (77) forp -> . statements forp
    (46) statements -> . assign
    (47) statements -> . function
    (48) statements -> . voidfunction
    (49) statements -> . call
    (50) statements -> . read
    (51) statements -> . print
    (52) statements -> . if
    (53) statements -> . while
    (54) statements -> . for
    (55) statements -> . funcesp
    (56) statements -> .
    (57) assign -> . var EQUAL exp SEMICOLON
    (10) function -> . FUNCTION type decfunc LPAREN param RPAREN LBRACE body RBRACE
    (12) voidfunction -> . FUNCTION VOID decfunc LPAREN param RPAREN LBRACE body RBRACE
    (63) call -> . ID LPAREN callp RPAREN
    (58) read -> . READ var
    (59) print -> . PRINT LPAREN printp
    (66) if -> . IF LPAREN CTI GT CTI RPAREN quadsIf ifp jumpsIf
    (72) while -> . WHILE LPAREN exp RPAREN statements whilep
    (75) for -> . FOR LPAREN var SEMICOLON exp SEMICOLON exp RPAREN LBRACKET statements forp
    (78) funcesp -> . array
    (79) funcesp -> . matrix
    (80) funcesp -> . mean
    (81) funcesp -> . layers
    (82) funcesp -> . sequential
    (83) funcesp -> . compile
    (84) funcesp -> . fit
    (85) funcesp -> . predict
    (86) funcesp -> . getweights
    (62) var -> . ID
    (87) array -> . ID EQUAL ARRAY LPAREN var arrayp
    (90) matrix -> . ID EQUAL MATRIX LPAREN array matrixp
    (93) mean -> . MEAN LPAREN array RPAREN
    (94) layers -> . ID EQUAL LAYERS LPAREN UNITS EQUAL INT RPAREN
    (95) sequential -> . ID EQUAL SEQUENTIAL LPAREN LBRACKET layers sequentialp
    (98) compile -> . sequential DOT COMPILE LPAREN RPAREN
    (99) fit -> . ID EQUAL sequential DOT FIT LPAREN array COMMA array COMMA EPOCHS EQUAL INT COMMA VERBOSE EQUAL fitp
    (102) predict -> . ID EQUAL sequential DOT PREDICT LPAREN LBRACKET predictp
    (105) getweights -> . layers DOT GETWEIGHTS LPAREN RPAREN

  ! shift/reduce conflict for RBRACKET resolved as shift
  ! shift/reduce conflict for FUNCTION resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for READ resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for MEAN resolved as shift
    RBRACKET        shift and go to state 223
    FUNCTION        shift and go to state 10
    ID              shift and go to state 54
    READ            shift and go to state 55
    PRINT           shift and go to state 56
    IF              shift and go to state 57
    WHILE           shift and go to state 58
    FOR             shift and go to state 59
    MEAN            shift and go to state 69

  ! RBRACKET        [ reduce using rule 56 (statements -> .) ]
  ! FUNCTION        [ reduce using rule 56 (statements -> .) ]
  ! ID              [ reduce using rule 56 (statements -> .) ]
  ! READ            [ reduce using rule 56 (statements -> .) ]
  ! PRINT           [ reduce using rule 56 (statements -> .) ]
  ! IF              [ reduce using rule 56 (statements -> .) ]
  ! WHILE           [ reduce using rule 56 (statements -> .) ]
  ! FOR             [ reduce using rule 56 (statements -> .) ]
  ! MEAN            [ reduce using rule 56 (statements -> .) ]

    var                            shift and go to state 53
    statements                     shift and go to state 221
    forp                           shift and go to state 222
    assign                         shift and go to state 43
    function                       shift and go to state 44
    voidfunction                   shift and go to state 45
    call                           shift and go to state 46
    read                           shift and go to state 47
    print                          shift and go to state 48
    if                             shift and go to state 49
    while                          shift and go to state 50
    for                            shift and go to state 51
    funcesp                        shift and go to state 52
    array                          shift and go to state 60
    matrix                         shift and go to state 61
    mean                           shift and go to state 62
    layers                         shift and go to state 63
    sequential                     shift and go to state 64
    compile                        shift and go to state 65
    fit                            shift and go to state 66
    predict                        shift and go to state 67
    getweights                     shift and go to state 68

state 220

    (99) fit -> ID EQUAL sequential DOT FIT LPAREN array COMMA array COMMA EPOCHS . EQUAL INT COMMA VERBOSE EQUAL fitp

    EQUAL           shift and go to state 224


state 221

    (77) forp -> statements . forp
    (76) forp -> . RBRACKET
    (77) forp -> . statements forp
    (46) statements -> . assign
    (47) statements -> . function
    (48) statements -> . voidfunction
    (49) statements -> . call
    (50) statements -> . read
    (51) statements -> . print
    (52) statements -> . if
    (53) statements -> . while
    (54) statements -> . for
    (55) statements -> . funcesp
    (56) statements -> .
    (57) assign -> . var EQUAL exp SEMICOLON
    (10) function -> . FUNCTION type decfunc LPAREN param RPAREN LBRACE body RBRACE
    (12) voidfunction -> . FUNCTION VOID decfunc LPAREN param RPAREN LBRACE body RBRACE
    (63) call -> . ID LPAREN callp RPAREN
    (58) read -> . READ var
    (59) print -> . PRINT LPAREN printp
    (66) if -> . IF LPAREN CTI GT CTI RPAREN quadsIf ifp jumpsIf
    (72) while -> . WHILE LPAREN exp RPAREN statements whilep
    (75) for -> . FOR LPAREN var SEMICOLON exp SEMICOLON exp RPAREN LBRACKET statements forp
    (78) funcesp -> . array
    (79) funcesp -> . matrix
    (80) funcesp -> . mean
    (81) funcesp -> . layers
    (82) funcesp -> . sequential
    (83) funcesp -> . compile
    (84) funcesp -> . fit
    (85) funcesp -> . predict
    (86) funcesp -> . getweights
    (62) var -> . ID
    (87) array -> . ID EQUAL ARRAY LPAREN var arrayp
    (90) matrix -> . ID EQUAL MATRIX LPAREN array matrixp
    (93) mean -> . MEAN LPAREN array RPAREN
    (94) layers -> . ID EQUAL LAYERS LPAREN UNITS EQUAL INT RPAREN
    (95) sequential -> . ID EQUAL SEQUENTIAL LPAREN LBRACKET layers sequentialp
    (98) compile -> . sequential DOT COMPILE LPAREN RPAREN
    (99) fit -> . ID EQUAL sequential DOT FIT LPAREN array COMMA array COMMA EPOCHS EQUAL INT COMMA VERBOSE EQUAL fitp
    (102) predict -> . ID EQUAL sequential DOT PREDICT LPAREN LBRACKET predictp
    (105) getweights -> . layers DOT GETWEIGHTS LPAREN RPAREN

  ! shift/reduce conflict for RBRACKET resolved as shift
  ! shift/reduce conflict for FUNCTION resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for READ resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for MEAN resolved as shift
    RBRACKET        shift and go to state 223
    FUNCTION        shift and go to state 10
    ID              shift and go to state 54
    READ            shift and go to state 55
    PRINT           shift and go to state 56
    IF              shift and go to state 57
    WHILE           shift and go to state 58
    FOR             shift and go to state 59
    MEAN            shift and go to state 69

  ! RBRACKET        [ reduce using rule 56 (statements -> .) ]
  ! FUNCTION        [ reduce using rule 56 (statements -> .) ]
  ! ID              [ reduce using rule 56 (statements -> .) ]
  ! READ            [ reduce using rule 56 (statements -> .) ]
  ! PRINT           [ reduce using rule 56 (statements -> .) ]
  ! IF              [ reduce using rule 56 (statements -> .) ]
  ! WHILE           [ reduce using rule 56 (statements -> .) ]
  ! FOR             [ reduce using rule 56 (statements -> .) ]
  ! MEAN            [ reduce using rule 56 (statements -> .) ]

    statements                     shift and go to state 221
    forp                           shift and go to state 225
    assign                         shift and go to state 43
    function                       shift and go to state 44
    voidfunction                   shift and go to state 45
    call                           shift and go to state 46
    read                           shift and go to state 47
    print                          shift and go to state 48
    if                             shift and go to state 49
    while                          shift and go to state 50
    for                            shift and go to state 51
    funcesp                        shift and go to state 52
    var                            shift and go to state 53
    array                          shift and go to state 60
    matrix                         shift and go to state 61
    mean                           shift and go to state 62
    layers                         shift and go to state 63
    sequential                     shift and go to state 64
    compile                        shift and go to state 65
    fit                            shift and go to state 66
    predict                        shift and go to state 67
    getweights                     shift and go to state 68

state 222

    (75) for -> FOR LPAREN var SEMICOLON exp SEMICOLON exp RPAREN LBRACKET statements forp .

    VAR             reduce using rule 75 (for -> FOR LPAREN var SEMICOLON exp SEMICOLON exp RPAREN LBRACKET statements forp .)
    FUNCTION        reduce using rule 75 (for -> FOR LPAREN var SEMICOLON exp SEMICOLON exp RPAREN LBRACKET statements forp .)
    ID              reduce using rule 75 (for -> FOR LPAREN var SEMICOLON exp SEMICOLON exp RPAREN LBRACKET statements forp .)
    READ            reduce using rule 75 (for -> FOR LPAREN var SEMICOLON exp SEMICOLON exp RPAREN LBRACKET statements forp .)
    PRINT           reduce using rule 75 (for -> FOR LPAREN var SEMICOLON exp SEMICOLON exp RPAREN LBRACKET statements forp .)
    IF              reduce using rule 75 (for -> FOR LPAREN var SEMICOLON exp SEMICOLON exp RPAREN LBRACKET statements forp .)
    WHILE           reduce using rule 75 (for -> FOR LPAREN var SEMICOLON exp SEMICOLON exp RPAREN LBRACKET statements forp .)
    FOR             reduce using rule 75 (for -> FOR LPAREN var SEMICOLON exp SEMICOLON exp RPAREN LBRACKET statements forp .)
    MEAN            reduce using rule 75 (for -> FOR LPAREN var SEMICOLON exp SEMICOLON exp RPAREN LBRACKET statements forp .)
    RBRACE          reduce using rule 75 (for -> FOR LPAREN var SEMICOLON exp SEMICOLON exp RPAREN LBRACKET statements forp .)
    SEMICOLON       reduce using rule 75 (for -> FOR LPAREN var SEMICOLON exp SEMICOLON exp RPAREN LBRACKET statements forp .)
    RBRACKET        reduce using rule 75 (for -> FOR LPAREN var SEMICOLON exp SEMICOLON exp RPAREN LBRACKET statements forp .)


state 223

    (76) forp -> RBRACKET .

    VAR             reduce using rule 76 (forp -> RBRACKET .)
    FUNCTION        reduce using rule 76 (forp -> RBRACKET .)
    ID              reduce using rule 76 (forp -> RBRACKET .)
    READ            reduce using rule 76 (forp -> RBRACKET .)
    PRINT           reduce using rule 76 (forp -> RBRACKET .)
    IF              reduce using rule 76 (forp -> RBRACKET .)
    WHILE           reduce using rule 76 (forp -> RBRACKET .)
    FOR             reduce using rule 76 (forp -> RBRACKET .)
    MEAN            reduce using rule 76 (forp -> RBRACKET .)
    RBRACE          reduce using rule 76 (forp -> RBRACKET .)
    SEMICOLON       reduce using rule 76 (forp -> RBRACKET .)
    RBRACKET        reduce using rule 76 (forp -> RBRACKET .)


state 224

    (99) fit -> ID EQUAL sequential DOT FIT LPAREN array COMMA array COMMA EPOCHS EQUAL . INT COMMA VERBOSE EQUAL fitp

    INT             shift and go to state 226


state 225

    (77) forp -> statements forp .

    VAR             reduce using rule 77 (forp -> statements forp .)
    FUNCTION        reduce using rule 77 (forp -> statements forp .)
    ID              reduce using rule 77 (forp -> statements forp .)
    READ            reduce using rule 77 (forp -> statements forp .)
    PRINT           reduce using rule 77 (forp -> statements forp .)
    IF              reduce using rule 77 (forp -> statements forp .)
    WHILE           reduce using rule 77 (forp -> statements forp .)
    FOR             reduce using rule 77 (forp -> statements forp .)
    MEAN            reduce using rule 77 (forp -> statements forp .)
    RBRACE          reduce using rule 77 (forp -> statements forp .)
    SEMICOLON       reduce using rule 77 (forp -> statements forp .)
    RBRACKET        reduce using rule 77 (forp -> statements forp .)


state 226

    (99) fit -> ID EQUAL sequential DOT FIT LPAREN array COMMA array COMMA EPOCHS EQUAL INT . COMMA VERBOSE EQUAL fitp

    COMMA           shift and go to state 227


state 227

    (99) fit -> ID EQUAL sequential DOT FIT LPAREN array COMMA array COMMA EPOCHS EQUAL INT COMMA . VERBOSE EQUAL fitp

    VERBOSE         shift and go to state 228


state 228

    (99) fit -> ID EQUAL sequential DOT FIT LPAREN array COMMA array COMMA EPOCHS EQUAL INT COMMA VERBOSE . EQUAL fitp

    EQUAL           shift and go to state 229


state 229

    (99) fit -> ID EQUAL sequential DOT FIT LPAREN array COMMA array COMMA EPOCHS EQUAL INT COMMA VERBOSE EQUAL . fitp
    (100) fitp -> . TRUE RPAREN
    (101) fitp -> . FALSE RPAREN

    TRUE            shift and go to state 231
    FALSE           shift and go to state 232

    fitp                           shift and go to state 230

state 230

    (99) fit -> ID EQUAL sequential DOT FIT LPAREN array COMMA array COMMA EPOCHS EQUAL INT COMMA VERBOSE EQUAL fitp .

    VAR             reduce using rule 99 (fit -> ID EQUAL sequential DOT FIT LPAREN array COMMA array COMMA EPOCHS EQUAL INT COMMA VERBOSE EQUAL fitp .)
    FUNCTION        reduce using rule 99 (fit -> ID EQUAL sequential DOT FIT LPAREN array COMMA array COMMA EPOCHS EQUAL INT COMMA VERBOSE EQUAL fitp .)
    ID              reduce using rule 99 (fit -> ID EQUAL sequential DOT FIT LPAREN array COMMA array COMMA EPOCHS EQUAL INT COMMA VERBOSE EQUAL fitp .)
    READ            reduce using rule 99 (fit -> ID EQUAL sequential DOT FIT LPAREN array COMMA array COMMA EPOCHS EQUAL INT COMMA VERBOSE EQUAL fitp .)
    PRINT           reduce using rule 99 (fit -> ID EQUAL sequential DOT FIT LPAREN array COMMA array COMMA EPOCHS EQUAL INT COMMA VERBOSE EQUAL fitp .)
    IF              reduce using rule 99 (fit -> ID EQUAL sequential DOT FIT LPAREN array COMMA array COMMA EPOCHS EQUAL INT COMMA VERBOSE EQUAL fitp .)
    WHILE           reduce using rule 99 (fit -> ID EQUAL sequential DOT FIT LPAREN array COMMA array COMMA EPOCHS EQUAL INT COMMA VERBOSE EQUAL fitp .)
    FOR             reduce using rule 99 (fit -> ID EQUAL sequential DOT FIT LPAREN array COMMA array COMMA EPOCHS EQUAL INT COMMA VERBOSE EQUAL fitp .)
    MEAN            reduce using rule 99 (fit -> ID EQUAL sequential DOT FIT LPAREN array COMMA array COMMA EPOCHS EQUAL INT COMMA VERBOSE EQUAL fitp .)
    RBRACE          reduce using rule 99 (fit -> ID EQUAL sequential DOT FIT LPAREN array COMMA array COMMA EPOCHS EQUAL INT COMMA VERBOSE EQUAL fitp .)
    SEMICOLON       reduce using rule 99 (fit -> ID EQUAL sequential DOT FIT LPAREN array COMMA array COMMA EPOCHS EQUAL INT COMMA VERBOSE EQUAL fitp .)
    RBRACKET        reduce using rule 99 (fit -> ID EQUAL sequential DOT FIT LPAREN array COMMA array COMMA EPOCHS EQUAL INT COMMA VERBOSE EQUAL fitp .)


state 231

    (100) fitp -> TRUE . RPAREN

    RPAREN          shift and go to state 233


state 232

    (101) fitp -> FALSE . RPAREN

    RPAREN          shift and go to state 234


state 233

    (100) fitp -> TRUE RPAREN .

    VAR             reduce using rule 100 (fitp -> TRUE RPAREN .)
    FUNCTION        reduce using rule 100 (fitp -> TRUE RPAREN .)
    ID              reduce using rule 100 (fitp -> TRUE RPAREN .)
    READ            reduce using rule 100 (fitp -> TRUE RPAREN .)
    PRINT           reduce using rule 100 (fitp -> TRUE RPAREN .)
    IF              reduce using rule 100 (fitp -> TRUE RPAREN .)
    WHILE           reduce using rule 100 (fitp -> TRUE RPAREN .)
    FOR             reduce using rule 100 (fitp -> TRUE RPAREN .)
    MEAN            reduce using rule 100 (fitp -> TRUE RPAREN .)
    RBRACE          reduce using rule 100 (fitp -> TRUE RPAREN .)
    SEMICOLON       reduce using rule 100 (fitp -> TRUE RPAREN .)
    RBRACKET        reduce using rule 100 (fitp -> TRUE RPAREN .)


state 234

    (101) fitp -> FALSE RPAREN .

    VAR             reduce using rule 101 (fitp -> FALSE RPAREN .)
    FUNCTION        reduce using rule 101 (fitp -> FALSE RPAREN .)
    ID              reduce using rule 101 (fitp -> FALSE RPAREN .)
    READ            reduce using rule 101 (fitp -> FALSE RPAREN .)
    PRINT           reduce using rule 101 (fitp -> FALSE RPAREN .)
    IF              reduce using rule 101 (fitp -> FALSE RPAREN .)
    WHILE           reduce using rule 101 (fitp -> FALSE RPAREN .)
    FOR             reduce using rule 101 (fitp -> FALSE RPAREN .)
    MEAN            reduce using rule 101 (fitp -> FALSE RPAREN .)
    RBRACE          reduce using rule 101 (fitp -> FALSE RPAREN .)
    SEMICOLON       reduce using rule 101 (fitp -> FALSE RPAREN .)
    RBRACKET        reduce using rule 101 (fitp -> FALSE RPAREN .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for VAR in state 11 resolved as shift
WARNING: shift/reduce conflict for VAR in state 11 resolved as shift
WARNING: shift/reduce conflict for VAR in state 37 resolved as shift
WARNING: shift/reduce conflict for VAR in state 37 resolved as shift
WARNING: shift/reduce conflict for FUNCTION in state 37 resolved as shift
WARNING: shift/reduce conflict for ID in state 37 resolved as shift
WARNING: shift/reduce conflict for READ in state 37 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 37 resolved as shift
WARNING: shift/reduce conflict for IF in state 37 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 37 resolved as shift
WARNING: shift/reduce conflict for FOR in state 37 resolved as shift
WARNING: shift/reduce conflict for MEAN in state 37 resolved as shift
WARNING: shift/reduce conflict for VAR in state 38 resolved as shift
WARNING: shift/reduce conflict for VAR in state 38 resolved as shift
WARNING: shift/reduce conflict for FUNCTION in state 38 resolved as shift
WARNING: shift/reduce conflict for ID in state 38 resolved as shift
WARNING: shift/reduce conflict for READ in state 38 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 38 resolved as shift
WARNING: shift/reduce conflict for IF in state 38 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 38 resolved as shift
WARNING: shift/reduce conflict for FOR in state 38 resolved as shift
WARNING: shift/reduce conflict for MEAN in state 38 resolved as shift
WARNING: shift/reduce conflict for FUNCTION in state 41 resolved as shift
WARNING: shift/reduce conflict for ID in state 41 resolved as shift
WARNING: shift/reduce conflict for READ in state 41 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 41 resolved as shift
WARNING: shift/reduce conflict for IF in state 41 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 41 resolved as shift
WARNING: shift/reduce conflict for FOR in state 41 resolved as shift
WARNING: shift/reduce conflict for MEAN in state 41 resolved as shift
WARNING: shift/reduce conflict for VAR in state 42 resolved as shift
WARNING: shift/reduce conflict for VAR in state 42 resolved as shift
WARNING: shift/reduce conflict for FUNCTION in state 42 resolved as shift
WARNING: shift/reduce conflict for ID in state 42 resolved as shift
WARNING: shift/reduce conflict for READ in state 42 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 42 resolved as shift
WARNING: shift/reduce conflict for IF in state 42 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 42 resolved as shift
WARNING: shift/reduce conflict for FOR in state 42 resolved as shift
WARNING: shift/reduce conflict for MEAN in state 42 resolved as shift
WARNING: shift/reduce conflict for EQUAL in state 54 resolved as shift
WARNING: shift/reduce conflict for VAR in state 72 resolved as shift
WARNING: shift/reduce conflict for VAR in state 72 resolved as shift
WARNING: shift/reduce conflict for FUNCTION in state 72 resolved as shift
WARNING: shift/reduce conflict for ID in state 72 resolved as shift
WARNING: shift/reduce conflict for READ in state 72 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 72 resolved as shift
WARNING: shift/reduce conflict for IF in state 72 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 72 resolved as shift
WARNING: shift/reduce conflict for FOR in state 72 resolved as shift
WARNING: shift/reduce conflict for MEAN in state 72 resolved as shift
WARNING: shift/reduce conflict for FUNCTION in state 141 resolved as shift
WARNING: shift/reduce conflict for ID in state 141 resolved as shift
WARNING: shift/reduce conflict for READ in state 141 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 141 resolved as shift
WARNING: shift/reduce conflict for IF in state 141 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 141 resolved as shift
WARNING: shift/reduce conflict for FOR in state 141 resolved as shift
WARNING: shift/reduce conflict for MEAN in state 141 resolved as shift
WARNING: shift/reduce conflict for SEMICOLON in state 164 resolved as shift
WARNING: shift/reduce conflict for FUNCTION in state 164 resolved as shift
WARNING: shift/reduce conflict for ID in state 164 resolved as shift
WARNING: shift/reduce conflict for READ in state 164 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 164 resolved as shift
WARNING: shift/reduce conflict for IF in state 164 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 164 resolved as shift
WARNING: shift/reduce conflict for FOR in state 164 resolved as shift
WARNING: shift/reduce conflict for MEAN in state 164 resolved as shift
WARNING: shift/reduce conflict for SEMICOLON in state 180 resolved as shift
WARNING: shift/reduce conflict for FUNCTION in state 180 resolved as shift
WARNING: shift/reduce conflict for ID in state 180 resolved as shift
WARNING: shift/reduce conflict for READ in state 180 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 180 resolved as shift
WARNING: shift/reduce conflict for IF in state 180 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 180 resolved as shift
WARNING: shift/reduce conflict for FOR in state 180 resolved as shift
WARNING: shift/reduce conflict for MEAN in state 180 resolved as shift
WARNING: shift/reduce conflict for FUNCTION in state 213 resolved as shift
WARNING: shift/reduce conflict for ID in state 213 resolved as shift
WARNING: shift/reduce conflict for READ in state 213 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 213 resolved as shift
WARNING: shift/reduce conflict for IF in state 213 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 213 resolved as shift
WARNING: shift/reduce conflict for FOR in state 213 resolved as shift
WARNING: shift/reduce conflict for MEAN in state 213 resolved as shift
WARNING: shift/reduce conflict for FUNCTION in state 214 resolved as shift
WARNING: shift/reduce conflict for ID in state 214 resolved as shift
WARNING: shift/reduce conflict for READ in state 214 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 214 resolved as shift
WARNING: shift/reduce conflict for IF in state 214 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 214 resolved as shift
WARNING: shift/reduce conflict for FOR in state 214 resolved as shift
WARNING: shift/reduce conflict for MEAN in state 214 resolved as shift
WARNING: shift/reduce conflict for RBRACKET in state 219 resolved as shift
WARNING: shift/reduce conflict for FUNCTION in state 219 resolved as shift
WARNING: shift/reduce conflict for ID in state 219 resolved as shift
WARNING: shift/reduce conflict for READ in state 219 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 219 resolved as shift
WARNING: shift/reduce conflict for IF in state 219 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 219 resolved as shift
WARNING: shift/reduce conflict for FOR in state 219 resolved as shift
WARNING: shift/reduce conflict for MEAN in state 219 resolved as shift
WARNING: shift/reduce conflict for RBRACKET in state 221 resolved as shift
WARNING: shift/reduce conflict for FUNCTION in state 221 resolved as shift
WARNING: shift/reduce conflict for ID in state 221 resolved as shift
WARNING: shift/reduce conflict for READ in state 221 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 221 resolved as shift
WARNING: shift/reduce conflict for IF in state 221 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 221 resolved as shift
WARNING: shift/reduce conflict for FOR in state 221 resolved as shift
WARNING: shift/reduce conflict for MEAN in state 221 resolved as shift
WARNING: reduce/reduce conflict in state 11 resolved using rule (decvar -> VAR decvarp)
WARNING: rejected rule (decvar -> <empty>) in state 11
WARNING: reduce/reduce conflict in state 37 resolved using rule (decvar -> <empty>)
WARNING: rejected rule (body -> <empty>) in state 37
WARNING: reduce/reduce conflict in state 37 resolved using rule (decvar -> <empty>)
WARNING: rejected rule (statements -> <empty>) in state 37
WARNING: reduce/reduce conflict in state 38 resolved using rule (decvar -> <empty>)
WARNING: rejected rule (body -> <empty>) in state 38
WARNING: reduce/reduce conflict in state 38 resolved using rule (decvar -> <empty>)
WARNING: rejected rule (statements -> <empty>) in state 38
WARNING: reduce/reduce conflict in state 41 resolved using rule (body -> decvar)
WARNING: rejected rule (statements -> <empty>) in state 41
WARNING: reduce/reduce conflict in state 42 resolved using rule (decvar -> <empty>)
WARNING: rejected rule (body -> <empty>) in state 42
WARNING: reduce/reduce conflict in state 42 resolved using rule (decvar -> <empty>)
WARNING: rejected rule (statements -> <empty>) in state 42
WARNING: reduce/reduce conflict in state 72 resolved using rule (decvar -> <empty>)
WARNING: rejected rule (body -> <empty>) in state 72
WARNING: reduce/reduce conflict in state 72 resolved using rule (decvar -> <empty>)
WARNING: rejected rule (statements -> <empty>) in state 72
WARNING: Rule (body -> <empty>) is never reduced
