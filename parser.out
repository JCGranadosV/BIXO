Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    ASSIGN
    CHAR
    COLON
    END
    FUNCESP
    GTE
    IFEQUAL
    LTE
    NUMPY
    QUOTE
    STRING

Grammar

Rule 0     S' -> program
Rule 1     program -> PROGRAM gotomain ID SEMICOLON decvar modules
Rule 2     gotomain -> <empty>
Rule 3     decvar -> VAR decvarp
Rule 4     decvar -> VAR decvarp decvar
Rule 5     decvar -> <empty>
Rule 6     decvarp -> type decvarpp SEMICOLON
Rule 7     decvarpp -> ID COMMA decvarpp
Rule 8     decvarpp -> ID
Rule 9     type -> INT
Rule 10    type -> FLOAT
Rule 11    function -> FUNCTION type decfunc LPAREN param RPAREN LBRACE body RBRACE
Rule 12    decfunc -> ID
Rule 13    voidfunction -> FUNCTION VOID decfunc LPAREN param RPAREN LBRACE body RBRACE
Rule 14    mainfunction -> MAIN LPAREN RPAREN LBRACE body RBRACE
Rule 15    modules -> function modules
Rule 16    modules -> voidfunction modules
Rule 17    modules -> function
Rule 18    modules -> voidfunction
Rule 19    body -> decvar statements body
Rule 20    body -> statements body
Rule 21    body -> decvar
Rule 22    body -> <empty>
Rule 23    param -> decvar
Rule 24    param -> <empty>
Rule 25    exp -> texp
Rule 26    exp -> texp OR exp
Rule 27    texp -> gexp
Rule 28    texp -> gexp AND texp
Rule 29    gexp -> mexp
Rule 30    gexp -> mexp gexpp mexp
Rule 31    gexpp -> LT
Rule 32    gexpp -> GT
Rule 33    gexpp -> EQUAL
Rule 34    gexpp -> DIFF
Rule 35    mexp -> t
Rule 36    mexp -> t PLUS mexp
Rule 37    mexp -> t MINUS mexp
Rule 38    t -> f
Rule 39    t -> f MULT t
Rule 40    t -> f DIV t
Rule 41    f -> LPAREN exp RPAREN
Rule 42    f -> CTI
Rule 43    f -> CTF
Rule 44    f -> var
Rule 45    f -> call
Rule 46    statements -> assign
Rule 47    statements -> function
Rule 48    statements -> voidfunction
Rule 49    statements -> call
Rule 50    statements -> read
Rule 51    statements -> print
Rule 52    statements -> if
Rule 53    statements -> while
Rule 54    statements -> for
Rule 55    assign -> var EQUAL exp SEMICOLON
Rule 56    read -> READ var
Rule 57    print -> PRINT LPAREN printp
Rule 58    printp -> exp RPAREN
Rule 59    printp -> exp COMMA printp
Rule 60    var -> ID
Rule 61    call -> ID LPAREN callp RPAREN
Rule 62    callp -> exp SEMICOLON callp
Rule 63    callp -> exp
Rule 64    if -> IF LPAREN exp RPAREN quadsIf statements ifelse jumpsIf
Rule 65    ifelse -> <empty>
Rule 66    ifelse -> ELSE quadsElse statements
Rule 67    quadsIf -> <empty>
Rule 68    jumpsIf -> <empty>
Rule 69    quadsElse -> <empty>
Rule 70    while -> WHILE LPAREN saveJumps exp RPAREN quadsWhile statements jumpsWhile whilep
Rule 71    whilep -> SEMICOLON
Rule 72    whilep -> statements whilep
Rule 73    saveJumps -> <empty>
Rule 74    quadsWhile -> <empty>
Rule 75    jumpsWhile -> <empty>
Rule 76    for -> FOR LPAREN var SEMICOLON exp SEMICOLON exp RPAREN LBRACKET statements forp
Rule 77    forp -> RBRACKET
Rule 78    forp -> statements forp
Rule 79    funcesp -> array
Rule 80    funcesp -> matrix
Rule 81    funcesp -> mean
Rule 82    funcesp -> layers
Rule 83    funcesp -> sequential
Rule 84    funcesp -> compile
Rule 85    funcesp -> fit
Rule 86    funcesp -> predict
Rule 87    funcesp -> getweights
Rule 88    array -> ID EQUAL ARRAY LPAREN var arrayp
Rule 89    arrayp -> RPAREN
Rule 90    arrayp -> COMMA var RPAREN
Rule 91    matrix -> ID EQUAL MATRIX LPAREN array matrixp
Rule 92    matrixp -> RPAREN
Rule 93    matrixp -> COMMA array RPAREN
Rule 94    mean -> MEAN LPAREN array RPAREN
Rule 95    layers -> ID EQUAL LAYERS LPAREN UNITS EQUAL INT RPAREN
Rule 96    sequential -> ID EQUAL SEQUENTIAL LPAREN LBRACKET layers sequentialp
Rule 97    sequentialp -> RBRACKET RPAREN
Rule 98    sequentialp -> COMMA layers sequentialp
Rule 99    compile -> sequential DOT COMPILE LPAREN RPAREN
Rule 100   fit -> ID EQUAL sequential DOT FIT LPAREN array COMMA array COMMA EPOCHS EQUAL INT COMMA VERBOSE EQUAL fitp
Rule 101   fitp -> TRUE RPAREN
Rule 102   fitp -> FALSE RPAREN
Rule 103   predict -> ID EQUAL sequential DOT PREDICT LPAREN LBRACKET predictp
Rule 104   predictp -> INT RBRACKET RPAREN
Rule 105   predictp -> FLOAT RBRACKET RPAREN
Rule 106   getweights -> layers DOT GETWEIGHTS LPAREN RPAREN
Rule 107   empty -> <empty>

Terminals, with rules where they appear

AND                  : 28
ARRAY                : 88
ASSIGN               : 
CHAR                 : 
COLON                : 
COMMA                : 7 59 90 93 98 100 100 100
COMPILE              : 99
CTF                  : 43
CTI                  : 42
DIFF                 : 34
DIV                  : 40
DOT                  : 99 100 103 106
ELSE                 : 66
END                  : 
EPOCHS               : 100
EQUAL                : 33 55 88 91 95 95 96 100 100 100 103
FALSE                : 102
FIT                  : 100
FLOAT                : 10 105
FOR                  : 76
FUNCESP              : 
FUNCTION             : 11 13
GETWEIGHTS           : 106
GT                   : 32
GTE                  : 
ID                   : 1 7 8 12 60 61 88 91 95 96 100 103
IF                   : 64
IFEQUAL              : 
INT                  : 9 95 100 104
LAYERS               : 95
LBRACE               : 11 13 14
LBRACKET             : 76 96 103
LPAREN               : 11 13 14 41 57 61 64 70 76 88 91 94 95 96 99 100 103 106
LT                   : 31
LTE                  : 
MAIN                 : 14
MATRIX               : 91
MEAN                 : 94
MINUS                : 37
MULT                 : 39
NUMPY                : 
OR                   : 26
PLUS                 : 36
PREDICT              : 103
PRINT                : 57
PROGRAM              : 1
QUOTE                : 
RBRACE               : 11 13 14
RBRACKET             : 77 97 104 105
READ                 : 56
RPAREN               : 11 13 14 41 58 61 64 70 76 89 90 92 93 94 95 97 99 101 102 104 105 106
SEMICOLON            : 1 6 55 62 71 76 76
SEQUENTIAL           : 96
STRING               : 
TRUE                 : 101
UNITS                : 95
VAR                  : 3 4
VERBOSE              : 100
VOID                 : 13
WHILE                : 70
error                : 

Nonterminals, with rules where they appear

array                : 79 91 93 94 100 100
arrayp               : 88
assign               : 46
body                 : 11 13 14 19 20
call                 : 45 49
callp                : 61 62
compile              : 84
decfunc              : 11 13
decvar               : 1 4 19 21 23
decvarp              : 3 4
decvarpp             : 6 7
empty                : 
exp                  : 26 41 55 58 59 62 63 64 70 76 76
f                    : 38 39 40
fit                  : 85
fitp                 : 100
for                  : 54
forp                 : 76 78
funcesp              : 
function             : 15 17 47
getweights           : 87
gexp                 : 27 28
gexpp                : 30
gotomain             : 1
if                   : 52
ifelse               : 64
jumpsIf              : 64
jumpsWhile           : 70
layers               : 82 96 98 106
mainfunction         : 
matrix               : 80
matrixp              : 91
mean                 : 81
mexp                 : 29 30 30 36 37
modules              : 1 15 16
param                : 11 13
predict              : 86
predictp             : 103
print                : 51
printp               : 57 59
program              : 0
quadsElse            : 66
quadsIf              : 64
quadsWhile           : 70
read                 : 50
saveJumps            : 70
sequential           : 83 99 100 103
sequentialp          : 96 98
statements           : 19 20 64 66 70 72 76 78
t                    : 35 36 37 39 40
texp                 : 25 26 28
type                 : 6 11
var                  : 44 55 56 76 88 90
voidfunction         : 16 18 48
while                : 53
whilep               : 70 72

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . PROGRAM gotomain ID SEMICOLON decvar modules

    PROGRAM         shift and go to state 2

    program                        shift and go to state 1

state 1

    (0) S' -> program .



state 2

    (1) program -> PROGRAM . gotomain ID SEMICOLON decvar modules
    (2) gotomain -> .

    ID              reduce using rule 2 (gotomain -> .)

    gotomain                       shift and go to state 3

state 3

    (1) program -> PROGRAM gotomain . ID SEMICOLON decvar modules

    ID              shift and go to state 4


state 4

    (1) program -> PROGRAM gotomain ID . SEMICOLON decvar modules

    SEMICOLON       shift and go to state 5


state 5

    (1) program -> PROGRAM gotomain ID SEMICOLON . decvar modules
    (3) decvar -> . VAR decvarp
    (4) decvar -> . VAR decvarp decvar
    (5) decvar -> .

    VAR             shift and go to state 7
    FUNCTION        reduce using rule 5 (decvar -> .)

    decvar                         shift and go to state 6

state 6

    (1) program -> PROGRAM gotomain ID SEMICOLON decvar . modules
    (15) modules -> . function modules
    (16) modules -> . voidfunction modules
    (17) modules -> . function
    (18) modules -> . voidfunction
    (11) function -> . FUNCTION type decfunc LPAREN param RPAREN LBRACE body RBRACE
    (13) voidfunction -> . FUNCTION VOID decfunc LPAREN param RPAREN LBRACE body RBRACE

    FUNCTION        shift and go to state 11

    modules                        shift and go to state 8
    function                       shift and go to state 9
    voidfunction                   shift and go to state 10

state 7

    (3) decvar -> VAR . decvarp
    (4) decvar -> VAR . decvarp decvar
    (6) decvarp -> . type decvarpp SEMICOLON
    (9) type -> . INT
    (10) type -> . FLOAT

    INT             shift and go to state 14
    FLOAT           shift and go to state 15

    decvarp                        shift and go to state 12
    type                           shift and go to state 13

state 8

    (1) program -> PROGRAM gotomain ID SEMICOLON decvar modules .

    $end            reduce using rule 1 (program -> PROGRAM gotomain ID SEMICOLON decvar modules .)


state 9

    (15) modules -> function . modules
    (17) modules -> function .
    (15) modules -> . function modules
    (16) modules -> . voidfunction modules
    (17) modules -> . function
    (18) modules -> . voidfunction
    (11) function -> . FUNCTION type decfunc LPAREN param RPAREN LBRACE body RBRACE
    (13) voidfunction -> . FUNCTION VOID decfunc LPAREN param RPAREN LBRACE body RBRACE

    $end            reduce using rule 17 (modules -> function .)
    FUNCTION        shift and go to state 11

    function                       shift and go to state 9
    modules                        shift and go to state 16
    voidfunction                   shift and go to state 10

state 10

    (16) modules -> voidfunction . modules
    (18) modules -> voidfunction .
    (15) modules -> . function modules
    (16) modules -> . voidfunction modules
    (17) modules -> . function
    (18) modules -> . voidfunction
    (11) function -> . FUNCTION type decfunc LPAREN param RPAREN LBRACE body RBRACE
    (13) voidfunction -> . FUNCTION VOID decfunc LPAREN param RPAREN LBRACE body RBRACE

    $end            reduce using rule 18 (modules -> voidfunction .)
    FUNCTION        shift and go to state 11

    voidfunction                   shift and go to state 10
    modules                        shift and go to state 17
    function                       shift and go to state 9

state 11

    (11) function -> FUNCTION . type decfunc LPAREN param RPAREN LBRACE body RBRACE
    (13) voidfunction -> FUNCTION . VOID decfunc LPAREN param RPAREN LBRACE body RBRACE
    (9) type -> . INT
    (10) type -> . FLOAT

    VOID            shift and go to state 19
    INT             shift and go to state 14
    FLOAT           shift and go to state 15

    type                           shift and go to state 18

state 12

    (3) decvar -> VAR decvarp .
    (4) decvar -> VAR decvarp . decvar
    (3) decvar -> . VAR decvarp
    (4) decvar -> . VAR decvarp decvar
    (5) decvar -> .

  ! reduce/reduce conflict for FUNCTION resolved using rule 3 (decvar -> VAR decvarp .)
  ! reduce/reduce conflict for RPAREN resolved using rule 3 (decvar -> VAR decvarp .)
  ! reduce/reduce conflict for ID resolved using rule 3 (decvar -> VAR decvarp .)
  ! reduce/reduce conflict for READ resolved using rule 3 (decvar -> VAR decvarp .)
  ! reduce/reduce conflict for PRINT resolved using rule 3 (decvar -> VAR decvarp .)
  ! reduce/reduce conflict for IF resolved using rule 3 (decvar -> VAR decvarp .)
  ! reduce/reduce conflict for WHILE resolved using rule 3 (decvar -> VAR decvarp .)
  ! reduce/reduce conflict for FOR resolved using rule 3 (decvar -> VAR decvarp .)
  ! reduce/reduce conflict for RBRACE resolved using rule 3 (decvar -> VAR decvarp .)
    FUNCTION        reduce using rule 3 (decvar -> VAR decvarp .)
    RPAREN          reduce using rule 3 (decvar -> VAR decvarp .)
    ID              reduce using rule 3 (decvar -> VAR decvarp .)
    READ            reduce using rule 3 (decvar -> VAR decvarp .)
    PRINT           reduce using rule 3 (decvar -> VAR decvarp .)
    IF              reduce using rule 3 (decvar -> VAR decvarp .)
    WHILE           reduce using rule 3 (decvar -> VAR decvarp .)
    FOR             reduce using rule 3 (decvar -> VAR decvarp .)
    RBRACE          reduce using rule 3 (decvar -> VAR decvarp .)
    VAR             shift and go to state 7

  ! FUNCTION        [ reduce using rule 5 (decvar -> .) ]
  ! RPAREN          [ reduce using rule 5 (decvar -> .) ]
  ! ID              [ reduce using rule 5 (decvar -> .) ]
  ! READ            [ reduce using rule 5 (decvar -> .) ]
  ! PRINT           [ reduce using rule 5 (decvar -> .) ]
  ! IF              [ reduce using rule 5 (decvar -> .) ]
  ! WHILE           [ reduce using rule 5 (decvar -> .) ]
  ! FOR             [ reduce using rule 5 (decvar -> .) ]
  ! RBRACE          [ reduce using rule 5 (decvar -> .) ]

    decvar                         shift and go to state 20

state 13

    (6) decvarp -> type . decvarpp SEMICOLON
    (7) decvarpp -> . ID COMMA decvarpp
    (8) decvarpp -> . ID

    ID              shift and go to state 22

    decvarpp                       shift and go to state 21

state 14

    (9) type -> INT .

    ID              reduce using rule 9 (type -> INT .)


state 15

    (10) type -> FLOAT .

    ID              reduce using rule 10 (type -> FLOAT .)


state 16

    (15) modules -> function modules .

    $end            reduce using rule 15 (modules -> function modules .)


state 17

    (16) modules -> voidfunction modules .

    $end            reduce using rule 16 (modules -> voidfunction modules .)


state 18

    (11) function -> FUNCTION type . decfunc LPAREN param RPAREN LBRACE body RBRACE
    (12) decfunc -> . ID

    ID              shift and go to state 24

    decfunc                        shift and go to state 23

state 19

    (13) voidfunction -> FUNCTION VOID . decfunc LPAREN param RPAREN LBRACE body RBRACE
    (12) decfunc -> . ID

    ID              shift and go to state 24

    decfunc                        shift and go to state 25

state 20

    (4) decvar -> VAR decvarp decvar .

    FUNCTION        reduce using rule 4 (decvar -> VAR decvarp decvar .)
    RPAREN          reduce using rule 4 (decvar -> VAR decvarp decvar .)
    ID              reduce using rule 4 (decvar -> VAR decvarp decvar .)
    READ            reduce using rule 4 (decvar -> VAR decvarp decvar .)
    PRINT           reduce using rule 4 (decvar -> VAR decvarp decvar .)
    IF              reduce using rule 4 (decvar -> VAR decvarp decvar .)
    WHILE           reduce using rule 4 (decvar -> VAR decvarp decvar .)
    FOR             reduce using rule 4 (decvar -> VAR decvarp decvar .)
    RBRACE          reduce using rule 4 (decvar -> VAR decvarp decvar .)


state 21

    (6) decvarp -> type decvarpp . SEMICOLON

    SEMICOLON       shift and go to state 26


state 22

    (7) decvarpp -> ID . COMMA decvarpp
    (8) decvarpp -> ID .

    COMMA           shift and go to state 27
    SEMICOLON       reduce using rule 8 (decvarpp -> ID .)


state 23

    (11) function -> FUNCTION type decfunc . LPAREN param RPAREN LBRACE body RBRACE

    LPAREN          shift and go to state 28


state 24

    (12) decfunc -> ID .

    LPAREN          reduce using rule 12 (decfunc -> ID .)


state 25

    (13) voidfunction -> FUNCTION VOID decfunc . LPAREN param RPAREN LBRACE body RBRACE

    LPAREN          shift and go to state 29


state 26

    (6) decvarp -> type decvarpp SEMICOLON .

    VAR             reduce using rule 6 (decvarp -> type decvarpp SEMICOLON .)
    FUNCTION        reduce using rule 6 (decvarp -> type decvarpp SEMICOLON .)
    RPAREN          reduce using rule 6 (decvarp -> type decvarpp SEMICOLON .)
    ID              reduce using rule 6 (decvarp -> type decvarpp SEMICOLON .)
    READ            reduce using rule 6 (decvarp -> type decvarpp SEMICOLON .)
    PRINT           reduce using rule 6 (decvarp -> type decvarpp SEMICOLON .)
    IF              reduce using rule 6 (decvarp -> type decvarpp SEMICOLON .)
    WHILE           reduce using rule 6 (decvarp -> type decvarpp SEMICOLON .)
    FOR             reduce using rule 6 (decvarp -> type decvarpp SEMICOLON .)
    RBRACE          reduce using rule 6 (decvarp -> type decvarpp SEMICOLON .)


state 27

    (7) decvarpp -> ID COMMA . decvarpp
    (7) decvarpp -> . ID COMMA decvarpp
    (8) decvarpp -> . ID

    ID              shift and go to state 22

    decvarpp                       shift and go to state 30

state 28

    (11) function -> FUNCTION type decfunc LPAREN . param RPAREN LBRACE body RBRACE
    (23) param -> . decvar
    (24) param -> .
    (3) decvar -> . VAR decvarp
    (4) decvar -> . VAR decvarp decvar
    (5) decvar -> .

  ! reduce/reduce conflict for RPAREN resolved using rule 5 (decvar -> .)
    VAR             shift and go to state 7
    RPAREN          reduce using rule 5 (decvar -> .)

  ! RPAREN          [ reduce using rule 24 (param -> .) ]

    param                          shift and go to state 31
    decvar                         shift and go to state 32

state 29

    (13) voidfunction -> FUNCTION VOID decfunc LPAREN . param RPAREN LBRACE body RBRACE
    (23) param -> . decvar
    (24) param -> .
    (3) decvar -> . VAR decvarp
    (4) decvar -> . VAR decvarp decvar
    (5) decvar -> .

  ! reduce/reduce conflict for RPAREN resolved using rule 5 (decvar -> .)
    VAR             shift and go to state 7
    RPAREN          reduce using rule 5 (decvar -> .)

  ! RPAREN          [ reduce using rule 24 (param -> .) ]

    param                          shift and go to state 33
    decvar                         shift and go to state 32

state 30

    (7) decvarpp -> ID COMMA decvarpp .

    SEMICOLON       reduce using rule 7 (decvarpp -> ID COMMA decvarpp .)


state 31

    (11) function -> FUNCTION type decfunc LPAREN param . RPAREN LBRACE body RBRACE

    RPAREN          shift and go to state 34


state 32

    (23) param -> decvar .

    RPAREN          reduce using rule 23 (param -> decvar .)


state 33

    (13) voidfunction -> FUNCTION VOID decfunc LPAREN param . RPAREN LBRACE body RBRACE

    RPAREN          shift and go to state 35


state 34

    (11) function -> FUNCTION type decfunc LPAREN param RPAREN . LBRACE body RBRACE

    LBRACE          shift and go to state 36


state 35

    (13) voidfunction -> FUNCTION VOID decfunc LPAREN param RPAREN . LBRACE body RBRACE

    LBRACE          shift and go to state 37


state 36

    (11) function -> FUNCTION type decfunc LPAREN param RPAREN LBRACE . body RBRACE
    (19) body -> . decvar statements body
    (20) body -> . statements body
    (21) body -> . decvar
    (22) body -> .
    (3) decvar -> . VAR decvarp
    (4) decvar -> . VAR decvarp decvar
    (5) decvar -> .
    (46) statements -> . assign
    (47) statements -> . function
    (48) statements -> . voidfunction
    (49) statements -> . call
    (50) statements -> . read
    (51) statements -> . print
    (52) statements -> . if
    (53) statements -> . while
    (54) statements -> . for
    (55) assign -> . var EQUAL exp SEMICOLON
    (11) function -> . FUNCTION type decfunc LPAREN param RPAREN LBRACE body RBRACE
    (13) voidfunction -> . FUNCTION VOID decfunc LPAREN param RPAREN LBRACE body RBRACE
    (61) call -> . ID LPAREN callp RPAREN
    (56) read -> . READ var
    (57) print -> . PRINT LPAREN printp
    (64) if -> . IF LPAREN exp RPAREN quadsIf statements ifelse jumpsIf
    (70) while -> . WHILE LPAREN saveJumps exp RPAREN quadsWhile statements jumpsWhile whilep
    (76) for -> . FOR LPAREN var SEMICOLON exp SEMICOLON exp RPAREN LBRACKET statements forp
    (60) var -> . ID

  ! reduce/reduce conflict for RBRACE resolved using rule 5 (decvar -> .)
  ! shift/reduce conflict for FUNCTION resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for READ resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
    VAR             shift and go to state 7
    RBRACE          reduce using rule 5 (decvar -> .)
    FUNCTION        shift and go to state 11
    ID              shift and go to state 51
    READ            shift and go to state 52
    PRINT           shift and go to state 53
    IF              shift and go to state 54
    WHILE           shift and go to state 55
    FOR             shift and go to state 56

  ! RBRACE          [ reduce using rule 22 (body -> .) ]
  ! FUNCTION        [ reduce using rule 5 (decvar -> .) ]
  ! ID              [ reduce using rule 5 (decvar -> .) ]
  ! READ            [ reduce using rule 5 (decvar -> .) ]
  ! PRINT           [ reduce using rule 5 (decvar -> .) ]
  ! IF              [ reduce using rule 5 (decvar -> .) ]
  ! WHILE           [ reduce using rule 5 (decvar -> .) ]
  ! FOR             [ reduce using rule 5 (decvar -> .) ]

    body                           shift and go to state 38
    decvar                         shift and go to state 39
    statements                     shift and go to state 40
    assign                         shift and go to state 41
    function                       shift and go to state 42
    voidfunction                   shift and go to state 43
    call                           shift and go to state 44
    read                           shift and go to state 45
    print                          shift and go to state 46
    if                             shift and go to state 47
    while                          shift and go to state 48
    for                            shift and go to state 49
    var                            shift and go to state 50

state 37

    (13) voidfunction -> FUNCTION VOID decfunc LPAREN param RPAREN LBRACE . body RBRACE
    (19) body -> . decvar statements body
    (20) body -> . statements body
    (21) body -> . decvar
    (22) body -> .
    (3) decvar -> . VAR decvarp
    (4) decvar -> . VAR decvarp decvar
    (5) decvar -> .
    (46) statements -> . assign
    (47) statements -> . function
    (48) statements -> . voidfunction
    (49) statements -> . call
    (50) statements -> . read
    (51) statements -> . print
    (52) statements -> . if
    (53) statements -> . while
    (54) statements -> . for
    (55) assign -> . var EQUAL exp SEMICOLON
    (11) function -> . FUNCTION type decfunc LPAREN param RPAREN LBRACE body RBRACE
    (13) voidfunction -> . FUNCTION VOID decfunc LPAREN param RPAREN LBRACE body RBRACE
    (61) call -> . ID LPAREN callp RPAREN
    (56) read -> . READ var
    (57) print -> . PRINT LPAREN printp
    (64) if -> . IF LPAREN exp RPAREN quadsIf statements ifelse jumpsIf
    (70) while -> . WHILE LPAREN saveJumps exp RPAREN quadsWhile statements jumpsWhile whilep
    (76) for -> . FOR LPAREN var SEMICOLON exp SEMICOLON exp RPAREN LBRACKET statements forp
    (60) var -> . ID

  ! reduce/reduce conflict for RBRACE resolved using rule 5 (decvar -> .)
  ! shift/reduce conflict for FUNCTION resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for READ resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
    VAR             shift and go to state 7
    RBRACE          reduce using rule 5 (decvar -> .)
    FUNCTION        shift and go to state 11
    ID              shift and go to state 51
    READ            shift and go to state 52
    PRINT           shift and go to state 53
    IF              shift and go to state 54
    WHILE           shift and go to state 55
    FOR             shift and go to state 56

  ! RBRACE          [ reduce using rule 22 (body -> .) ]
  ! FUNCTION        [ reduce using rule 5 (decvar -> .) ]
  ! ID              [ reduce using rule 5 (decvar -> .) ]
  ! READ            [ reduce using rule 5 (decvar -> .) ]
  ! PRINT           [ reduce using rule 5 (decvar -> .) ]
  ! IF              [ reduce using rule 5 (decvar -> .) ]
  ! WHILE           [ reduce using rule 5 (decvar -> .) ]
  ! FOR             [ reduce using rule 5 (decvar -> .) ]

    body                           shift and go to state 57
    decvar                         shift and go to state 39
    statements                     shift and go to state 40
    assign                         shift and go to state 41
    function                       shift and go to state 42
    voidfunction                   shift and go to state 43
    call                           shift and go to state 44
    read                           shift and go to state 45
    print                          shift and go to state 46
    if                             shift and go to state 47
    while                          shift and go to state 48
    for                            shift and go to state 49
    var                            shift and go to state 50

state 38

    (11) function -> FUNCTION type decfunc LPAREN param RPAREN LBRACE body . RBRACE

    RBRACE          shift and go to state 58


state 39

    (19) body -> decvar . statements body
    (21) body -> decvar .
    (46) statements -> . assign
    (47) statements -> . function
    (48) statements -> . voidfunction
    (49) statements -> . call
    (50) statements -> . read
    (51) statements -> . print
    (52) statements -> . if
    (53) statements -> . while
    (54) statements -> . for
    (55) assign -> . var EQUAL exp SEMICOLON
    (11) function -> . FUNCTION type decfunc LPAREN param RPAREN LBRACE body RBRACE
    (13) voidfunction -> . FUNCTION VOID decfunc LPAREN param RPAREN LBRACE body RBRACE
    (61) call -> . ID LPAREN callp RPAREN
    (56) read -> . READ var
    (57) print -> . PRINT LPAREN printp
    (64) if -> . IF LPAREN exp RPAREN quadsIf statements ifelse jumpsIf
    (70) while -> . WHILE LPAREN saveJumps exp RPAREN quadsWhile statements jumpsWhile whilep
    (76) for -> . FOR LPAREN var SEMICOLON exp SEMICOLON exp RPAREN LBRACKET statements forp
    (60) var -> . ID

    RBRACE          reduce using rule 21 (body -> decvar .)
    FUNCTION        shift and go to state 11
    ID              shift and go to state 51
    READ            shift and go to state 52
    PRINT           shift and go to state 53
    IF              shift and go to state 54
    WHILE           shift and go to state 55
    FOR             shift and go to state 56

    statements                     shift and go to state 59
    assign                         shift and go to state 41
    function                       shift and go to state 42
    voidfunction                   shift and go to state 43
    call                           shift and go to state 44
    read                           shift and go to state 45
    print                          shift and go to state 46
    if                             shift and go to state 47
    while                          shift and go to state 48
    for                            shift and go to state 49
    var                            shift and go to state 50

state 40

    (20) body -> statements . body
    (19) body -> . decvar statements body
    (20) body -> . statements body
    (21) body -> . decvar
    (22) body -> .
    (3) decvar -> . VAR decvarp
    (4) decvar -> . VAR decvarp decvar
    (5) decvar -> .
    (46) statements -> . assign
    (47) statements -> . function
    (48) statements -> . voidfunction
    (49) statements -> . call
    (50) statements -> . read
    (51) statements -> . print
    (52) statements -> . if
    (53) statements -> . while
    (54) statements -> . for
    (55) assign -> . var EQUAL exp SEMICOLON
    (11) function -> . FUNCTION type decfunc LPAREN param RPAREN LBRACE body RBRACE
    (13) voidfunction -> . FUNCTION VOID decfunc LPAREN param RPAREN LBRACE body RBRACE
    (61) call -> . ID LPAREN callp RPAREN
    (56) read -> . READ var
    (57) print -> . PRINT LPAREN printp
    (64) if -> . IF LPAREN exp RPAREN quadsIf statements ifelse jumpsIf
    (70) while -> . WHILE LPAREN saveJumps exp RPAREN quadsWhile statements jumpsWhile whilep
    (76) for -> . FOR LPAREN var SEMICOLON exp SEMICOLON exp RPAREN LBRACKET statements forp
    (60) var -> . ID

  ! reduce/reduce conflict for RBRACE resolved using rule 5 (decvar -> .)
  ! shift/reduce conflict for FUNCTION resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for READ resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
    VAR             shift and go to state 7
    RBRACE          reduce using rule 5 (decvar -> .)
    FUNCTION        shift and go to state 11
    ID              shift and go to state 51
    READ            shift and go to state 52
    PRINT           shift and go to state 53
    IF              shift and go to state 54
    WHILE           shift and go to state 55
    FOR             shift and go to state 56

  ! RBRACE          [ reduce using rule 22 (body -> .) ]
  ! FUNCTION        [ reduce using rule 5 (decvar -> .) ]
  ! ID              [ reduce using rule 5 (decvar -> .) ]
  ! READ            [ reduce using rule 5 (decvar -> .) ]
  ! PRINT           [ reduce using rule 5 (decvar -> .) ]
  ! IF              [ reduce using rule 5 (decvar -> .) ]
  ! WHILE           [ reduce using rule 5 (decvar -> .) ]
  ! FOR             [ reduce using rule 5 (decvar -> .) ]

    statements                     shift and go to state 40
    body                           shift and go to state 60
    decvar                         shift and go to state 39
    assign                         shift and go to state 41
    function                       shift and go to state 42
    voidfunction                   shift and go to state 43
    call                           shift and go to state 44
    read                           shift and go to state 45
    print                          shift and go to state 46
    if                             shift and go to state 47
    while                          shift and go to state 48
    for                            shift and go to state 49
    var                            shift and go to state 50

state 41

    (46) statements -> assign .

    VAR             reduce using rule 46 (statements -> assign .)
    FUNCTION        reduce using rule 46 (statements -> assign .)
    ID              reduce using rule 46 (statements -> assign .)
    READ            reduce using rule 46 (statements -> assign .)
    PRINT           reduce using rule 46 (statements -> assign .)
    IF              reduce using rule 46 (statements -> assign .)
    WHILE           reduce using rule 46 (statements -> assign .)
    FOR             reduce using rule 46 (statements -> assign .)
    RBRACE          reduce using rule 46 (statements -> assign .)
    ELSE            reduce using rule 46 (statements -> assign .)
    SEMICOLON       reduce using rule 46 (statements -> assign .)
    RBRACKET        reduce using rule 46 (statements -> assign .)


state 42

    (47) statements -> function .

    VAR             reduce using rule 47 (statements -> function .)
    FUNCTION        reduce using rule 47 (statements -> function .)
    ID              reduce using rule 47 (statements -> function .)
    READ            reduce using rule 47 (statements -> function .)
    PRINT           reduce using rule 47 (statements -> function .)
    IF              reduce using rule 47 (statements -> function .)
    WHILE           reduce using rule 47 (statements -> function .)
    FOR             reduce using rule 47 (statements -> function .)
    RBRACE          reduce using rule 47 (statements -> function .)
    ELSE            reduce using rule 47 (statements -> function .)
    SEMICOLON       reduce using rule 47 (statements -> function .)
    RBRACKET        reduce using rule 47 (statements -> function .)


state 43

    (48) statements -> voidfunction .

    VAR             reduce using rule 48 (statements -> voidfunction .)
    FUNCTION        reduce using rule 48 (statements -> voidfunction .)
    ID              reduce using rule 48 (statements -> voidfunction .)
    READ            reduce using rule 48 (statements -> voidfunction .)
    PRINT           reduce using rule 48 (statements -> voidfunction .)
    IF              reduce using rule 48 (statements -> voidfunction .)
    WHILE           reduce using rule 48 (statements -> voidfunction .)
    FOR             reduce using rule 48 (statements -> voidfunction .)
    RBRACE          reduce using rule 48 (statements -> voidfunction .)
    ELSE            reduce using rule 48 (statements -> voidfunction .)
    SEMICOLON       reduce using rule 48 (statements -> voidfunction .)
    RBRACKET        reduce using rule 48 (statements -> voidfunction .)


state 44

    (49) statements -> call .

    VAR             reduce using rule 49 (statements -> call .)
    FUNCTION        reduce using rule 49 (statements -> call .)
    ID              reduce using rule 49 (statements -> call .)
    READ            reduce using rule 49 (statements -> call .)
    PRINT           reduce using rule 49 (statements -> call .)
    IF              reduce using rule 49 (statements -> call .)
    WHILE           reduce using rule 49 (statements -> call .)
    FOR             reduce using rule 49 (statements -> call .)
    RBRACE          reduce using rule 49 (statements -> call .)
    ELSE            reduce using rule 49 (statements -> call .)
    SEMICOLON       reduce using rule 49 (statements -> call .)
    RBRACKET        reduce using rule 49 (statements -> call .)


state 45

    (50) statements -> read .

    VAR             reduce using rule 50 (statements -> read .)
    FUNCTION        reduce using rule 50 (statements -> read .)
    ID              reduce using rule 50 (statements -> read .)
    READ            reduce using rule 50 (statements -> read .)
    PRINT           reduce using rule 50 (statements -> read .)
    IF              reduce using rule 50 (statements -> read .)
    WHILE           reduce using rule 50 (statements -> read .)
    FOR             reduce using rule 50 (statements -> read .)
    RBRACE          reduce using rule 50 (statements -> read .)
    ELSE            reduce using rule 50 (statements -> read .)
    SEMICOLON       reduce using rule 50 (statements -> read .)
    RBRACKET        reduce using rule 50 (statements -> read .)


state 46

    (51) statements -> print .

    VAR             reduce using rule 51 (statements -> print .)
    FUNCTION        reduce using rule 51 (statements -> print .)
    ID              reduce using rule 51 (statements -> print .)
    READ            reduce using rule 51 (statements -> print .)
    PRINT           reduce using rule 51 (statements -> print .)
    IF              reduce using rule 51 (statements -> print .)
    WHILE           reduce using rule 51 (statements -> print .)
    FOR             reduce using rule 51 (statements -> print .)
    RBRACE          reduce using rule 51 (statements -> print .)
    ELSE            reduce using rule 51 (statements -> print .)
    SEMICOLON       reduce using rule 51 (statements -> print .)
    RBRACKET        reduce using rule 51 (statements -> print .)


state 47

    (52) statements -> if .

    VAR             reduce using rule 52 (statements -> if .)
    FUNCTION        reduce using rule 52 (statements -> if .)
    ID              reduce using rule 52 (statements -> if .)
    READ            reduce using rule 52 (statements -> if .)
    PRINT           reduce using rule 52 (statements -> if .)
    IF              reduce using rule 52 (statements -> if .)
    WHILE           reduce using rule 52 (statements -> if .)
    FOR             reduce using rule 52 (statements -> if .)
    RBRACE          reduce using rule 52 (statements -> if .)
    ELSE            reduce using rule 52 (statements -> if .)
    SEMICOLON       reduce using rule 52 (statements -> if .)
    RBRACKET        reduce using rule 52 (statements -> if .)


state 48

    (53) statements -> while .

    VAR             reduce using rule 53 (statements -> while .)
    FUNCTION        reduce using rule 53 (statements -> while .)
    ID              reduce using rule 53 (statements -> while .)
    READ            reduce using rule 53 (statements -> while .)
    PRINT           reduce using rule 53 (statements -> while .)
    IF              reduce using rule 53 (statements -> while .)
    WHILE           reduce using rule 53 (statements -> while .)
    FOR             reduce using rule 53 (statements -> while .)
    RBRACE          reduce using rule 53 (statements -> while .)
    ELSE            reduce using rule 53 (statements -> while .)
    SEMICOLON       reduce using rule 53 (statements -> while .)
    RBRACKET        reduce using rule 53 (statements -> while .)


state 49

    (54) statements -> for .

    VAR             reduce using rule 54 (statements -> for .)
    FUNCTION        reduce using rule 54 (statements -> for .)
    ID              reduce using rule 54 (statements -> for .)
    READ            reduce using rule 54 (statements -> for .)
    PRINT           reduce using rule 54 (statements -> for .)
    IF              reduce using rule 54 (statements -> for .)
    WHILE           reduce using rule 54 (statements -> for .)
    FOR             reduce using rule 54 (statements -> for .)
    RBRACE          reduce using rule 54 (statements -> for .)
    ELSE            reduce using rule 54 (statements -> for .)
    SEMICOLON       reduce using rule 54 (statements -> for .)
    RBRACKET        reduce using rule 54 (statements -> for .)


state 50

    (55) assign -> var . EQUAL exp SEMICOLON

    EQUAL           shift and go to state 61


state 51

    (61) call -> ID . LPAREN callp RPAREN
    (60) var -> ID .

    LPAREN          shift and go to state 62
    EQUAL           reduce using rule 60 (var -> ID .)


state 52

    (56) read -> READ . var
    (60) var -> . ID

    ID              shift and go to state 64

    var                            shift and go to state 63

state 53

    (57) print -> PRINT . LPAREN printp

    LPAREN          shift and go to state 65


state 54

    (64) if -> IF . LPAREN exp RPAREN quadsIf statements ifelse jumpsIf

    LPAREN          shift and go to state 66


state 55

    (70) while -> WHILE . LPAREN saveJumps exp RPAREN quadsWhile statements jumpsWhile whilep

    LPAREN          shift and go to state 67


state 56

    (76) for -> FOR . LPAREN var SEMICOLON exp SEMICOLON exp RPAREN LBRACKET statements forp

    LPAREN          shift and go to state 68


state 57

    (13) voidfunction -> FUNCTION VOID decfunc LPAREN param RPAREN LBRACE body . RBRACE

    RBRACE          shift and go to state 69


state 58

    (11) function -> FUNCTION type decfunc LPAREN param RPAREN LBRACE body RBRACE .

    FUNCTION        reduce using rule 11 (function -> FUNCTION type decfunc LPAREN param RPAREN LBRACE body RBRACE .)
    $end            reduce using rule 11 (function -> FUNCTION type decfunc LPAREN param RPAREN LBRACE body RBRACE .)
    VAR             reduce using rule 11 (function -> FUNCTION type decfunc LPAREN param RPAREN LBRACE body RBRACE .)
    ID              reduce using rule 11 (function -> FUNCTION type decfunc LPAREN param RPAREN LBRACE body RBRACE .)
    READ            reduce using rule 11 (function -> FUNCTION type decfunc LPAREN param RPAREN LBRACE body RBRACE .)
    PRINT           reduce using rule 11 (function -> FUNCTION type decfunc LPAREN param RPAREN LBRACE body RBRACE .)
    IF              reduce using rule 11 (function -> FUNCTION type decfunc LPAREN param RPAREN LBRACE body RBRACE .)
    WHILE           reduce using rule 11 (function -> FUNCTION type decfunc LPAREN param RPAREN LBRACE body RBRACE .)
    FOR             reduce using rule 11 (function -> FUNCTION type decfunc LPAREN param RPAREN LBRACE body RBRACE .)
    RBRACE          reduce using rule 11 (function -> FUNCTION type decfunc LPAREN param RPAREN LBRACE body RBRACE .)
    ELSE            reduce using rule 11 (function -> FUNCTION type decfunc LPAREN param RPAREN LBRACE body RBRACE .)
    SEMICOLON       reduce using rule 11 (function -> FUNCTION type decfunc LPAREN param RPAREN LBRACE body RBRACE .)
    RBRACKET        reduce using rule 11 (function -> FUNCTION type decfunc LPAREN param RPAREN LBRACE body RBRACE .)


state 59

    (19) body -> decvar statements . body
    (19) body -> . decvar statements body
    (20) body -> . statements body
    (21) body -> . decvar
    (22) body -> .
    (3) decvar -> . VAR decvarp
    (4) decvar -> . VAR decvarp decvar
    (5) decvar -> .
    (46) statements -> . assign
    (47) statements -> . function
    (48) statements -> . voidfunction
    (49) statements -> . call
    (50) statements -> . read
    (51) statements -> . print
    (52) statements -> . if
    (53) statements -> . while
    (54) statements -> . for
    (55) assign -> . var EQUAL exp SEMICOLON
    (11) function -> . FUNCTION type decfunc LPAREN param RPAREN LBRACE body RBRACE
    (13) voidfunction -> . FUNCTION VOID decfunc LPAREN param RPAREN LBRACE body RBRACE
    (61) call -> . ID LPAREN callp RPAREN
    (56) read -> . READ var
    (57) print -> . PRINT LPAREN printp
    (64) if -> . IF LPAREN exp RPAREN quadsIf statements ifelse jumpsIf
    (70) while -> . WHILE LPAREN saveJumps exp RPAREN quadsWhile statements jumpsWhile whilep
    (76) for -> . FOR LPAREN var SEMICOLON exp SEMICOLON exp RPAREN LBRACKET statements forp
    (60) var -> . ID

  ! reduce/reduce conflict for RBRACE resolved using rule 5 (decvar -> .)
  ! shift/reduce conflict for FUNCTION resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for READ resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
    VAR             shift and go to state 7
    RBRACE          reduce using rule 5 (decvar -> .)
    FUNCTION        shift and go to state 11
    ID              shift and go to state 51
    READ            shift and go to state 52
    PRINT           shift and go to state 53
    IF              shift and go to state 54
    WHILE           shift and go to state 55
    FOR             shift and go to state 56

  ! RBRACE          [ reduce using rule 22 (body -> .) ]
  ! FUNCTION        [ reduce using rule 5 (decvar -> .) ]
  ! ID              [ reduce using rule 5 (decvar -> .) ]
  ! READ            [ reduce using rule 5 (decvar -> .) ]
  ! PRINT           [ reduce using rule 5 (decvar -> .) ]
  ! IF              [ reduce using rule 5 (decvar -> .) ]
  ! WHILE           [ reduce using rule 5 (decvar -> .) ]
  ! FOR             [ reduce using rule 5 (decvar -> .) ]

    decvar                         shift and go to state 39
    statements                     shift and go to state 40
    body                           shift and go to state 70
    assign                         shift and go to state 41
    function                       shift and go to state 42
    voidfunction                   shift and go to state 43
    call                           shift and go to state 44
    read                           shift and go to state 45
    print                          shift and go to state 46
    if                             shift and go to state 47
    while                          shift and go to state 48
    for                            shift and go to state 49
    var                            shift and go to state 50

state 60

    (20) body -> statements body .

    RBRACE          reduce using rule 20 (body -> statements body .)


state 61

    (55) assign -> var EQUAL . exp SEMICOLON
    (25) exp -> . texp
    (26) exp -> . texp OR exp
    (27) texp -> . gexp
    (28) texp -> . gexp AND texp
    (29) gexp -> . mexp
    (30) gexp -> . mexp gexpp mexp
    (35) mexp -> . t
    (36) mexp -> . t PLUS mexp
    (37) mexp -> . t MINUS mexp
    (38) t -> . f
    (39) t -> . f MULT t
    (40) t -> . f DIV t
    (41) f -> . LPAREN exp RPAREN
    (42) f -> . CTI
    (43) f -> . CTF
    (44) f -> . var
    (45) f -> . call
    (60) var -> . ID
    (61) call -> . ID LPAREN callp RPAREN

    LPAREN          shift and go to state 78
    CTI             shift and go to state 79
    CTF             shift and go to state 80
    ID              shift and go to state 82

    var                            shift and go to state 71
    exp                            shift and go to state 72
    texp                           shift and go to state 73
    gexp                           shift and go to state 74
    mexp                           shift and go to state 75
    t                              shift and go to state 76
    f                              shift and go to state 77
    call                           shift and go to state 81

state 62

    (61) call -> ID LPAREN . callp RPAREN
    (62) callp -> . exp SEMICOLON callp
    (63) callp -> . exp
    (25) exp -> . texp
    (26) exp -> . texp OR exp
    (27) texp -> . gexp
    (28) texp -> . gexp AND texp
    (29) gexp -> . mexp
    (30) gexp -> . mexp gexpp mexp
    (35) mexp -> . t
    (36) mexp -> . t PLUS mexp
    (37) mexp -> . t MINUS mexp
    (38) t -> . f
    (39) t -> . f MULT t
    (40) t -> . f DIV t
    (41) f -> . LPAREN exp RPAREN
    (42) f -> . CTI
    (43) f -> . CTF
    (44) f -> . var
    (45) f -> . call
    (60) var -> . ID
    (61) call -> . ID LPAREN callp RPAREN

    LPAREN          shift and go to state 78
    CTI             shift and go to state 79
    CTF             shift and go to state 80
    ID              shift and go to state 82

    callp                          shift and go to state 83
    exp                            shift and go to state 84
    texp                           shift and go to state 73
    gexp                           shift and go to state 74
    mexp                           shift and go to state 75
    t                              shift and go to state 76
    f                              shift and go to state 77
    var                            shift and go to state 71
    call                           shift and go to state 81

state 63

    (56) read -> READ var .

    VAR             reduce using rule 56 (read -> READ var .)
    FUNCTION        reduce using rule 56 (read -> READ var .)
    ID              reduce using rule 56 (read -> READ var .)
    READ            reduce using rule 56 (read -> READ var .)
    PRINT           reduce using rule 56 (read -> READ var .)
    IF              reduce using rule 56 (read -> READ var .)
    WHILE           reduce using rule 56 (read -> READ var .)
    FOR             reduce using rule 56 (read -> READ var .)
    RBRACE          reduce using rule 56 (read -> READ var .)
    ELSE            reduce using rule 56 (read -> READ var .)
    SEMICOLON       reduce using rule 56 (read -> READ var .)
    RBRACKET        reduce using rule 56 (read -> READ var .)


state 64

    (60) var -> ID .

    VAR             reduce using rule 60 (var -> ID .)
    FUNCTION        reduce using rule 60 (var -> ID .)
    ID              reduce using rule 60 (var -> ID .)
    READ            reduce using rule 60 (var -> ID .)
    PRINT           reduce using rule 60 (var -> ID .)
    IF              reduce using rule 60 (var -> ID .)
    WHILE           reduce using rule 60 (var -> ID .)
    FOR             reduce using rule 60 (var -> ID .)
    RBRACE          reduce using rule 60 (var -> ID .)
    ELSE            reduce using rule 60 (var -> ID .)
    SEMICOLON       reduce using rule 60 (var -> ID .)
    RBRACKET        reduce using rule 60 (var -> ID .)


state 65

    (57) print -> PRINT LPAREN . printp
    (58) printp -> . exp RPAREN
    (59) printp -> . exp COMMA printp
    (25) exp -> . texp
    (26) exp -> . texp OR exp
    (27) texp -> . gexp
    (28) texp -> . gexp AND texp
    (29) gexp -> . mexp
    (30) gexp -> . mexp gexpp mexp
    (35) mexp -> . t
    (36) mexp -> . t PLUS mexp
    (37) mexp -> . t MINUS mexp
    (38) t -> . f
    (39) t -> . f MULT t
    (40) t -> . f DIV t
    (41) f -> . LPAREN exp RPAREN
    (42) f -> . CTI
    (43) f -> . CTF
    (44) f -> . var
    (45) f -> . call
    (60) var -> . ID
    (61) call -> . ID LPAREN callp RPAREN

    LPAREN          shift and go to state 78
    CTI             shift and go to state 79
    CTF             shift and go to state 80
    ID              shift and go to state 82

    printp                         shift and go to state 85
    exp                            shift and go to state 86
    texp                           shift and go to state 73
    gexp                           shift and go to state 74
    mexp                           shift and go to state 75
    t                              shift and go to state 76
    f                              shift and go to state 77
    var                            shift and go to state 71
    call                           shift and go to state 81

state 66

    (64) if -> IF LPAREN . exp RPAREN quadsIf statements ifelse jumpsIf
    (25) exp -> . texp
    (26) exp -> . texp OR exp
    (27) texp -> . gexp
    (28) texp -> . gexp AND texp
    (29) gexp -> . mexp
    (30) gexp -> . mexp gexpp mexp
    (35) mexp -> . t
    (36) mexp -> . t PLUS mexp
    (37) mexp -> . t MINUS mexp
    (38) t -> . f
    (39) t -> . f MULT t
    (40) t -> . f DIV t
    (41) f -> . LPAREN exp RPAREN
    (42) f -> . CTI
    (43) f -> . CTF
    (44) f -> . var
    (45) f -> . call
    (60) var -> . ID
    (61) call -> . ID LPAREN callp RPAREN

    LPAREN          shift and go to state 78
    CTI             shift and go to state 79
    CTF             shift and go to state 80
    ID              shift and go to state 82

    exp                            shift and go to state 87
    texp                           shift and go to state 73
    gexp                           shift and go to state 74
    mexp                           shift and go to state 75
    t                              shift and go to state 76
    f                              shift and go to state 77
    var                            shift and go to state 71
    call                           shift and go to state 81

state 67

    (70) while -> WHILE LPAREN . saveJumps exp RPAREN quadsWhile statements jumpsWhile whilep
    (73) saveJumps -> .

    LPAREN          reduce using rule 73 (saveJumps -> .)
    CTI             reduce using rule 73 (saveJumps -> .)
    CTF             reduce using rule 73 (saveJumps -> .)
    ID              reduce using rule 73 (saveJumps -> .)

    saveJumps                      shift and go to state 88

state 68

    (76) for -> FOR LPAREN . var SEMICOLON exp SEMICOLON exp RPAREN LBRACKET statements forp
    (60) var -> . ID

    ID              shift and go to state 64

    var                            shift and go to state 89

state 69

    (13) voidfunction -> FUNCTION VOID decfunc LPAREN param RPAREN LBRACE body RBRACE .

    FUNCTION        reduce using rule 13 (voidfunction -> FUNCTION VOID decfunc LPAREN param RPAREN LBRACE body RBRACE .)
    $end            reduce using rule 13 (voidfunction -> FUNCTION VOID decfunc LPAREN param RPAREN LBRACE body RBRACE .)
    VAR             reduce using rule 13 (voidfunction -> FUNCTION VOID decfunc LPAREN param RPAREN LBRACE body RBRACE .)
    ID              reduce using rule 13 (voidfunction -> FUNCTION VOID decfunc LPAREN param RPAREN LBRACE body RBRACE .)
    READ            reduce using rule 13 (voidfunction -> FUNCTION VOID decfunc LPAREN param RPAREN LBRACE body RBRACE .)
    PRINT           reduce using rule 13 (voidfunction -> FUNCTION VOID decfunc LPAREN param RPAREN LBRACE body RBRACE .)
    IF              reduce using rule 13 (voidfunction -> FUNCTION VOID decfunc LPAREN param RPAREN LBRACE body RBRACE .)
    WHILE           reduce using rule 13 (voidfunction -> FUNCTION VOID decfunc LPAREN param RPAREN LBRACE body RBRACE .)
    FOR             reduce using rule 13 (voidfunction -> FUNCTION VOID decfunc LPAREN param RPAREN LBRACE body RBRACE .)
    RBRACE          reduce using rule 13 (voidfunction -> FUNCTION VOID decfunc LPAREN param RPAREN LBRACE body RBRACE .)
    ELSE            reduce using rule 13 (voidfunction -> FUNCTION VOID decfunc LPAREN param RPAREN LBRACE body RBRACE .)
    SEMICOLON       reduce using rule 13 (voidfunction -> FUNCTION VOID decfunc LPAREN param RPAREN LBRACE body RBRACE .)
    RBRACKET        reduce using rule 13 (voidfunction -> FUNCTION VOID decfunc LPAREN param RPAREN LBRACE body RBRACE .)


state 70

    (19) body -> decvar statements body .

    RBRACE          reduce using rule 19 (body -> decvar statements body .)


state 71

    (44) f -> var .

    MULT            reduce using rule 44 (f -> var .)
    DIV             reduce using rule 44 (f -> var .)
    PLUS            reduce using rule 44 (f -> var .)
    MINUS           reduce using rule 44 (f -> var .)
    LT              reduce using rule 44 (f -> var .)
    GT              reduce using rule 44 (f -> var .)
    EQUAL           reduce using rule 44 (f -> var .)
    DIFF            reduce using rule 44 (f -> var .)
    AND             reduce using rule 44 (f -> var .)
    OR              reduce using rule 44 (f -> var .)
    SEMICOLON       reduce using rule 44 (f -> var .)
    RPAREN          reduce using rule 44 (f -> var .)
    COMMA           reduce using rule 44 (f -> var .)


state 72

    (55) assign -> var EQUAL exp . SEMICOLON

    SEMICOLON       shift and go to state 90


state 73

    (25) exp -> texp .
    (26) exp -> texp . OR exp

    SEMICOLON       reduce using rule 25 (exp -> texp .)
    RPAREN          reduce using rule 25 (exp -> texp .)
    COMMA           reduce using rule 25 (exp -> texp .)
    OR              shift and go to state 91


state 74

    (27) texp -> gexp .
    (28) texp -> gexp . AND texp

    OR              reduce using rule 27 (texp -> gexp .)
    SEMICOLON       reduce using rule 27 (texp -> gexp .)
    RPAREN          reduce using rule 27 (texp -> gexp .)
    COMMA           reduce using rule 27 (texp -> gexp .)
    AND             shift and go to state 92


state 75

    (29) gexp -> mexp .
    (30) gexp -> mexp . gexpp mexp
    (31) gexpp -> . LT
    (32) gexpp -> . GT
    (33) gexpp -> . EQUAL
    (34) gexpp -> . DIFF

    AND             reduce using rule 29 (gexp -> mexp .)
    OR              reduce using rule 29 (gexp -> mexp .)
    SEMICOLON       reduce using rule 29 (gexp -> mexp .)
    RPAREN          reduce using rule 29 (gexp -> mexp .)
    COMMA           reduce using rule 29 (gexp -> mexp .)
    LT              shift and go to state 94
    GT              shift and go to state 95
    EQUAL           shift and go to state 96
    DIFF            shift and go to state 97

    gexpp                          shift and go to state 93

state 76

    (35) mexp -> t .
    (36) mexp -> t . PLUS mexp
    (37) mexp -> t . MINUS mexp

    LT              reduce using rule 35 (mexp -> t .)
    GT              reduce using rule 35 (mexp -> t .)
    EQUAL           reduce using rule 35 (mexp -> t .)
    DIFF            reduce using rule 35 (mexp -> t .)
    AND             reduce using rule 35 (mexp -> t .)
    OR              reduce using rule 35 (mexp -> t .)
    SEMICOLON       reduce using rule 35 (mexp -> t .)
    RPAREN          reduce using rule 35 (mexp -> t .)
    COMMA           reduce using rule 35 (mexp -> t .)
    PLUS            shift and go to state 98
    MINUS           shift and go to state 99


state 77

    (38) t -> f .
    (39) t -> f . MULT t
    (40) t -> f . DIV t

    PLUS            reduce using rule 38 (t -> f .)
    MINUS           reduce using rule 38 (t -> f .)
    LT              reduce using rule 38 (t -> f .)
    GT              reduce using rule 38 (t -> f .)
    EQUAL           reduce using rule 38 (t -> f .)
    DIFF            reduce using rule 38 (t -> f .)
    AND             reduce using rule 38 (t -> f .)
    OR              reduce using rule 38 (t -> f .)
    SEMICOLON       reduce using rule 38 (t -> f .)
    RPAREN          reduce using rule 38 (t -> f .)
    COMMA           reduce using rule 38 (t -> f .)
    MULT            shift and go to state 100
    DIV             shift and go to state 101


state 78

    (41) f -> LPAREN . exp RPAREN
    (25) exp -> . texp
    (26) exp -> . texp OR exp
    (27) texp -> . gexp
    (28) texp -> . gexp AND texp
    (29) gexp -> . mexp
    (30) gexp -> . mexp gexpp mexp
    (35) mexp -> . t
    (36) mexp -> . t PLUS mexp
    (37) mexp -> . t MINUS mexp
    (38) t -> . f
    (39) t -> . f MULT t
    (40) t -> . f DIV t
    (41) f -> . LPAREN exp RPAREN
    (42) f -> . CTI
    (43) f -> . CTF
    (44) f -> . var
    (45) f -> . call
    (60) var -> . ID
    (61) call -> . ID LPAREN callp RPAREN

    LPAREN          shift and go to state 78
    CTI             shift and go to state 79
    CTF             shift and go to state 80
    ID              shift and go to state 82

    exp                            shift and go to state 102
    texp                           shift and go to state 73
    gexp                           shift and go to state 74
    mexp                           shift and go to state 75
    t                              shift and go to state 76
    f                              shift and go to state 77
    var                            shift and go to state 71
    call                           shift and go to state 81

state 79

    (42) f -> CTI .

    MULT            reduce using rule 42 (f -> CTI .)
    DIV             reduce using rule 42 (f -> CTI .)
    PLUS            reduce using rule 42 (f -> CTI .)
    MINUS           reduce using rule 42 (f -> CTI .)
    LT              reduce using rule 42 (f -> CTI .)
    GT              reduce using rule 42 (f -> CTI .)
    EQUAL           reduce using rule 42 (f -> CTI .)
    DIFF            reduce using rule 42 (f -> CTI .)
    AND             reduce using rule 42 (f -> CTI .)
    OR              reduce using rule 42 (f -> CTI .)
    SEMICOLON       reduce using rule 42 (f -> CTI .)
    RPAREN          reduce using rule 42 (f -> CTI .)
    COMMA           reduce using rule 42 (f -> CTI .)


state 80

    (43) f -> CTF .

    MULT            reduce using rule 43 (f -> CTF .)
    DIV             reduce using rule 43 (f -> CTF .)
    PLUS            reduce using rule 43 (f -> CTF .)
    MINUS           reduce using rule 43 (f -> CTF .)
    LT              reduce using rule 43 (f -> CTF .)
    GT              reduce using rule 43 (f -> CTF .)
    EQUAL           reduce using rule 43 (f -> CTF .)
    DIFF            reduce using rule 43 (f -> CTF .)
    AND             reduce using rule 43 (f -> CTF .)
    OR              reduce using rule 43 (f -> CTF .)
    SEMICOLON       reduce using rule 43 (f -> CTF .)
    RPAREN          reduce using rule 43 (f -> CTF .)
    COMMA           reduce using rule 43 (f -> CTF .)


state 81

    (45) f -> call .

    MULT            reduce using rule 45 (f -> call .)
    DIV             reduce using rule 45 (f -> call .)
    PLUS            reduce using rule 45 (f -> call .)
    MINUS           reduce using rule 45 (f -> call .)
    LT              reduce using rule 45 (f -> call .)
    GT              reduce using rule 45 (f -> call .)
    EQUAL           reduce using rule 45 (f -> call .)
    DIFF            reduce using rule 45 (f -> call .)
    AND             reduce using rule 45 (f -> call .)
    OR              reduce using rule 45 (f -> call .)
    SEMICOLON       reduce using rule 45 (f -> call .)
    RPAREN          reduce using rule 45 (f -> call .)
    COMMA           reduce using rule 45 (f -> call .)


state 82

    (60) var -> ID .
    (61) call -> ID . LPAREN callp RPAREN

    MULT            reduce using rule 60 (var -> ID .)
    DIV             reduce using rule 60 (var -> ID .)
    PLUS            reduce using rule 60 (var -> ID .)
    MINUS           reduce using rule 60 (var -> ID .)
    LT              reduce using rule 60 (var -> ID .)
    GT              reduce using rule 60 (var -> ID .)
    EQUAL           reduce using rule 60 (var -> ID .)
    DIFF            reduce using rule 60 (var -> ID .)
    AND             reduce using rule 60 (var -> ID .)
    OR              reduce using rule 60 (var -> ID .)
    SEMICOLON       reduce using rule 60 (var -> ID .)
    RPAREN          reduce using rule 60 (var -> ID .)
    COMMA           reduce using rule 60 (var -> ID .)
    LPAREN          shift and go to state 62


state 83

    (61) call -> ID LPAREN callp . RPAREN

    RPAREN          shift and go to state 103


state 84

    (62) callp -> exp . SEMICOLON callp
    (63) callp -> exp .

    SEMICOLON       shift and go to state 104
    RPAREN          reduce using rule 63 (callp -> exp .)


state 85

    (57) print -> PRINT LPAREN printp .

    VAR             reduce using rule 57 (print -> PRINT LPAREN printp .)
    FUNCTION        reduce using rule 57 (print -> PRINT LPAREN printp .)
    ID              reduce using rule 57 (print -> PRINT LPAREN printp .)
    READ            reduce using rule 57 (print -> PRINT LPAREN printp .)
    PRINT           reduce using rule 57 (print -> PRINT LPAREN printp .)
    IF              reduce using rule 57 (print -> PRINT LPAREN printp .)
    WHILE           reduce using rule 57 (print -> PRINT LPAREN printp .)
    FOR             reduce using rule 57 (print -> PRINT LPAREN printp .)
    RBRACE          reduce using rule 57 (print -> PRINT LPAREN printp .)
    ELSE            reduce using rule 57 (print -> PRINT LPAREN printp .)
    SEMICOLON       reduce using rule 57 (print -> PRINT LPAREN printp .)
    RBRACKET        reduce using rule 57 (print -> PRINT LPAREN printp .)


state 86

    (58) printp -> exp . RPAREN
    (59) printp -> exp . COMMA printp

    RPAREN          shift and go to state 105
    COMMA           shift and go to state 106


state 87

    (64) if -> IF LPAREN exp . RPAREN quadsIf statements ifelse jumpsIf

    RPAREN          shift and go to state 107


state 88

    (70) while -> WHILE LPAREN saveJumps . exp RPAREN quadsWhile statements jumpsWhile whilep
    (25) exp -> . texp
    (26) exp -> . texp OR exp
    (27) texp -> . gexp
    (28) texp -> . gexp AND texp
    (29) gexp -> . mexp
    (30) gexp -> . mexp gexpp mexp
    (35) mexp -> . t
    (36) mexp -> . t PLUS mexp
    (37) mexp -> . t MINUS mexp
    (38) t -> . f
    (39) t -> . f MULT t
    (40) t -> . f DIV t
    (41) f -> . LPAREN exp RPAREN
    (42) f -> . CTI
    (43) f -> . CTF
    (44) f -> . var
    (45) f -> . call
    (60) var -> . ID
    (61) call -> . ID LPAREN callp RPAREN

    LPAREN          shift and go to state 78
    CTI             shift and go to state 79
    CTF             shift and go to state 80
    ID              shift and go to state 82

    exp                            shift and go to state 108
    texp                           shift and go to state 73
    gexp                           shift and go to state 74
    mexp                           shift and go to state 75
    t                              shift and go to state 76
    f                              shift and go to state 77
    var                            shift and go to state 71
    call                           shift and go to state 81

state 89

    (76) for -> FOR LPAREN var . SEMICOLON exp SEMICOLON exp RPAREN LBRACKET statements forp

    SEMICOLON       shift and go to state 109


state 90

    (55) assign -> var EQUAL exp SEMICOLON .

    VAR             reduce using rule 55 (assign -> var EQUAL exp SEMICOLON .)
    FUNCTION        reduce using rule 55 (assign -> var EQUAL exp SEMICOLON .)
    ID              reduce using rule 55 (assign -> var EQUAL exp SEMICOLON .)
    READ            reduce using rule 55 (assign -> var EQUAL exp SEMICOLON .)
    PRINT           reduce using rule 55 (assign -> var EQUAL exp SEMICOLON .)
    IF              reduce using rule 55 (assign -> var EQUAL exp SEMICOLON .)
    WHILE           reduce using rule 55 (assign -> var EQUAL exp SEMICOLON .)
    FOR             reduce using rule 55 (assign -> var EQUAL exp SEMICOLON .)
    RBRACE          reduce using rule 55 (assign -> var EQUAL exp SEMICOLON .)
    ELSE            reduce using rule 55 (assign -> var EQUAL exp SEMICOLON .)
    SEMICOLON       reduce using rule 55 (assign -> var EQUAL exp SEMICOLON .)
    RBRACKET        reduce using rule 55 (assign -> var EQUAL exp SEMICOLON .)


state 91

    (26) exp -> texp OR . exp
    (25) exp -> . texp
    (26) exp -> . texp OR exp
    (27) texp -> . gexp
    (28) texp -> . gexp AND texp
    (29) gexp -> . mexp
    (30) gexp -> . mexp gexpp mexp
    (35) mexp -> . t
    (36) mexp -> . t PLUS mexp
    (37) mexp -> . t MINUS mexp
    (38) t -> . f
    (39) t -> . f MULT t
    (40) t -> . f DIV t
    (41) f -> . LPAREN exp RPAREN
    (42) f -> . CTI
    (43) f -> . CTF
    (44) f -> . var
    (45) f -> . call
    (60) var -> . ID
    (61) call -> . ID LPAREN callp RPAREN

    LPAREN          shift and go to state 78
    CTI             shift and go to state 79
    CTF             shift and go to state 80
    ID              shift and go to state 82

    texp                           shift and go to state 73
    exp                            shift and go to state 110
    gexp                           shift and go to state 74
    mexp                           shift and go to state 75
    t                              shift and go to state 76
    f                              shift and go to state 77
    var                            shift and go to state 71
    call                           shift and go to state 81

state 92

    (28) texp -> gexp AND . texp
    (27) texp -> . gexp
    (28) texp -> . gexp AND texp
    (29) gexp -> . mexp
    (30) gexp -> . mexp gexpp mexp
    (35) mexp -> . t
    (36) mexp -> . t PLUS mexp
    (37) mexp -> . t MINUS mexp
    (38) t -> . f
    (39) t -> . f MULT t
    (40) t -> . f DIV t
    (41) f -> . LPAREN exp RPAREN
    (42) f -> . CTI
    (43) f -> . CTF
    (44) f -> . var
    (45) f -> . call
    (60) var -> . ID
    (61) call -> . ID LPAREN callp RPAREN

    LPAREN          shift and go to state 78
    CTI             shift and go to state 79
    CTF             shift and go to state 80
    ID              shift and go to state 82

    gexp                           shift and go to state 74
    texp                           shift and go to state 111
    mexp                           shift and go to state 75
    t                              shift and go to state 76
    f                              shift and go to state 77
    var                            shift and go to state 71
    call                           shift and go to state 81

state 93

    (30) gexp -> mexp gexpp . mexp
    (35) mexp -> . t
    (36) mexp -> . t PLUS mexp
    (37) mexp -> . t MINUS mexp
    (38) t -> . f
    (39) t -> . f MULT t
    (40) t -> . f DIV t
    (41) f -> . LPAREN exp RPAREN
    (42) f -> . CTI
    (43) f -> . CTF
    (44) f -> . var
    (45) f -> . call
    (60) var -> . ID
    (61) call -> . ID LPAREN callp RPAREN

    LPAREN          shift and go to state 78
    CTI             shift and go to state 79
    CTF             shift and go to state 80
    ID              shift and go to state 82

    mexp                           shift and go to state 112
    t                              shift and go to state 76
    f                              shift and go to state 77
    var                            shift and go to state 71
    call                           shift and go to state 81

state 94

    (31) gexpp -> LT .

    LPAREN          reduce using rule 31 (gexpp -> LT .)
    CTI             reduce using rule 31 (gexpp -> LT .)
    CTF             reduce using rule 31 (gexpp -> LT .)
    ID              reduce using rule 31 (gexpp -> LT .)


state 95

    (32) gexpp -> GT .

    LPAREN          reduce using rule 32 (gexpp -> GT .)
    CTI             reduce using rule 32 (gexpp -> GT .)
    CTF             reduce using rule 32 (gexpp -> GT .)
    ID              reduce using rule 32 (gexpp -> GT .)


state 96

    (33) gexpp -> EQUAL .

    LPAREN          reduce using rule 33 (gexpp -> EQUAL .)
    CTI             reduce using rule 33 (gexpp -> EQUAL .)
    CTF             reduce using rule 33 (gexpp -> EQUAL .)
    ID              reduce using rule 33 (gexpp -> EQUAL .)


state 97

    (34) gexpp -> DIFF .

    LPAREN          reduce using rule 34 (gexpp -> DIFF .)
    CTI             reduce using rule 34 (gexpp -> DIFF .)
    CTF             reduce using rule 34 (gexpp -> DIFF .)
    ID              reduce using rule 34 (gexpp -> DIFF .)


state 98

    (36) mexp -> t PLUS . mexp
    (35) mexp -> . t
    (36) mexp -> . t PLUS mexp
    (37) mexp -> . t MINUS mexp
    (38) t -> . f
    (39) t -> . f MULT t
    (40) t -> . f DIV t
    (41) f -> . LPAREN exp RPAREN
    (42) f -> . CTI
    (43) f -> . CTF
    (44) f -> . var
    (45) f -> . call
    (60) var -> . ID
    (61) call -> . ID LPAREN callp RPAREN

    LPAREN          shift and go to state 78
    CTI             shift and go to state 79
    CTF             shift and go to state 80
    ID              shift and go to state 82

    t                              shift and go to state 76
    mexp                           shift and go to state 113
    f                              shift and go to state 77
    var                            shift and go to state 71
    call                           shift and go to state 81

state 99

    (37) mexp -> t MINUS . mexp
    (35) mexp -> . t
    (36) mexp -> . t PLUS mexp
    (37) mexp -> . t MINUS mexp
    (38) t -> . f
    (39) t -> . f MULT t
    (40) t -> . f DIV t
    (41) f -> . LPAREN exp RPAREN
    (42) f -> . CTI
    (43) f -> . CTF
    (44) f -> . var
    (45) f -> . call
    (60) var -> . ID
    (61) call -> . ID LPAREN callp RPAREN

    LPAREN          shift and go to state 78
    CTI             shift and go to state 79
    CTF             shift and go to state 80
    ID              shift and go to state 82

    t                              shift and go to state 76
    mexp                           shift and go to state 114
    f                              shift and go to state 77
    var                            shift and go to state 71
    call                           shift and go to state 81

state 100

    (39) t -> f MULT . t
    (38) t -> . f
    (39) t -> . f MULT t
    (40) t -> . f DIV t
    (41) f -> . LPAREN exp RPAREN
    (42) f -> . CTI
    (43) f -> . CTF
    (44) f -> . var
    (45) f -> . call
    (60) var -> . ID
    (61) call -> . ID LPAREN callp RPAREN

    LPAREN          shift and go to state 78
    CTI             shift and go to state 79
    CTF             shift and go to state 80
    ID              shift and go to state 82

    f                              shift and go to state 77
    t                              shift and go to state 115
    var                            shift and go to state 71
    call                           shift and go to state 81

state 101

    (40) t -> f DIV . t
    (38) t -> . f
    (39) t -> . f MULT t
    (40) t -> . f DIV t
    (41) f -> . LPAREN exp RPAREN
    (42) f -> . CTI
    (43) f -> . CTF
    (44) f -> . var
    (45) f -> . call
    (60) var -> . ID
    (61) call -> . ID LPAREN callp RPAREN

    LPAREN          shift and go to state 78
    CTI             shift and go to state 79
    CTF             shift and go to state 80
    ID              shift and go to state 82

    f                              shift and go to state 77
    t                              shift and go to state 116
    var                            shift and go to state 71
    call                           shift and go to state 81

state 102

    (41) f -> LPAREN exp . RPAREN

    RPAREN          shift and go to state 117


state 103

    (61) call -> ID LPAREN callp RPAREN .

    VAR             reduce using rule 61 (call -> ID LPAREN callp RPAREN .)
    FUNCTION        reduce using rule 61 (call -> ID LPAREN callp RPAREN .)
    ID              reduce using rule 61 (call -> ID LPAREN callp RPAREN .)
    READ            reduce using rule 61 (call -> ID LPAREN callp RPAREN .)
    PRINT           reduce using rule 61 (call -> ID LPAREN callp RPAREN .)
    IF              reduce using rule 61 (call -> ID LPAREN callp RPAREN .)
    WHILE           reduce using rule 61 (call -> ID LPAREN callp RPAREN .)
    FOR             reduce using rule 61 (call -> ID LPAREN callp RPAREN .)
    RBRACE          reduce using rule 61 (call -> ID LPAREN callp RPAREN .)
    MULT            reduce using rule 61 (call -> ID LPAREN callp RPAREN .)
    DIV             reduce using rule 61 (call -> ID LPAREN callp RPAREN .)
    PLUS            reduce using rule 61 (call -> ID LPAREN callp RPAREN .)
    MINUS           reduce using rule 61 (call -> ID LPAREN callp RPAREN .)
    LT              reduce using rule 61 (call -> ID LPAREN callp RPAREN .)
    GT              reduce using rule 61 (call -> ID LPAREN callp RPAREN .)
    EQUAL           reduce using rule 61 (call -> ID LPAREN callp RPAREN .)
    DIFF            reduce using rule 61 (call -> ID LPAREN callp RPAREN .)
    AND             reduce using rule 61 (call -> ID LPAREN callp RPAREN .)
    OR              reduce using rule 61 (call -> ID LPAREN callp RPAREN .)
    SEMICOLON       reduce using rule 61 (call -> ID LPAREN callp RPAREN .)
    RPAREN          reduce using rule 61 (call -> ID LPAREN callp RPAREN .)
    COMMA           reduce using rule 61 (call -> ID LPAREN callp RPAREN .)
    ELSE            reduce using rule 61 (call -> ID LPAREN callp RPAREN .)
    RBRACKET        reduce using rule 61 (call -> ID LPAREN callp RPAREN .)


state 104

    (62) callp -> exp SEMICOLON . callp
    (62) callp -> . exp SEMICOLON callp
    (63) callp -> . exp
    (25) exp -> . texp
    (26) exp -> . texp OR exp
    (27) texp -> . gexp
    (28) texp -> . gexp AND texp
    (29) gexp -> . mexp
    (30) gexp -> . mexp gexpp mexp
    (35) mexp -> . t
    (36) mexp -> . t PLUS mexp
    (37) mexp -> . t MINUS mexp
    (38) t -> . f
    (39) t -> . f MULT t
    (40) t -> . f DIV t
    (41) f -> . LPAREN exp RPAREN
    (42) f -> . CTI
    (43) f -> . CTF
    (44) f -> . var
    (45) f -> . call
    (60) var -> . ID
    (61) call -> . ID LPAREN callp RPAREN

    LPAREN          shift and go to state 78
    CTI             shift and go to state 79
    CTF             shift and go to state 80
    ID              shift and go to state 82

    exp                            shift and go to state 84
    callp                          shift and go to state 118
    texp                           shift and go to state 73
    gexp                           shift and go to state 74
    mexp                           shift and go to state 75
    t                              shift and go to state 76
    f                              shift and go to state 77
    var                            shift and go to state 71
    call                           shift and go to state 81

state 105

    (58) printp -> exp RPAREN .

    VAR             reduce using rule 58 (printp -> exp RPAREN .)
    FUNCTION        reduce using rule 58 (printp -> exp RPAREN .)
    ID              reduce using rule 58 (printp -> exp RPAREN .)
    READ            reduce using rule 58 (printp -> exp RPAREN .)
    PRINT           reduce using rule 58 (printp -> exp RPAREN .)
    IF              reduce using rule 58 (printp -> exp RPAREN .)
    WHILE           reduce using rule 58 (printp -> exp RPAREN .)
    FOR             reduce using rule 58 (printp -> exp RPAREN .)
    RBRACE          reduce using rule 58 (printp -> exp RPAREN .)
    ELSE            reduce using rule 58 (printp -> exp RPAREN .)
    SEMICOLON       reduce using rule 58 (printp -> exp RPAREN .)
    RBRACKET        reduce using rule 58 (printp -> exp RPAREN .)


state 106

    (59) printp -> exp COMMA . printp
    (58) printp -> . exp RPAREN
    (59) printp -> . exp COMMA printp
    (25) exp -> . texp
    (26) exp -> . texp OR exp
    (27) texp -> . gexp
    (28) texp -> . gexp AND texp
    (29) gexp -> . mexp
    (30) gexp -> . mexp gexpp mexp
    (35) mexp -> . t
    (36) mexp -> . t PLUS mexp
    (37) mexp -> . t MINUS mexp
    (38) t -> . f
    (39) t -> . f MULT t
    (40) t -> . f DIV t
    (41) f -> . LPAREN exp RPAREN
    (42) f -> . CTI
    (43) f -> . CTF
    (44) f -> . var
    (45) f -> . call
    (60) var -> . ID
    (61) call -> . ID LPAREN callp RPAREN

    LPAREN          shift and go to state 78
    CTI             shift and go to state 79
    CTF             shift and go to state 80
    ID              shift and go to state 82

    exp                            shift and go to state 86
    printp                         shift and go to state 119
    texp                           shift and go to state 73
    gexp                           shift and go to state 74
    mexp                           shift and go to state 75
    t                              shift and go to state 76
    f                              shift and go to state 77
    var                            shift and go to state 71
    call                           shift and go to state 81

state 107

    (64) if -> IF LPAREN exp RPAREN . quadsIf statements ifelse jumpsIf
    (67) quadsIf -> .

    FUNCTION        reduce using rule 67 (quadsIf -> .)
    ID              reduce using rule 67 (quadsIf -> .)
    READ            reduce using rule 67 (quadsIf -> .)
    PRINT           reduce using rule 67 (quadsIf -> .)
    IF              reduce using rule 67 (quadsIf -> .)
    WHILE           reduce using rule 67 (quadsIf -> .)
    FOR             reduce using rule 67 (quadsIf -> .)

    quadsIf                        shift and go to state 120

state 108

    (70) while -> WHILE LPAREN saveJumps exp . RPAREN quadsWhile statements jumpsWhile whilep

    RPAREN          shift and go to state 121


state 109

    (76) for -> FOR LPAREN var SEMICOLON . exp SEMICOLON exp RPAREN LBRACKET statements forp
    (25) exp -> . texp
    (26) exp -> . texp OR exp
    (27) texp -> . gexp
    (28) texp -> . gexp AND texp
    (29) gexp -> . mexp
    (30) gexp -> . mexp gexpp mexp
    (35) mexp -> . t
    (36) mexp -> . t PLUS mexp
    (37) mexp -> . t MINUS mexp
    (38) t -> . f
    (39) t -> . f MULT t
    (40) t -> . f DIV t
    (41) f -> . LPAREN exp RPAREN
    (42) f -> . CTI
    (43) f -> . CTF
    (44) f -> . var
    (45) f -> . call
    (60) var -> . ID
    (61) call -> . ID LPAREN callp RPAREN

    LPAREN          shift and go to state 78
    CTI             shift and go to state 79
    CTF             shift and go to state 80
    ID              shift and go to state 82

    var                            shift and go to state 71
    exp                            shift and go to state 122
    texp                           shift and go to state 73
    gexp                           shift and go to state 74
    mexp                           shift and go to state 75
    t                              shift and go to state 76
    f                              shift and go to state 77
    call                           shift and go to state 81

state 110

    (26) exp -> texp OR exp .

    SEMICOLON       reduce using rule 26 (exp -> texp OR exp .)
    RPAREN          reduce using rule 26 (exp -> texp OR exp .)
    COMMA           reduce using rule 26 (exp -> texp OR exp .)


state 111

    (28) texp -> gexp AND texp .

    OR              reduce using rule 28 (texp -> gexp AND texp .)
    SEMICOLON       reduce using rule 28 (texp -> gexp AND texp .)
    RPAREN          reduce using rule 28 (texp -> gexp AND texp .)
    COMMA           reduce using rule 28 (texp -> gexp AND texp .)


state 112

    (30) gexp -> mexp gexpp mexp .

    AND             reduce using rule 30 (gexp -> mexp gexpp mexp .)
    OR              reduce using rule 30 (gexp -> mexp gexpp mexp .)
    SEMICOLON       reduce using rule 30 (gexp -> mexp gexpp mexp .)
    RPAREN          reduce using rule 30 (gexp -> mexp gexpp mexp .)
    COMMA           reduce using rule 30 (gexp -> mexp gexpp mexp .)


state 113

    (36) mexp -> t PLUS mexp .

    LT              reduce using rule 36 (mexp -> t PLUS mexp .)
    GT              reduce using rule 36 (mexp -> t PLUS mexp .)
    EQUAL           reduce using rule 36 (mexp -> t PLUS mexp .)
    DIFF            reduce using rule 36 (mexp -> t PLUS mexp .)
    AND             reduce using rule 36 (mexp -> t PLUS mexp .)
    OR              reduce using rule 36 (mexp -> t PLUS mexp .)
    SEMICOLON       reduce using rule 36 (mexp -> t PLUS mexp .)
    RPAREN          reduce using rule 36 (mexp -> t PLUS mexp .)
    COMMA           reduce using rule 36 (mexp -> t PLUS mexp .)


state 114

    (37) mexp -> t MINUS mexp .

    LT              reduce using rule 37 (mexp -> t MINUS mexp .)
    GT              reduce using rule 37 (mexp -> t MINUS mexp .)
    EQUAL           reduce using rule 37 (mexp -> t MINUS mexp .)
    DIFF            reduce using rule 37 (mexp -> t MINUS mexp .)
    AND             reduce using rule 37 (mexp -> t MINUS mexp .)
    OR              reduce using rule 37 (mexp -> t MINUS mexp .)
    SEMICOLON       reduce using rule 37 (mexp -> t MINUS mexp .)
    RPAREN          reduce using rule 37 (mexp -> t MINUS mexp .)
    COMMA           reduce using rule 37 (mexp -> t MINUS mexp .)


state 115

    (39) t -> f MULT t .

    PLUS            reduce using rule 39 (t -> f MULT t .)
    MINUS           reduce using rule 39 (t -> f MULT t .)
    LT              reduce using rule 39 (t -> f MULT t .)
    GT              reduce using rule 39 (t -> f MULT t .)
    EQUAL           reduce using rule 39 (t -> f MULT t .)
    DIFF            reduce using rule 39 (t -> f MULT t .)
    AND             reduce using rule 39 (t -> f MULT t .)
    OR              reduce using rule 39 (t -> f MULT t .)
    SEMICOLON       reduce using rule 39 (t -> f MULT t .)
    RPAREN          reduce using rule 39 (t -> f MULT t .)
    COMMA           reduce using rule 39 (t -> f MULT t .)


state 116

    (40) t -> f DIV t .

    PLUS            reduce using rule 40 (t -> f DIV t .)
    MINUS           reduce using rule 40 (t -> f DIV t .)
    LT              reduce using rule 40 (t -> f DIV t .)
    GT              reduce using rule 40 (t -> f DIV t .)
    EQUAL           reduce using rule 40 (t -> f DIV t .)
    DIFF            reduce using rule 40 (t -> f DIV t .)
    AND             reduce using rule 40 (t -> f DIV t .)
    OR              reduce using rule 40 (t -> f DIV t .)
    SEMICOLON       reduce using rule 40 (t -> f DIV t .)
    RPAREN          reduce using rule 40 (t -> f DIV t .)
    COMMA           reduce using rule 40 (t -> f DIV t .)


state 117

    (41) f -> LPAREN exp RPAREN .

    MULT            reduce using rule 41 (f -> LPAREN exp RPAREN .)
    DIV             reduce using rule 41 (f -> LPAREN exp RPAREN .)
    PLUS            reduce using rule 41 (f -> LPAREN exp RPAREN .)
    MINUS           reduce using rule 41 (f -> LPAREN exp RPAREN .)
    LT              reduce using rule 41 (f -> LPAREN exp RPAREN .)
    GT              reduce using rule 41 (f -> LPAREN exp RPAREN .)
    EQUAL           reduce using rule 41 (f -> LPAREN exp RPAREN .)
    DIFF            reduce using rule 41 (f -> LPAREN exp RPAREN .)
    AND             reduce using rule 41 (f -> LPAREN exp RPAREN .)
    OR              reduce using rule 41 (f -> LPAREN exp RPAREN .)
    SEMICOLON       reduce using rule 41 (f -> LPAREN exp RPAREN .)
    RPAREN          reduce using rule 41 (f -> LPAREN exp RPAREN .)
    COMMA           reduce using rule 41 (f -> LPAREN exp RPAREN .)


state 118

    (62) callp -> exp SEMICOLON callp .

    RPAREN          reduce using rule 62 (callp -> exp SEMICOLON callp .)


state 119

    (59) printp -> exp COMMA printp .

    VAR             reduce using rule 59 (printp -> exp COMMA printp .)
    FUNCTION        reduce using rule 59 (printp -> exp COMMA printp .)
    ID              reduce using rule 59 (printp -> exp COMMA printp .)
    READ            reduce using rule 59 (printp -> exp COMMA printp .)
    PRINT           reduce using rule 59 (printp -> exp COMMA printp .)
    IF              reduce using rule 59 (printp -> exp COMMA printp .)
    WHILE           reduce using rule 59 (printp -> exp COMMA printp .)
    FOR             reduce using rule 59 (printp -> exp COMMA printp .)
    RBRACE          reduce using rule 59 (printp -> exp COMMA printp .)
    ELSE            reduce using rule 59 (printp -> exp COMMA printp .)
    SEMICOLON       reduce using rule 59 (printp -> exp COMMA printp .)
    RBRACKET        reduce using rule 59 (printp -> exp COMMA printp .)


state 120

    (64) if -> IF LPAREN exp RPAREN quadsIf . statements ifelse jumpsIf
    (46) statements -> . assign
    (47) statements -> . function
    (48) statements -> . voidfunction
    (49) statements -> . call
    (50) statements -> . read
    (51) statements -> . print
    (52) statements -> . if
    (53) statements -> . while
    (54) statements -> . for
    (55) assign -> . var EQUAL exp SEMICOLON
    (11) function -> . FUNCTION type decfunc LPAREN param RPAREN LBRACE body RBRACE
    (13) voidfunction -> . FUNCTION VOID decfunc LPAREN param RPAREN LBRACE body RBRACE
    (61) call -> . ID LPAREN callp RPAREN
    (56) read -> . READ var
    (57) print -> . PRINT LPAREN printp
    (64) if -> . IF LPAREN exp RPAREN quadsIf statements ifelse jumpsIf
    (70) while -> . WHILE LPAREN saveJumps exp RPAREN quadsWhile statements jumpsWhile whilep
    (76) for -> . FOR LPAREN var SEMICOLON exp SEMICOLON exp RPAREN LBRACKET statements forp
    (60) var -> . ID

    FUNCTION        shift and go to state 11
    ID              shift and go to state 51
    READ            shift and go to state 52
    PRINT           shift and go to state 53
    IF              shift and go to state 54
    WHILE           shift and go to state 55
    FOR             shift and go to state 56

    statements                     shift and go to state 123
    assign                         shift and go to state 41
    function                       shift and go to state 42
    voidfunction                   shift and go to state 43
    call                           shift and go to state 44
    read                           shift and go to state 45
    print                          shift and go to state 46
    if                             shift and go to state 47
    while                          shift and go to state 48
    for                            shift and go to state 49
    var                            shift and go to state 50

state 121

    (70) while -> WHILE LPAREN saveJumps exp RPAREN . quadsWhile statements jumpsWhile whilep
    (74) quadsWhile -> .

    FUNCTION        reduce using rule 74 (quadsWhile -> .)
    ID              reduce using rule 74 (quadsWhile -> .)
    READ            reduce using rule 74 (quadsWhile -> .)
    PRINT           reduce using rule 74 (quadsWhile -> .)
    IF              reduce using rule 74 (quadsWhile -> .)
    WHILE           reduce using rule 74 (quadsWhile -> .)
    FOR             reduce using rule 74 (quadsWhile -> .)

    quadsWhile                     shift and go to state 124

state 122

    (76) for -> FOR LPAREN var SEMICOLON exp . SEMICOLON exp RPAREN LBRACKET statements forp

    SEMICOLON       shift and go to state 125


state 123

    (64) if -> IF LPAREN exp RPAREN quadsIf statements . ifelse jumpsIf
    (65) ifelse -> .
    (66) ifelse -> . ELSE quadsElse statements

  ! shift/reduce conflict for ELSE resolved as shift
    VAR             reduce using rule 65 (ifelse -> .)
    FUNCTION        reduce using rule 65 (ifelse -> .)
    ID              reduce using rule 65 (ifelse -> .)
    READ            reduce using rule 65 (ifelse -> .)
    PRINT           reduce using rule 65 (ifelse -> .)
    IF              reduce using rule 65 (ifelse -> .)
    WHILE           reduce using rule 65 (ifelse -> .)
    FOR             reduce using rule 65 (ifelse -> .)
    RBRACE          reduce using rule 65 (ifelse -> .)
    SEMICOLON       reduce using rule 65 (ifelse -> .)
    RBRACKET        reduce using rule 65 (ifelse -> .)
    ELSE            shift and go to state 127

  ! ELSE            [ reduce using rule 65 (ifelse -> .) ]

    ifelse                         shift and go to state 126

state 124

    (70) while -> WHILE LPAREN saveJumps exp RPAREN quadsWhile . statements jumpsWhile whilep
    (46) statements -> . assign
    (47) statements -> . function
    (48) statements -> . voidfunction
    (49) statements -> . call
    (50) statements -> . read
    (51) statements -> . print
    (52) statements -> . if
    (53) statements -> . while
    (54) statements -> . for
    (55) assign -> . var EQUAL exp SEMICOLON
    (11) function -> . FUNCTION type decfunc LPAREN param RPAREN LBRACE body RBRACE
    (13) voidfunction -> . FUNCTION VOID decfunc LPAREN param RPAREN LBRACE body RBRACE
    (61) call -> . ID LPAREN callp RPAREN
    (56) read -> . READ var
    (57) print -> . PRINT LPAREN printp
    (64) if -> . IF LPAREN exp RPAREN quadsIf statements ifelse jumpsIf
    (70) while -> . WHILE LPAREN saveJumps exp RPAREN quadsWhile statements jumpsWhile whilep
    (76) for -> . FOR LPAREN var SEMICOLON exp SEMICOLON exp RPAREN LBRACKET statements forp
    (60) var -> . ID

    FUNCTION        shift and go to state 11
    ID              shift and go to state 51
    READ            shift and go to state 52
    PRINT           shift and go to state 53
    IF              shift and go to state 54
    WHILE           shift and go to state 55
    FOR             shift and go to state 56

    statements                     shift and go to state 128
    assign                         shift and go to state 41
    function                       shift and go to state 42
    voidfunction                   shift and go to state 43
    call                           shift and go to state 44
    read                           shift and go to state 45
    print                          shift and go to state 46
    if                             shift and go to state 47
    while                          shift and go to state 48
    for                            shift and go to state 49
    var                            shift and go to state 50

state 125

    (76) for -> FOR LPAREN var SEMICOLON exp SEMICOLON . exp RPAREN LBRACKET statements forp
    (25) exp -> . texp
    (26) exp -> . texp OR exp
    (27) texp -> . gexp
    (28) texp -> . gexp AND texp
    (29) gexp -> . mexp
    (30) gexp -> . mexp gexpp mexp
    (35) mexp -> . t
    (36) mexp -> . t PLUS mexp
    (37) mexp -> . t MINUS mexp
    (38) t -> . f
    (39) t -> . f MULT t
    (40) t -> . f DIV t
    (41) f -> . LPAREN exp RPAREN
    (42) f -> . CTI
    (43) f -> . CTF
    (44) f -> . var
    (45) f -> . call
    (60) var -> . ID
    (61) call -> . ID LPAREN callp RPAREN

    LPAREN          shift and go to state 78
    CTI             shift and go to state 79
    CTF             shift and go to state 80
    ID              shift and go to state 82

    var                            shift and go to state 71
    exp                            shift and go to state 129
    texp                           shift and go to state 73
    gexp                           shift and go to state 74
    mexp                           shift and go to state 75
    t                              shift and go to state 76
    f                              shift and go to state 77
    call                           shift and go to state 81

state 126

    (64) if -> IF LPAREN exp RPAREN quadsIf statements ifelse . jumpsIf
    (68) jumpsIf -> .

    VAR             reduce using rule 68 (jumpsIf -> .)
    FUNCTION        reduce using rule 68 (jumpsIf -> .)
    ID              reduce using rule 68 (jumpsIf -> .)
    READ            reduce using rule 68 (jumpsIf -> .)
    PRINT           reduce using rule 68 (jumpsIf -> .)
    IF              reduce using rule 68 (jumpsIf -> .)
    WHILE           reduce using rule 68 (jumpsIf -> .)
    FOR             reduce using rule 68 (jumpsIf -> .)
    RBRACE          reduce using rule 68 (jumpsIf -> .)
    ELSE            reduce using rule 68 (jumpsIf -> .)
    SEMICOLON       reduce using rule 68 (jumpsIf -> .)
    RBRACKET        reduce using rule 68 (jumpsIf -> .)

    jumpsIf                        shift and go to state 130

state 127

    (66) ifelse -> ELSE . quadsElse statements
    (69) quadsElse -> .

    FUNCTION        reduce using rule 69 (quadsElse -> .)
    ID              reduce using rule 69 (quadsElse -> .)
    READ            reduce using rule 69 (quadsElse -> .)
    PRINT           reduce using rule 69 (quadsElse -> .)
    IF              reduce using rule 69 (quadsElse -> .)
    WHILE           reduce using rule 69 (quadsElse -> .)
    FOR             reduce using rule 69 (quadsElse -> .)

    quadsElse                      shift and go to state 131

state 128

    (70) while -> WHILE LPAREN saveJumps exp RPAREN quadsWhile statements . jumpsWhile whilep
    (75) jumpsWhile -> .

    SEMICOLON       reduce using rule 75 (jumpsWhile -> .)
    FUNCTION        reduce using rule 75 (jumpsWhile -> .)
    ID              reduce using rule 75 (jumpsWhile -> .)
    READ            reduce using rule 75 (jumpsWhile -> .)
    PRINT           reduce using rule 75 (jumpsWhile -> .)
    IF              reduce using rule 75 (jumpsWhile -> .)
    WHILE           reduce using rule 75 (jumpsWhile -> .)
    FOR             reduce using rule 75 (jumpsWhile -> .)

    jumpsWhile                     shift and go to state 132

state 129

    (76) for -> FOR LPAREN var SEMICOLON exp SEMICOLON exp . RPAREN LBRACKET statements forp

    RPAREN          shift and go to state 133


state 130

    (64) if -> IF LPAREN exp RPAREN quadsIf statements ifelse jumpsIf .

    VAR             reduce using rule 64 (if -> IF LPAREN exp RPAREN quadsIf statements ifelse jumpsIf .)
    FUNCTION        reduce using rule 64 (if -> IF LPAREN exp RPAREN quadsIf statements ifelse jumpsIf .)
    ID              reduce using rule 64 (if -> IF LPAREN exp RPAREN quadsIf statements ifelse jumpsIf .)
    READ            reduce using rule 64 (if -> IF LPAREN exp RPAREN quadsIf statements ifelse jumpsIf .)
    PRINT           reduce using rule 64 (if -> IF LPAREN exp RPAREN quadsIf statements ifelse jumpsIf .)
    IF              reduce using rule 64 (if -> IF LPAREN exp RPAREN quadsIf statements ifelse jumpsIf .)
    WHILE           reduce using rule 64 (if -> IF LPAREN exp RPAREN quadsIf statements ifelse jumpsIf .)
    FOR             reduce using rule 64 (if -> IF LPAREN exp RPAREN quadsIf statements ifelse jumpsIf .)
    RBRACE          reduce using rule 64 (if -> IF LPAREN exp RPAREN quadsIf statements ifelse jumpsIf .)
    ELSE            reduce using rule 64 (if -> IF LPAREN exp RPAREN quadsIf statements ifelse jumpsIf .)
    SEMICOLON       reduce using rule 64 (if -> IF LPAREN exp RPAREN quadsIf statements ifelse jumpsIf .)
    RBRACKET        reduce using rule 64 (if -> IF LPAREN exp RPAREN quadsIf statements ifelse jumpsIf .)


state 131

    (66) ifelse -> ELSE quadsElse . statements
    (46) statements -> . assign
    (47) statements -> . function
    (48) statements -> . voidfunction
    (49) statements -> . call
    (50) statements -> . read
    (51) statements -> . print
    (52) statements -> . if
    (53) statements -> . while
    (54) statements -> . for
    (55) assign -> . var EQUAL exp SEMICOLON
    (11) function -> . FUNCTION type decfunc LPAREN param RPAREN LBRACE body RBRACE
    (13) voidfunction -> . FUNCTION VOID decfunc LPAREN param RPAREN LBRACE body RBRACE
    (61) call -> . ID LPAREN callp RPAREN
    (56) read -> . READ var
    (57) print -> . PRINT LPAREN printp
    (64) if -> . IF LPAREN exp RPAREN quadsIf statements ifelse jumpsIf
    (70) while -> . WHILE LPAREN saveJumps exp RPAREN quadsWhile statements jumpsWhile whilep
    (76) for -> . FOR LPAREN var SEMICOLON exp SEMICOLON exp RPAREN LBRACKET statements forp
    (60) var -> . ID

    FUNCTION        shift and go to state 11
    ID              shift and go to state 51
    READ            shift and go to state 52
    PRINT           shift and go to state 53
    IF              shift and go to state 54
    WHILE           shift and go to state 55
    FOR             shift and go to state 56

    statements                     shift and go to state 134
    assign                         shift and go to state 41
    function                       shift and go to state 42
    voidfunction                   shift and go to state 43
    call                           shift and go to state 44
    read                           shift and go to state 45
    print                          shift and go to state 46
    if                             shift and go to state 47
    while                          shift and go to state 48
    for                            shift and go to state 49
    var                            shift and go to state 50

state 132

    (70) while -> WHILE LPAREN saveJumps exp RPAREN quadsWhile statements jumpsWhile . whilep
    (71) whilep -> . SEMICOLON
    (72) whilep -> . statements whilep
    (46) statements -> . assign
    (47) statements -> . function
    (48) statements -> . voidfunction
    (49) statements -> . call
    (50) statements -> . read
    (51) statements -> . print
    (52) statements -> . if
    (53) statements -> . while
    (54) statements -> . for
    (55) assign -> . var EQUAL exp SEMICOLON
    (11) function -> . FUNCTION type decfunc LPAREN param RPAREN LBRACE body RBRACE
    (13) voidfunction -> . FUNCTION VOID decfunc LPAREN param RPAREN LBRACE body RBRACE
    (61) call -> . ID LPAREN callp RPAREN
    (56) read -> . READ var
    (57) print -> . PRINT LPAREN printp
    (64) if -> . IF LPAREN exp RPAREN quadsIf statements ifelse jumpsIf
    (70) while -> . WHILE LPAREN saveJumps exp RPAREN quadsWhile statements jumpsWhile whilep
    (76) for -> . FOR LPAREN var SEMICOLON exp SEMICOLON exp RPAREN LBRACKET statements forp
    (60) var -> . ID

    SEMICOLON       shift and go to state 137
    FUNCTION        shift and go to state 11
    ID              shift and go to state 51
    READ            shift and go to state 52
    PRINT           shift and go to state 53
    IF              shift and go to state 54
    WHILE           shift and go to state 55
    FOR             shift and go to state 56

    statements                     shift and go to state 135
    whilep                         shift and go to state 136
    assign                         shift and go to state 41
    function                       shift and go to state 42
    voidfunction                   shift and go to state 43
    call                           shift and go to state 44
    read                           shift and go to state 45
    print                          shift and go to state 46
    if                             shift and go to state 47
    while                          shift and go to state 48
    for                            shift and go to state 49
    var                            shift and go to state 50

state 133

    (76) for -> FOR LPAREN var SEMICOLON exp SEMICOLON exp RPAREN . LBRACKET statements forp

    LBRACKET        shift and go to state 138


state 134

    (66) ifelse -> ELSE quadsElse statements .

    ELSE            reduce using rule 66 (ifelse -> ELSE quadsElse statements .)
    VAR             reduce using rule 66 (ifelse -> ELSE quadsElse statements .)
    FUNCTION        reduce using rule 66 (ifelse -> ELSE quadsElse statements .)
    ID              reduce using rule 66 (ifelse -> ELSE quadsElse statements .)
    READ            reduce using rule 66 (ifelse -> ELSE quadsElse statements .)
    PRINT           reduce using rule 66 (ifelse -> ELSE quadsElse statements .)
    IF              reduce using rule 66 (ifelse -> ELSE quadsElse statements .)
    WHILE           reduce using rule 66 (ifelse -> ELSE quadsElse statements .)
    FOR             reduce using rule 66 (ifelse -> ELSE quadsElse statements .)
    RBRACE          reduce using rule 66 (ifelse -> ELSE quadsElse statements .)
    SEMICOLON       reduce using rule 66 (ifelse -> ELSE quadsElse statements .)
    RBRACKET        reduce using rule 66 (ifelse -> ELSE quadsElse statements .)


state 135

    (72) whilep -> statements . whilep
    (71) whilep -> . SEMICOLON
    (72) whilep -> . statements whilep
    (46) statements -> . assign
    (47) statements -> . function
    (48) statements -> . voidfunction
    (49) statements -> . call
    (50) statements -> . read
    (51) statements -> . print
    (52) statements -> . if
    (53) statements -> . while
    (54) statements -> . for
    (55) assign -> . var EQUAL exp SEMICOLON
    (11) function -> . FUNCTION type decfunc LPAREN param RPAREN LBRACE body RBRACE
    (13) voidfunction -> . FUNCTION VOID decfunc LPAREN param RPAREN LBRACE body RBRACE
    (61) call -> . ID LPAREN callp RPAREN
    (56) read -> . READ var
    (57) print -> . PRINT LPAREN printp
    (64) if -> . IF LPAREN exp RPAREN quadsIf statements ifelse jumpsIf
    (70) while -> . WHILE LPAREN saveJumps exp RPAREN quadsWhile statements jumpsWhile whilep
    (76) for -> . FOR LPAREN var SEMICOLON exp SEMICOLON exp RPAREN LBRACKET statements forp
    (60) var -> . ID

    SEMICOLON       shift and go to state 137
    FUNCTION        shift and go to state 11
    ID              shift and go to state 51
    READ            shift and go to state 52
    PRINT           shift and go to state 53
    IF              shift and go to state 54
    WHILE           shift and go to state 55
    FOR             shift and go to state 56

    statements                     shift and go to state 135
    whilep                         shift and go to state 139
    assign                         shift and go to state 41
    function                       shift and go to state 42
    voidfunction                   shift and go to state 43
    call                           shift and go to state 44
    read                           shift and go to state 45
    print                          shift and go to state 46
    if                             shift and go to state 47
    while                          shift and go to state 48
    for                            shift and go to state 49
    var                            shift and go to state 50

state 136

    (70) while -> WHILE LPAREN saveJumps exp RPAREN quadsWhile statements jumpsWhile whilep .

    VAR             reduce using rule 70 (while -> WHILE LPAREN saveJumps exp RPAREN quadsWhile statements jumpsWhile whilep .)
    FUNCTION        reduce using rule 70 (while -> WHILE LPAREN saveJumps exp RPAREN quadsWhile statements jumpsWhile whilep .)
    ID              reduce using rule 70 (while -> WHILE LPAREN saveJumps exp RPAREN quadsWhile statements jumpsWhile whilep .)
    READ            reduce using rule 70 (while -> WHILE LPAREN saveJumps exp RPAREN quadsWhile statements jumpsWhile whilep .)
    PRINT           reduce using rule 70 (while -> WHILE LPAREN saveJumps exp RPAREN quadsWhile statements jumpsWhile whilep .)
    IF              reduce using rule 70 (while -> WHILE LPAREN saveJumps exp RPAREN quadsWhile statements jumpsWhile whilep .)
    WHILE           reduce using rule 70 (while -> WHILE LPAREN saveJumps exp RPAREN quadsWhile statements jumpsWhile whilep .)
    FOR             reduce using rule 70 (while -> WHILE LPAREN saveJumps exp RPAREN quadsWhile statements jumpsWhile whilep .)
    RBRACE          reduce using rule 70 (while -> WHILE LPAREN saveJumps exp RPAREN quadsWhile statements jumpsWhile whilep .)
    ELSE            reduce using rule 70 (while -> WHILE LPAREN saveJumps exp RPAREN quadsWhile statements jumpsWhile whilep .)
    SEMICOLON       reduce using rule 70 (while -> WHILE LPAREN saveJumps exp RPAREN quadsWhile statements jumpsWhile whilep .)
    RBRACKET        reduce using rule 70 (while -> WHILE LPAREN saveJumps exp RPAREN quadsWhile statements jumpsWhile whilep .)


state 137

    (71) whilep -> SEMICOLON .

    VAR             reduce using rule 71 (whilep -> SEMICOLON .)
    FUNCTION        reduce using rule 71 (whilep -> SEMICOLON .)
    ID              reduce using rule 71 (whilep -> SEMICOLON .)
    READ            reduce using rule 71 (whilep -> SEMICOLON .)
    PRINT           reduce using rule 71 (whilep -> SEMICOLON .)
    IF              reduce using rule 71 (whilep -> SEMICOLON .)
    WHILE           reduce using rule 71 (whilep -> SEMICOLON .)
    FOR             reduce using rule 71 (whilep -> SEMICOLON .)
    RBRACE          reduce using rule 71 (whilep -> SEMICOLON .)
    ELSE            reduce using rule 71 (whilep -> SEMICOLON .)
    SEMICOLON       reduce using rule 71 (whilep -> SEMICOLON .)
    RBRACKET        reduce using rule 71 (whilep -> SEMICOLON .)


state 138

    (76) for -> FOR LPAREN var SEMICOLON exp SEMICOLON exp RPAREN LBRACKET . statements forp
    (46) statements -> . assign
    (47) statements -> . function
    (48) statements -> . voidfunction
    (49) statements -> . call
    (50) statements -> . read
    (51) statements -> . print
    (52) statements -> . if
    (53) statements -> . while
    (54) statements -> . for
    (55) assign -> . var EQUAL exp SEMICOLON
    (11) function -> . FUNCTION type decfunc LPAREN param RPAREN LBRACE body RBRACE
    (13) voidfunction -> . FUNCTION VOID decfunc LPAREN param RPAREN LBRACE body RBRACE
    (61) call -> . ID LPAREN callp RPAREN
    (56) read -> . READ var
    (57) print -> . PRINT LPAREN printp
    (64) if -> . IF LPAREN exp RPAREN quadsIf statements ifelse jumpsIf
    (70) while -> . WHILE LPAREN saveJumps exp RPAREN quadsWhile statements jumpsWhile whilep
    (76) for -> . FOR LPAREN var SEMICOLON exp SEMICOLON exp RPAREN LBRACKET statements forp
    (60) var -> . ID

    FUNCTION        shift and go to state 11
    ID              shift and go to state 51
    READ            shift and go to state 52
    PRINT           shift and go to state 53
    IF              shift and go to state 54
    WHILE           shift and go to state 55
    FOR             shift and go to state 56

    var                            shift and go to state 50
    statements                     shift and go to state 140
    assign                         shift and go to state 41
    function                       shift and go to state 42
    voidfunction                   shift and go to state 43
    call                           shift and go to state 44
    read                           shift and go to state 45
    print                          shift and go to state 46
    if                             shift and go to state 47
    while                          shift and go to state 48
    for                            shift and go to state 49

state 139

    (72) whilep -> statements whilep .

    VAR             reduce using rule 72 (whilep -> statements whilep .)
    FUNCTION        reduce using rule 72 (whilep -> statements whilep .)
    ID              reduce using rule 72 (whilep -> statements whilep .)
    READ            reduce using rule 72 (whilep -> statements whilep .)
    PRINT           reduce using rule 72 (whilep -> statements whilep .)
    IF              reduce using rule 72 (whilep -> statements whilep .)
    WHILE           reduce using rule 72 (whilep -> statements whilep .)
    FOR             reduce using rule 72 (whilep -> statements whilep .)
    RBRACE          reduce using rule 72 (whilep -> statements whilep .)
    ELSE            reduce using rule 72 (whilep -> statements whilep .)
    SEMICOLON       reduce using rule 72 (whilep -> statements whilep .)
    RBRACKET        reduce using rule 72 (whilep -> statements whilep .)


state 140

    (76) for -> FOR LPAREN var SEMICOLON exp SEMICOLON exp RPAREN LBRACKET statements . forp
    (77) forp -> . RBRACKET
    (78) forp -> . statements forp
    (46) statements -> . assign
    (47) statements -> . function
    (48) statements -> . voidfunction
    (49) statements -> . call
    (50) statements -> . read
    (51) statements -> . print
    (52) statements -> . if
    (53) statements -> . while
    (54) statements -> . for
    (55) assign -> . var EQUAL exp SEMICOLON
    (11) function -> . FUNCTION type decfunc LPAREN param RPAREN LBRACE body RBRACE
    (13) voidfunction -> . FUNCTION VOID decfunc LPAREN param RPAREN LBRACE body RBRACE
    (61) call -> . ID LPAREN callp RPAREN
    (56) read -> . READ var
    (57) print -> . PRINT LPAREN printp
    (64) if -> . IF LPAREN exp RPAREN quadsIf statements ifelse jumpsIf
    (70) while -> . WHILE LPAREN saveJumps exp RPAREN quadsWhile statements jumpsWhile whilep
    (76) for -> . FOR LPAREN var SEMICOLON exp SEMICOLON exp RPAREN LBRACKET statements forp
    (60) var -> . ID

    RBRACKET        shift and go to state 143
    FUNCTION        shift and go to state 11
    ID              shift and go to state 51
    READ            shift and go to state 52
    PRINT           shift and go to state 53
    IF              shift and go to state 54
    WHILE           shift and go to state 55
    FOR             shift and go to state 56

    var                            shift and go to state 50
    statements                     shift and go to state 141
    forp                           shift and go to state 142
    assign                         shift and go to state 41
    function                       shift and go to state 42
    voidfunction                   shift and go to state 43
    call                           shift and go to state 44
    read                           shift and go to state 45
    print                          shift and go to state 46
    if                             shift and go to state 47
    while                          shift and go to state 48
    for                            shift and go to state 49

state 141

    (78) forp -> statements . forp
    (77) forp -> . RBRACKET
    (78) forp -> . statements forp
    (46) statements -> . assign
    (47) statements -> . function
    (48) statements -> . voidfunction
    (49) statements -> . call
    (50) statements -> . read
    (51) statements -> . print
    (52) statements -> . if
    (53) statements -> . while
    (54) statements -> . for
    (55) assign -> . var EQUAL exp SEMICOLON
    (11) function -> . FUNCTION type decfunc LPAREN param RPAREN LBRACE body RBRACE
    (13) voidfunction -> . FUNCTION VOID decfunc LPAREN param RPAREN LBRACE body RBRACE
    (61) call -> . ID LPAREN callp RPAREN
    (56) read -> . READ var
    (57) print -> . PRINT LPAREN printp
    (64) if -> . IF LPAREN exp RPAREN quadsIf statements ifelse jumpsIf
    (70) while -> . WHILE LPAREN saveJumps exp RPAREN quadsWhile statements jumpsWhile whilep
    (76) for -> . FOR LPAREN var SEMICOLON exp SEMICOLON exp RPAREN LBRACKET statements forp
    (60) var -> . ID

    RBRACKET        shift and go to state 143
    FUNCTION        shift and go to state 11
    ID              shift and go to state 51
    READ            shift and go to state 52
    PRINT           shift and go to state 53
    IF              shift and go to state 54
    WHILE           shift and go to state 55
    FOR             shift and go to state 56

    statements                     shift and go to state 141
    forp                           shift and go to state 144
    assign                         shift and go to state 41
    function                       shift and go to state 42
    voidfunction                   shift and go to state 43
    call                           shift and go to state 44
    read                           shift and go to state 45
    print                          shift and go to state 46
    if                             shift and go to state 47
    while                          shift and go to state 48
    for                            shift and go to state 49
    var                            shift and go to state 50

state 142

    (76) for -> FOR LPAREN var SEMICOLON exp SEMICOLON exp RPAREN LBRACKET statements forp .

    VAR             reduce using rule 76 (for -> FOR LPAREN var SEMICOLON exp SEMICOLON exp RPAREN LBRACKET statements forp .)
    FUNCTION        reduce using rule 76 (for -> FOR LPAREN var SEMICOLON exp SEMICOLON exp RPAREN LBRACKET statements forp .)
    ID              reduce using rule 76 (for -> FOR LPAREN var SEMICOLON exp SEMICOLON exp RPAREN LBRACKET statements forp .)
    READ            reduce using rule 76 (for -> FOR LPAREN var SEMICOLON exp SEMICOLON exp RPAREN LBRACKET statements forp .)
    PRINT           reduce using rule 76 (for -> FOR LPAREN var SEMICOLON exp SEMICOLON exp RPAREN LBRACKET statements forp .)
    IF              reduce using rule 76 (for -> FOR LPAREN var SEMICOLON exp SEMICOLON exp RPAREN LBRACKET statements forp .)
    WHILE           reduce using rule 76 (for -> FOR LPAREN var SEMICOLON exp SEMICOLON exp RPAREN LBRACKET statements forp .)
    FOR             reduce using rule 76 (for -> FOR LPAREN var SEMICOLON exp SEMICOLON exp RPAREN LBRACKET statements forp .)
    RBRACE          reduce using rule 76 (for -> FOR LPAREN var SEMICOLON exp SEMICOLON exp RPAREN LBRACKET statements forp .)
    ELSE            reduce using rule 76 (for -> FOR LPAREN var SEMICOLON exp SEMICOLON exp RPAREN LBRACKET statements forp .)
    SEMICOLON       reduce using rule 76 (for -> FOR LPAREN var SEMICOLON exp SEMICOLON exp RPAREN LBRACKET statements forp .)
    RBRACKET        reduce using rule 76 (for -> FOR LPAREN var SEMICOLON exp SEMICOLON exp RPAREN LBRACKET statements forp .)


state 143

    (77) forp -> RBRACKET .

    VAR             reduce using rule 77 (forp -> RBRACKET .)
    FUNCTION        reduce using rule 77 (forp -> RBRACKET .)
    ID              reduce using rule 77 (forp -> RBRACKET .)
    READ            reduce using rule 77 (forp -> RBRACKET .)
    PRINT           reduce using rule 77 (forp -> RBRACKET .)
    IF              reduce using rule 77 (forp -> RBRACKET .)
    WHILE           reduce using rule 77 (forp -> RBRACKET .)
    FOR             reduce using rule 77 (forp -> RBRACKET .)
    RBRACE          reduce using rule 77 (forp -> RBRACKET .)
    ELSE            reduce using rule 77 (forp -> RBRACKET .)
    SEMICOLON       reduce using rule 77 (forp -> RBRACKET .)
    RBRACKET        reduce using rule 77 (forp -> RBRACKET .)


state 144

    (78) forp -> statements forp .

    VAR             reduce using rule 78 (forp -> statements forp .)
    FUNCTION        reduce using rule 78 (forp -> statements forp .)
    ID              reduce using rule 78 (forp -> statements forp .)
    READ            reduce using rule 78 (forp -> statements forp .)
    PRINT           reduce using rule 78 (forp -> statements forp .)
    IF              reduce using rule 78 (forp -> statements forp .)
    WHILE           reduce using rule 78 (forp -> statements forp .)
    FOR             reduce using rule 78 (forp -> statements forp .)
    RBRACE          reduce using rule 78 (forp -> statements forp .)
    ELSE            reduce using rule 78 (forp -> statements forp .)
    SEMICOLON       reduce using rule 78 (forp -> statements forp .)
    RBRACKET        reduce using rule 78 (forp -> statements forp .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for FUNCTION in state 36 resolved as shift
WARNING: shift/reduce conflict for ID in state 36 resolved as shift
WARNING: shift/reduce conflict for READ in state 36 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 36 resolved as shift
WARNING: shift/reduce conflict for IF in state 36 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 36 resolved as shift
WARNING: shift/reduce conflict for FOR in state 36 resolved as shift
WARNING: shift/reduce conflict for FUNCTION in state 37 resolved as shift
WARNING: shift/reduce conflict for ID in state 37 resolved as shift
WARNING: shift/reduce conflict for READ in state 37 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 37 resolved as shift
WARNING: shift/reduce conflict for IF in state 37 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 37 resolved as shift
WARNING: shift/reduce conflict for FOR in state 37 resolved as shift
WARNING: shift/reduce conflict for FUNCTION in state 40 resolved as shift
WARNING: shift/reduce conflict for ID in state 40 resolved as shift
WARNING: shift/reduce conflict for READ in state 40 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 40 resolved as shift
WARNING: shift/reduce conflict for IF in state 40 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 40 resolved as shift
WARNING: shift/reduce conflict for FOR in state 40 resolved as shift
WARNING: shift/reduce conflict for FUNCTION in state 59 resolved as shift
WARNING: shift/reduce conflict for ID in state 59 resolved as shift
WARNING: shift/reduce conflict for READ in state 59 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 59 resolved as shift
WARNING: shift/reduce conflict for IF in state 59 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 59 resolved as shift
WARNING: shift/reduce conflict for FOR in state 59 resolved as shift
WARNING: shift/reduce conflict for ELSE in state 123 resolved as shift
WARNING: reduce/reduce conflict in state 12 resolved using rule (decvar -> VAR decvarp)
WARNING: rejected rule (decvar -> <empty>) in state 12
WARNING: reduce/reduce conflict in state 28 resolved using rule (decvar -> <empty>)
WARNING: rejected rule (param -> <empty>) in state 28
WARNING: reduce/reduce conflict in state 29 resolved using rule (decvar -> <empty>)
WARNING: rejected rule (param -> <empty>) in state 29
WARNING: reduce/reduce conflict in state 36 resolved using rule (decvar -> <empty>)
WARNING: rejected rule (body -> <empty>) in state 36
WARNING: reduce/reduce conflict in state 37 resolved using rule (decvar -> <empty>)
WARNING: rejected rule (body -> <empty>) in state 37
WARNING: reduce/reduce conflict in state 40 resolved using rule (decvar -> <empty>)
WARNING: rejected rule (body -> <empty>) in state 40
WARNING: reduce/reduce conflict in state 59 resolved using rule (decvar -> <empty>)
WARNING: rejected rule (body -> <empty>) in state 59
WARNING: Rule (param -> <empty>) is never reduced
WARNING: Rule (body -> <empty>) is never reduced
