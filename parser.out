Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    ASSIGN
    CHAR
    COLON
    FUNCESP
    GTE
    LTE
    NUMPY
    QUOTE
    STRING

Grammar

Rule 0     S' -> program
Rule 1     program -> PROGRAM ID SEMICOLON if
Rule 2     decvar -> VAR decvarp
Rule 3     decvar -> VAR decvarp decvar
Rule 4     decvarp -> type decvarpp SEMICOLON
Rule 5     decvarpp -> ID COMMA decvarpp
Rule 6     decvarpp -> ID
Rule 7     type -> INT
Rule 8     type -> FLOAT
Rule 9     function -> FUNCTION type ID LPAREN param RPAREN body
Rule 10    voidfunction -> FUNCTION VOID ID LPAREN param RPAREN body
Rule 11    body -> LBRACE bodyp RBRACE
Rule 12    bodyp -> decvar statements bodyp
Rule 13    bodyp -> statements bodyp
Rule 14    bodyp -> decvar
Rule 15    bodyp -> <empty>
Rule 16    param -> <empty>
Rule 17    param -> type paramp
Rule 18    paramp -> ID
Rule 19    paramp -> ID COMMA param
Rule 20    exp -> texp
Rule 21    exp -> texp OR exp
Rule 22    texp -> gexp
Rule 23    texp -> gexp AND texp
Rule 24    gexp -> mexp
Rule 25    gexp -> mexp gexpp mexp
Rule 26    gexpp -> LT
Rule 27    gexpp -> GT
Rule 28    gexpp -> IFEQUAL
Rule 29    gexpp -> DIFF
Rule 30    mexp -> t
Rule 31    mexp -> t PLUS mexp
Rule 32    mexp -> t MINUS mexp
Rule 33    t -> f
Rule 34    t -> f MULT t
Rule 35    t -> f DIV t
Rule 36    f -> LPAREN exp RPAREN
Rule 37    f -> CTI
Rule 38    f -> CTF
Rule 39    f -> var
Rule 40    f -> call
Rule 41    statements -> assign
Rule 42    statements -> function
Rule 43    statements -> voidfunction
Rule 44    statements -> call
Rule 45    statements -> read
Rule 46    statements -> print
Rule 47    statements -> if
Rule 48    statements -> while
Rule 49    statements -> for
Rule 50    statements -> funcesp
Rule 51    assign -> var EQUAL exp
Rule 52    read -> READ var
Rule 53    print -> PRINT LPAREN printp
Rule 54    printp -> exp RPAREN
Rule 55    printp -> exp COMMA printp
Rule 56    var -> ID
Rule 57    call -> ID LPAREN callp RPAREN
Rule 58    callp -> exp SEMICOLON callp
Rule 59    callp -> exp
Rule 60    if -> IF LPAREN exp RPAREN quadsIf ifelse jumpsIf
Rule 61    ifelse -> <empty>
Rule 62    ifelse -> ELSE quadsElse
Rule 63    quadsIf -> <empty>
Rule 64    jumpsIf -> <empty>
Rule 65    quadsElse -> <empty>
Rule 66    while -> WHILE LPAREN saveJumps exp RPAREN quadsWhile statements jumpsWhile whilep
Rule 67    whilep -> SEMICOLON
Rule 68    whilep -> statements whilep
Rule 69    saveJumps -> <empty>
Rule 70    quadsWhile -> <empty>
Rule 71    jumpsWhile -> <empty>
Rule 72    for -> FOR LPAREN var SEMICOLON exp SEMICOLON exp RPAREN LBRACKET statements forp
Rule 73    forp -> RBRACKET
Rule 74    forp -> statements forp
Rule 75    funcesp -> array
Rule 76    funcesp -> matrix
Rule 77    funcesp -> mean
Rule 78    funcesp -> layers
Rule 79    funcesp -> sequential
Rule 80    funcesp -> compile
Rule 81    funcesp -> fit
Rule 82    funcesp -> predict
Rule 83    funcesp -> getweights
Rule 84    array -> ID EQUAL ARRAY LPAREN var arrayp
Rule 85    arrayp -> RPAREN
Rule 86    arrayp -> COMMA var RPAREN
Rule 87    matrix -> ID EQUAL MATRIX LPAREN array matrixp
Rule 88    matrixp -> RPAREN
Rule 89    matrixp -> COMMA array RPAREN
Rule 90    mean -> MEAN LPAREN array RPAREN
Rule 91    layers -> ID EQUAL LAYERS LPAREN UNITS EQUAL INT RPAREN
Rule 92    sequential -> ID EQUAL SEQUENTIAL LPAREN LBRACKET layers sequentialp
Rule 93    sequentialp -> RBRACKET RPAREN
Rule 94    sequentialp -> COMMA layers sequentialp
Rule 95    compile -> sequential DOT COMPILE LPAREN RPAREN
Rule 96    fit -> ID EQUAL sequential DOT FIT LPAREN array COMMA array COMMA EPOCHS EQUAL INT COMMA VERBOSE EQUAL fitp
Rule 97    fitp -> TRUE RPAREN
Rule 98    fitp -> FALSE RPAREN
Rule 99    predict -> ID EQUAL sequential DOT PREDICT LPAREN LBRACKET predictp
Rule 100   predictp -> INT RBRACKET RPAREN
Rule 101   predictp -> FLOAT RBRACKET RPAREN
Rule 102   getweights -> layers DOT GETWEIGHTS LPAREN RPAREN
Rule 103   empty -> <empty>

Terminals, with rules where they appear

AND                  : 23
ARRAY                : 84
ASSIGN               : 
CHAR                 : 
COLON                : 
COMMA                : 5 19 55 86 89 94 96 96 96
COMPILE              : 95
CTF                  : 38
CTI                  : 37
DIFF                 : 29
DIV                  : 35
DOT                  : 95 96 99 102
ELSE                 : 62
EPOCHS               : 96
EQUAL                : 51 84 87 91 91 92 96 96 96 99
FALSE                : 98
FIT                  : 96
FLOAT                : 8 101
FOR                  : 72
FUNCESP              : 
FUNCTION             : 9 10
GETWEIGHTS           : 102
GT                   : 27
GTE                  : 
ID                   : 1 5 6 9 10 18 19 56 57 84 87 91 92 96 99
IF                   : 60
IFEQUAL              : 28
INT                  : 7 91 96 100
LAYERS               : 91
LBRACE               : 11
LBRACKET             : 72 92 99
LPAREN               : 9 10 36 53 57 60 66 72 84 87 90 91 92 95 96 99 102
LT                   : 26
LTE                  : 
MATRIX               : 87
MEAN                 : 90
MINUS                : 32
MULT                 : 34
NUMPY                : 
OR                   : 21
PLUS                 : 31
PREDICT              : 99
PRINT                : 53
PROGRAM              : 1
QUOTE                : 
RBRACE               : 11
RBRACKET             : 73 93 100 101
READ                 : 52
RPAREN               : 9 10 36 54 57 60 66 72 85 86 88 89 90 91 93 95 97 98 100 101 102
SEMICOLON            : 1 4 58 67 72 72
SEQUENTIAL           : 92
STRING               : 
TRUE                 : 97
UNITS                : 91
VAR                  : 2 3
VERBOSE              : 96
VOID                 : 10
WHILE                : 66
error                : 

Nonterminals, with rules where they appear

array                : 75 87 89 90 96 96
arrayp               : 84
assign               : 41
body                 : 9 10
bodyp                : 11 12 13
call                 : 40 44
callp                : 57 58
compile              : 80
decvar               : 3 12 14
decvarp              : 2 3
decvarpp             : 4 5
empty                : 
exp                  : 21 36 51 54 55 58 59 60 66 72 72
f                    : 33 34 35
fit                  : 81
fitp                 : 96
for                  : 49
forp                 : 72 74
funcesp              : 50
function             : 42
getweights           : 83
gexp                 : 22 23
gexpp                : 25
if                   : 1 47
ifelse               : 60
jumpsIf              : 60
jumpsWhile           : 66
layers               : 78 92 94 102
matrix               : 76
matrixp              : 87
mean                 : 77
mexp                 : 24 25 25 31 32
param                : 9 10 19
paramp               : 17
predict              : 82
predictp             : 99
print                : 46
printp               : 53 55
program              : 0
quadsElse            : 62
quadsIf              : 60
quadsWhile           : 66
read                 : 45
saveJumps            : 66
sequential           : 79 95 96 99
sequentialp          : 92 94
statements           : 12 13 66 68 72 74
t                    : 30 31 32 34 35
texp                 : 20 21 23
type                 : 4 9 17
var                  : 39 51 52 72 84 86
voidfunction         : 43
while                : 48
whilep               : 66 68

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . PROGRAM ID SEMICOLON if

    PROGRAM         shift and go to state 2

    program                        shift and go to state 1

state 1

    (0) S' -> program .



state 2

    (1) program -> PROGRAM . ID SEMICOLON if

    ID              shift and go to state 3


state 3

    (1) program -> PROGRAM ID . SEMICOLON if

    SEMICOLON       shift and go to state 4


state 4

    (1) program -> PROGRAM ID SEMICOLON . if
    (60) if -> . IF LPAREN exp RPAREN quadsIf ifelse jumpsIf

    IF              shift and go to state 6

    if                             shift and go to state 5

state 5

    (1) program -> PROGRAM ID SEMICOLON if .

    $end            reduce using rule 1 (program -> PROGRAM ID SEMICOLON if .)


state 6

    (60) if -> IF . LPAREN exp RPAREN quadsIf ifelse jumpsIf

    LPAREN          shift and go to state 7


state 7

    (60) if -> IF LPAREN . exp RPAREN quadsIf ifelse jumpsIf
    (20) exp -> . texp
    (21) exp -> . texp OR exp
    (22) texp -> . gexp
    (23) texp -> . gexp AND texp
    (24) gexp -> . mexp
    (25) gexp -> . mexp gexpp mexp
    (30) mexp -> . t
    (31) mexp -> . t PLUS mexp
    (32) mexp -> . t MINUS mexp
    (33) t -> . f
    (34) t -> . f MULT t
    (35) t -> . f DIV t
    (36) f -> . LPAREN exp RPAREN
    (37) f -> . CTI
    (38) f -> . CTF
    (39) f -> . var
    (40) f -> . call
    (56) var -> . ID
    (57) call -> . ID LPAREN callp RPAREN

    LPAREN          shift and go to state 8
    CTI             shift and go to state 15
    CTF             shift and go to state 16
    ID              shift and go to state 19

    exp                            shift and go to state 9
    texp                           shift and go to state 10
    gexp                           shift and go to state 11
    mexp                           shift and go to state 12
    t                              shift and go to state 13
    f                              shift and go to state 14
    var                            shift and go to state 17
    call                           shift and go to state 18

state 8

    (36) f -> LPAREN . exp RPAREN
    (20) exp -> . texp
    (21) exp -> . texp OR exp
    (22) texp -> . gexp
    (23) texp -> . gexp AND texp
    (24) gexp -> . mexp
    (25) gexp -> . mexp gexpp mexp
    (30) mexp -> . t
    (31) mexp -> . t PLUS mexp
    (32) mexp -> . t MINUS mexp
    (33) t -> . f
    (34) t -> . f MULT t
    (35) t -> . f DIV t
    (36) f -> . LPAREN exp RPAREN
    (37) f -> . CTI
    (38) f -> . CTF
    (39) f -> . var
    (40) f -> . call
    (56) var -> . ID
    (57) call -> . ID LPAREN callp RPAREN

    LPAREN          shift and go to state 8
    CTI             shift and go to state 15
    CTF             shift and go to state 16
    ID              shift and go to state 19

    exp                            shift and go to state 20
    texp                           shift and go to state 10
    gexp                           shift and go to state 11
    mexp                           shift and go to state 12
    t                              shift and go to state 13
    f                              shift and go to state 14
    var                            shift and go to state 17
    call                           shift and go to state 18

state 9

    (60) if -> IF LPAREN exp . RPAREN quadsIf ifelse jumpsIf

    RPAREN          shift and go to state 21


state 10

    (20) exp -> texp .
    (21) exp -> texp . OR exp

    RPAREN          reduce using rule 20 (exp -> texp .)
    SEMICOLON       reduce using rule 20 (exp -> texp .)
    OR              shift and go to state 22


state 11

    (22) texp -> gexp .
    (23) texp -> gexp . AND texp

    OR              reduce using rule 22 (texp -> gexp .)
    RPAREN          reduce using rule 22 (texp -> gexp .)
    SEMICOLON       reduce using rule 22 (texp -> gexp .)
    AND             shift and go to state 23


state 12

    (24) gexp -> mexp .
    (25) gexp -> mexp . gexpp mexp
    (26) gexpp -> . LT
    (27) gexpp -> . GT
    (28) gexpp -> . IFEQUAL
    (29) gexpp -> . DIFF

    AND             reduce using rule 24 (gexp -> mexp .)
    OR              reduce using rule 24 (gexp -> mexp .)
    RPAREN          reduce using rule 24 (gexp -> mexp .)
    SEMICOLON       reduce using rule 24 (gexp -> mexp .)
    LT              shift and go to state 25
    GT              shift and go to state 26
    IFEQUAL         shift and go to state 27
    DIFF            shift and go to state 28

    gexpp                          shift and go to state 24

state 13

    (30) mexp -> t .
    (31) mexp -> t . PLUS mexp
    (32) mexp -> t . MINUS mexp

    LT              reduce using rule 30 (mexp -> t .)
    GT              reduce using rule 30 (mexp -> t .)
    IFEQUAL         reduce using rule 30 (mexp -> t .)
    DIFF            reduce using rule 30 (mexp -> t .)
    AND             reduce using rule 30 (mexp -> t .)
    OR              reduce using rule 30 (mexp -> t .)
    RPAREN          reduce using rule 30 (mexp -> t .)
    SEMICOLON       reduce using rule 30 (mexp -> t .)
    PLUS            shift and go to state 29
    MINUS           shift and go to state 30


state 14

    (33) t -> f .
    (34) t -> f . MULT t
    (35) t -> f . DIV t

    PLUS            reduce using rule 33 (t -> f .)
    MINUS           reduce using rule 33 (t -> f .)
    LT              reduce using rule 33 (t -> f .)
    GT              reduce using rule 33 (t -> f .)
    IFEQUAL         reduce using rule 33 (t -> f .)
    DIFF            reduce using rule 33 (t -> f .)
    AND             reduce using rule 33 (t -> f .)
    OR              reduce using rule 33 (t -> f .)
    RPAREN          reduce using rule 33 (t -> f .)
    SEMICOLON       reduce using rule 33 (t -> f .)
    MULT            shift and go to state 31
    DIV             shift and go to state 32


state 15

    (37) f -> CTI .

    MULT            reduce using rule 37 (f -> CTI .)
    DIV             reduce using rule 37 (f -> CTI .)
    PLUS            reduce using rule 37 (f -> CTI .)
    MINUS           reduce using rule 37 (f -> CTI .)
    LT              reduce using rule 37 (f -> CTI .)
    GT              reduce using rule 37 (f -> CTI .)
    IFEQUAL         reduce using rule 37 (f -> CTI .)
    DIFF            reduce using rule 37 (f -> CTI .)
    AND             reduce using rule 37 (f -> CTI .)
    OR              reduce using rule 37 (f -> CTI .)
    RPAREN          reduce using rule 37 (f -> CTI .)
    SEMICOLON       reduce using rule 37 (f -> CTI .)


state 16

    (38) f -> CTF .

    MULT            reduce using rule 38 (f -> CTF .)
    DIV             reduce using rule 38 (f -> CTF .)
    PLUS            reduce using rule 38 (f -> CTF .)
    MINUS           reduce using rule 38 (f -> CTF .)
    LT              reduce using rule 38 (f -> CTF .)
    GT              reduce using rule 38 (f -> CTF .)
    IFEQUAL         reduce using rule 38 (f -> CTF .)
    DIFF            reduce using rule 38 (f -> CTF .)
    AND             reduce using rule 38 (f -> CTF .)
    OR              reduce using rule 38 (f -> CTF .)
    RPAREN          reduce using rule 38 (f -> CTF .)
    SEMICOLON       reduce using rule 38 (f -> CTF .)


state 17

    (39) f -> var .

    MULT            reduce using rule 39 (f -> var .)
    DIV             reduce using rule 39 (f -> var .)
    PLUS            reduce using rule 39 (f -> var .)
    MINUS           reduce using rule 39 (f -> var .)
    LT              reduce using rule 39 (f -> var .)
    GT              reduce using rule 39 (f -> var .)
    IFEQUAL         reduce using rule 39 (f -> var .)
    DIFF            reduce using rule 39 (f -> var .)
    AND             reduce using rule 39 (f -> var .)
    OR              reduce using rule 39 (f -> var .)
    RPAREN          reduce using rule 39 (f -> var .)
    SEMICOLON       reduce using rule 39 (f -> var .)


state 18

    (40) f -> call .

    MULT            reduce using rule 40 (f -> call .)
    DIV             reduce using rule 40 (f -> call .)
    PLUS            reduce using rule 40 (f -> call .)
    MINUS           reduce using rule 40 (f -> call .)
    LT              reduce using rule 40 (f -> call .)
    GT              reduce using rule 40 (f -> call .)
    IFEQUAL         reduce using rule 40 (f -> call .)
    DIFF            reduce using rule 40 (f -> call .)
    AND             reduce using rule 40 (f -> call .)
    OR              reduce using rule 40 (f -> call .)
    RPAREN          reduce using rule 40 (f -> call .)
    SEMICOLON       reduce using rule 40 (f -> call .)


state 19

    (56) var -> ID .
    (57) call -> ID . LPAREN callp RPAREN

    MULT            reduce using rule 56 (var -> ID .)
    DIV             reduce using rule 56 (var -> ID .)
    PLUS            reduce using rule 56 (var -> ID .)
    MINUS           reduce using rule 56 (var -> ID .)
    LT              reduce using rule 56 (var -> ID .)
    GT              reduce using rule 56 (var -> ID .)
    IFEQUAL         reduce using rule 56 (var -> ID .)
    DIFF            reduce using rule 56 (var -> ID .)
    AND             reduce using rule 56 (var -> ID .)
    OR              reduce using rule 56 (var -> ID .)
    RPAREN          reduce using rule 56 (var -> ID .)
    SEMICOLON       reduce using rule 56 (var -> ID .)
    LPAREN          shift and go to state 33


state 20

    (36) f -> LPAREN exp . RPAREN

    RPAREN          shift and go to state 34


state 21

    (60) if -> IF LPAREN exp RPAREN . quadsIf ifelse jumpsIf
    (63) quadsIf -> .

    ELSE            reduce using rule 63 (quadsIf -> .)
    $end            reduce using rule 63 (quadsIf -> .)

    quadsIf                        shift and go to state 35

state 22

    (21) exp -> texp OR . exp
    (20) exp -> . texp
    (21) exp -> . texp OR exp
    (22) texp -> . gexp
    (23) texp -> . gexp AND texp
    (24) gexp -> . mexp
    (25) gexp -> . mexp gexpp mexp
    (30) mexp -> . t
    (31) mexp -> . t PLUS mexp
    (32) mexp -> . t MINUS mexp
    (33) t -> . f
    (34) t -> . f MULT t
    (35) t -> . f DIV t
    (36) f -> . LPAREN exp RPAREN
    (37) f -> . CTI
    (38) f -> . CTF
    (39) f -> . var
    (40) f -> . call
    (56) var -> . ID
    (57) call -> . ID LPAREN callp RPAREN

    LPAREN          shift and go to state 8
    CTI             shift and go to state 15
    CTF             shift and go to state 16
    ID              shift and go to state 19

    texp                           shift and go to state 10
    exp                            shift and go to state 36
    gexp                           shift and go to state 11
    mexp                           shift and go to state 12
    t                              shift and go to state 13
    f                              shift and go to state 14
    var                            shift and go to state 17
    call                           shift and go to state 18

state 23

    (23) texp -> gexp AND . texp
    (22) texp -> . gexp
    (23) texp -> . gexp AND texp
    (24) gexp -> . mexp
    (25) gexp -> . mexp gexpp mexp
    (30) mexp -> . t
    (31) mexp -> . t PLUS mexp
    (32) mexp -> . t MINUS mexp
    (33) t -> . f
    (34) t -> . f MULT t
    (35) t -> . f DIV t
    (36) f -> . LPAREN exp RPAREN
    (37) f -> . CTI
    (38) f -> . CTF
    (39) f -> . var
    (40) f -> . call
    (56) var -> . ID
    (57) call -> . ID LPAREN callp RPAREN

    LPAREN          shift and go to state 8
    CTI             shift and go to state 15
    CTF             shift and go to state 16
    ID              shift and go to state 19

    gexp                           shift and go to state 11
    texp                           shift and go to state 37
    mexp                           shift and go to state 12
    t                              shift and go to state 13
    f                              shift and go to state 14
    var                            shift and go to state 17
    call                           shift and go to state 18

state 24

    (25) gexp -> mexp gexpp . mexp
    (30) mexp -> . t
    (31) mexp -> . t PLUS mexp
    (32) mexp -> . t MINUS mexp
    (33) t -> . f
    (34) t -> . f MULT t
    (35) t -> . f DIV t
    (36) f -> . LPAREN exp RPAREN
    (37) f -> . CTI
    (38) f -> . CTF
    (39) f -> . var
    (40) f -> . call
    (56) var -> . ID
    (57) call -> . ID LPAREN callp RPAREN

    LPAREN          shift and go to state 8
    CTI             shift and go to state 15
    CTF             shift and go to state 16
    ID              shift and go to state 19

    mexp                           shift and go to state 38
    t                              shift and go to state 13
    f                              shift and go to state 14
    var                            shift and go to state 17
    call                           shift and go to state 18

state 25

    (26) gexpp -> LT .

    LPAREN          reduce using rule 26 (gexpp -> LT .)
    CTI             reduce using rule 26 (gexpp -> LT .)
    CTF             reduce using rule 26 (gexpp -> LT .)
    ID              reduce using rule 26 (gexpp -> LT .)


state 26

    (27) gexpp -> GT .

    LPAREN          reduce using rule 27 (gexpp -> GT .)
    CTI             reduce using rule 27 (gexpp -> GT .)
    CTF             reduce using rule 27 (gexpp -> GT .)
    ID              reduce using rule 27 (gexpp -> GT .)


state 27

    (28) gexpp -> IFEQUAL .

    LPAREN          reduce using rule 28 (gexpp -> IFEQUAL .)
    CTI             reduce using rule 28 (gexpp -> IFEQUAL .)
    CTF             reduce using rule 28 (gexpp -> IFEQUAL .)
    ID              reduce using rule 28 (gexpp -> IFEQUAL .)


state 28

    (29) gexpp -> DIFF .

    LPAREN          reduce using rule 29 (gexpp -> DIFF .)
    CTI             reduce using rule 29 (gexpp -> DIFF .)
    CTF             reduce using rule 29 (gexpp -> DIFF .)
    ID              reduce using rule 29 (gexpp -> DIFF .)


state 29

    (31) mexp -> t PLUS . mexp
    (30) mexp -> . t
    (31) mexp -> . t PLUS mexp
    (32) mexp -> . t MINUS mexp
    (33) t -> . f
    (34) t -> . f MULT t
    (35) t -> . f DIV t
    (36) f -> . LPAREN exp RPAREN
    (37) f -> . CTI
    (38) f -> . CTF
    (39) f -> . var
    (40) f -> . call
    (56) var -> . ID
    (57) call -> . ID LPAREN callp RPAREN

    LPAREN          shift and go to state 8
    CTI             shift and go to state 15
    CTF             shift and go to state 16
    ID              shift and go to state 19

    t                              shift and go to state 13
    mexp                           shift and go to state 39
    f                              shift and go to state 14
    var                            shift and go to state 17
    call                           shift and go to state 18

state 30

    (32) mexp -> t MINUS . mexp
    (30) mexp -> . t
    (31) mexp -> . t PLUS mexp
    (32) mexp -> . t MINUS mexp
    (33) t -> . f
    (34) t -> . f MULT t
    (35) t -> . f DIV t
    (36) f -> . LPAREN exp RPAREN
    (37) f -> . CTI
    (38) f -> . CTF
    (39) f -> . var
    (40) f -> . call
    (56) var -> . ID
    (57) call -> . ID LPAREN callp RPAREN

    LPAREN          shift and go to state 8
    CTI             shift and go to state 15
    CTF             shift and go to state 16
    ID              shift and go to state 19

    t                              shift and go to state 13
    mexp                           shift and go to state 40
    f                              shift and go to state 14
    var                            shift and go to state 17
    call                           shift and go to state 18

state 31

    (34) t -> f MULT . t
    (33) t -> . f
    (34) t -> . f MULT t
    (35) t -> . f DIV t
    (36) f -> . LPAREN exp RPAREN
    (37) f -> . CTI
    (38) f -> . CTF
    (39) f -> . var
    (40) f -> . call
    (56) var -> . ID
    (57) call -> . ID LPAREN callp RPAREN

    LPAREN          shift and go to state 8
    CTI             shift and go to state 15
    CTF             shift and go to state 16
    ID              shift and go to state 19

    f                              shift and go to state 14
    t                              shift and go to state 41
    var                            shift and go to state 17
    call                           shift and go to state 18

state 32

    (35) t -> f DIV . t
    (33) t -> . f
    (34) t -> . f MULT t
    (35) t -> . f DIV t
    (36) f -> . LPAREN exp RPAREN
    (37) f -> . CTI
    (38) f -> . CTF
    (39) f -> . var
    (40) f -> . call
    (56) var -> . ID
    (57) call -> . ID LPAREN callp RPAREN

    LPAREN          shift and go to state 8
    CTI             shift and go to state 15
    CTF             shift and go to state 16
    ID              shift and go to state 19

    f                              shift and go to state 14
    t                              shift and go to state 42
    var                            shift and go to state 17
    call                           shift and go to state 18

state 33

    (57) call -> ID LPAREN . callp RPAREN
    (58) callp -> . exp SEMICOLON callp
    (59) callp -> . exp
    (20) exp -> . texp
    (21) exp -> . texp OR exp
    (22) texp -> . gexp
    (23) texp -> . gexp AND texp
    (24) gexp -> . mexp
    (25) gexp -> . mexp gexpp mexp
    (30) mexp -> . t
    (31) mexp -> . t PLUS mexp
    (32) mexp -> . t MINUS mexp
    (33) t -> . f
    (34) t -> . f MULT t
    (35) t -> . f DIV t
    (36) f -> . LPAREN exp RPAREN
    (37) f -> . CTI
    (38) f -> . CTF
    (39) f -> . var
    (40) f -> . call
    (56) var -> . ID
    (57) call -> . ID LPAREN callp RPAREN

    LPAREN          shift and go to state 8
    CTI             shift and go to state 15
    CTF             shift and go to state 16
    ID              shift and go to state 19

    callp                          shift and go to state 43
    exp                            shift and go to state 44
    texp                           shift and go to state 10
    gexp                           shift and go to state 11
    mexp                           shift and go to state 12
    t                              shift and go to state 13
    f                              shift and go to state 14
    var                            shift and go to state 17
    call                           shift and go to state 18

state 34

    (36) f -> LPAREN exp RPAREN .

    MULT            reduce using rule 36 (f -> LPAREN exp RPAREN .)
    DIV             reduce using rule 36 (f -> LPAREN exp RPAREN .)
    PLUS            reduce using rule 36 (f -> LPAREN exp RPAREN .)
    MINUS           reduce using rule 36 (f -> LPAREN exp RPAREN .)
    LT              reduce using rule 36 (f -> LPAREN exp RPAREN .)
    GT              reduce using rule 36 (f -> LPAREN exp RPAREN .)
    IFEQUAL         reduce using rule 36 (f -> LPAREN exp RPAREN .)
    DIFF            reduce using rule 36 (f -> LPAREN exp RPAREN .)
    AND             reduce using rule 36 (f -> LPAREN exp RPAREN .)
    OR              reduce using rule 36 (f -> LPAREN exp RPAREN .)
    RPAREN          reduce using rule 36 (f -> LPAREN exp RPAREN .)
    SEMICOLON       reduce using rule 36 (f -> LPAREN exp RPAREN .)


state 35

    (60) if -> IF LPAREN exp RPAREN quadsIf . ifelse jumpsIf
    (61) ifelse -> .
    (62) ifelse -> . ELSE quadsElse

    $end            reduce using rule 61 (ifelse -> .)
    ELSE            shift and go to state 46

    ifelse                         shift and go to state 45

state 36

    (21) exp -> texp OR exp .

    RPAREN          reduce using rule 21 (exp -> texp OR exp .)
    SEMICOLON       reduce using rule 21 (exp -> texp OR exp .)


state 37

    (23) texp -> gexp AND texp .

    OR              reduce using rule 23 (texp -> gexp AND texp .)
    RPAREN          reduce using rule 23 (texp -> gexp AND texp .)
    SEMICOLON       reduce using rule 23 (texp -> gexp AND texp .)


state 38

    (25) gexp -> mexp gexpp mexp .

    AND             reduce using rule 25 (gexp -> mexp gexpp mexp .)
    OR              reduce using rule 25 (gexp -> mexp gexpp mexp .)
    RPAREN          reduce using rule 25 (gexp -> mexp gexpp mexp .)
    SEMICOLON       reduce using rule 25 (gexp -> mexp gexpp mexp .)


state 39

    (31) mexp -> t PLUS mexp .

    LT              reduce using rule 31 (mexp -> t PLUS mexp .)
    GT              reduce using rule 31 (mexp -> t PLUS mexp .)
    IFEQUAL         reduce using rule 31 (mexp -> t PLUS mexp .)
    DIFF            reduce using rule 31 (mexp -> t PLUS mexp .)
    AND             reduce using rule 31 (mexp -> t PLUS mexp .)
    OR              reduce using rule 31 (mexp -> t PLUS mexp .)
    RPAREN          reduce using rule 31 (mexp -> t PLUS mexp .)
    SEMICOLON       reduce using rule 31 (mexp -> t PLUS mexp .)


state 40

    (32) mexp -> t MINUS mexp .

    LT              reduce using rule 32 (mexp -> t MINUS mexp .)
    GT              reduce using rule 32 (mexp -> t MINUS mexp .)
    IFEQUAL         reduce using rule 32 (mexp -> t MINUS mexp .)
    DIFF            reduce using rule 32 (mexp -> t MINUS mexp .)
    AND             reduce using rule 32 (mexp -> t MINUS mexp .)
    OR              reduce using rule 32 (mexp -> t MINUS mexp .)
    RPAREN          reduce using rule 32 (mexp -> t MINUS mexp .)
    SEMICOLON       reduce using rule 32 (mexp -> t MINUS mexp .)


state 41

    (34) t -> f MULT t .

    PLUS            reduce using rule 34 (t -> f MULT t .)
    MINUS           reduce using rule 34 (t -> f MULT t .)
    LT              reduce using rule 34 (t -> f MULT t .)
    GT              reduce using rule 34 (t -> f MULT t .)
    IFEQUAL         reduce using rule 34 (t -> f MULT t .)
    DIFF            reduce using rule 34 (t -> f MULT t .)
    AND             reduce using rule 34 (t -> f MULT t .)
    OR              reduce using rule 34 (t -> f MULT t .)
    RPAREN          reduce using rule 34 (t -> f MULT t .)
    SEMICOLON       reduce using rule 34 (t -> f MULT t .)


state 42

    (35) t -> f DIV t .

    PLUS            reduce using rule 35 (t -> f DIV t .)
    MINUS           reduce using rule 35 (t -> f DIV t .)
    LT              reduce using rule 35 (t -> f DIV t .)
    GT              reduce using rule 35 (t -> f DIV t .)
    IFEQUAL         reduce using rule 35 (t -> f DIV t .)
    DIFF            reduce using rule 35 (t -> f DIV t .)
    AND             reduce using rule 35 (t -> f DIV t .)
    OR              reduce using rule 35 (t -> f DIV t .)
    RPAREN          reduce using rule 35 (t -> f DIV t .)
    SEMICOLON       reduce using rule 35 (t -> f DIV t .)


state 43

    (57) call -> ID LPAREN callp . RPAREN

    RPAREN          shift and go to state 47


state 44

    (58) callp -> exp . SEMICOLON callp
    (59) callp -> exp .

    SEMICOLON       shift and go to state 48
    RPAREN          reduce using rule 59 (callp -> exp .)


state 45

    (60) if -> IF LPAREN exp RPAREN quadsIf ifelse . jumpsIf
    (64) jumpsIf -> .

    $end            reduce using rule 64 (jumpsIf -> .)

    jumpsIf                        shift and go to state 49

state 46

    (62) ifelse -> ELSE . quadsElse
    (65) quadsElse -> .

    $end            reduce using rule 65 (quadsElse -> .)

    quadsElse                      shift and go to state 50

state 47

    (57) call -> ID LPAREN callp RPAREN .

    MULT            reduce using rule 57 (call -> ID LPAREN callp RPAREN .)
    DIV             reduce using rule 57 (call -> ID LPAREN callp RPAREN .)
    PLUS            reduce using rule 57 (call -> ID LPAREN callp RPAREN .)
    MINUS           reduce using rule 57 (call -> ID LPAREN callp RPAREN .)
    LT              reduce using rule 57 (call -> ID LPAREN callp RPAREN .)
    GT              reduce using rule 57 (call -> ID LPAREN callp RPAREN .)
    IFEQUAL         reduce using rule 57 (call -> ID LPAREN callp RPAREN .)
    DIFF            reduce using rule 57 (call -> ID LPAREN callp RPAREN .)
    AND             reduce using rule 57 (call -> ID LPAREN callp RPAREN .)
    OR              reduce using rule 57 (call -> ID LPAREN callp RPAREN .)
    RPAREN          reduce using rule 57 (call -> ID LPAREN callp RPAREN .)
    SEMICOLON       reduce using rule 57 (call -> ID LPAREN callp RPAREN .)


state 48

    (58) callp -> exp SEMICOLON . callp
    (58) callp -> . exp SEMICOLON callp
    (59) callp -> . exp
    (20) exp -> . texp
    (21) exp -> . texp OR exp
    (22) texp -> . gexp
    (23) texp -> . gexp AND texp
    (24) gexp -> . mexp
    (25) gexp -> . mexp gexpp mexp
    (30) mexp -> . t
    (31) mexp -> . t PLUS mexp
    (32) mexp -> . t MINUS mexp
    (33) t -> . f
    (34) t -> . f MULT t
    (35) t -> . f DIV t
    (36) f -> . LPAREN exp RPAREN
    (37) f -> . CTI
    (38) f -> . CTF
    (39) f -> . var
    (40) f -> . call
    (56) var -> . ID
    (57) call -> . ID LPAREN callp RPAREN

    LPAREN          shift and go to state 8
    CTI             shift and go to state 15
    CTF             shift and go to state 16
    ID              shift and go to state 19

    exp                            shift and go to state 44
    callp                          shift and go to state 51
    texp                           shift and go to state 10
    gexp                           shift and go to state 11
    mexp                           shift and go to state 12
    t                              shift and go to state 13
    f                              shift and go to state 14
    var                            shift and go to state 17
    call                           shift and go to state 18

state 49

    (60) if -> IF LPAREN exp RPAREN quadsIf ifelse jumpsIf .

    $end            reduce using rule 60 (if -> IF LPAREN exp RPAREN quadsIf ifelse jumpsIf .)


state 50

    (62) ifelse -> ELSE quadsElse .

    $end            reduce using rule 62 (ifelse -> ELSE quadsElse .)


state 51

    (58) callp -> exp SEMICOLON callp .

    RPAREN          reduce using rule 58 (callp -> exp SEMICOLON callp .)

