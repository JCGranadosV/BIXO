Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    ASSIGN
    CHAR
    COLON
    END
    FUNCESP
    GTE
    IFEQUAL
    LTE
    NUMPY
    QUOTE
    STRING

Grammar

Rule 0     S' -> program
Rule 1     program -> PROGRAM gotomain ID SEMICOLON decvar modules mainfunction
Rule 2     gotomain -> <empty>
Rule 3     decvar -> VAR decvarp
Rule 4     decvar -> VAR decvarp decvar
Rule 5     decvar -> <empty>
Rule 6     decvarp -> type decvarpp SEMICOLON
Rule 7     decvarpp -> ID COMMA decvarpp
Rule 8     decvarpp -> ID
Rule 9     type -> INT
Rule 10    type -> FLOAT
Rule 11    function -> FUNCTION type decfunc LPAREN param RPAREN LBRACE body RETURN exp SEMICOLON RBRACE
Rule 12    decfunc -> ID
Rule 13    voidfunction -> FUNCTION VOID decfunc LPAREN param RPAREN LBRACE body RBRACE
Rule 14    decfuncmain -> <empty>
Rule 15    mainfunction -> MAIN decfuncmain LPAREN RPAREN LBRACE body RBRACE
Rule 16    modules -> function modules
Rule 17    modules -> voidfunction modules
Rule 18    modules -> function
Rule 19    modules -> voidfunction
Rule 20    body -> decvar statements body
Rule 21    body -> statements body
Rule 22    body -> decvar
Rule 23    body -> <empty>
Rule 24    param -> type ID
Rule 25    param -> type ID COMMA param
Rule 26    param -> <empty>
Rule 27    exp -> texp
Rule 28    exp -> texp OR exp
Rule 29    texp -> gexp
Rule 30    texp -> gexp AND texp
Rule 31    gexp -> mexp
Rule 32    gexp -> mexp gexpp mexp
Rule 33    gexpp -> LT
Rule 34    gexpp -> GT
Rule 35    gexpp -> EQUAL
Rule 36    gexpp -> DIFF
Rule 37    mexp -> t
Rule 38    mexp -> mexp PLUS t
Rule 39    mexp -> mexp MINUS t
Rule 40    t -> f
Rule 41    t -> t MULT f
Rule 42    t -> t DIV f
Rule 43    f -> LPAREN exp RPAREN
Rule 44    f -> CTI
Rule 45    f -> CTF
Rule 46    f -> var
Rule 47    f -> call
Rule 48    statements -> assign
Rule 49    statements -> function
Rule 50    statements -> voidfunction
Rule 51    statements -> call
Rule 52    statements -> read
Rule 53    statements -> print
Rule 54    statements -> if
Rule 55    statements -> while
Rule 56    statements -> for
Rule 57    assign -> var EQUAL exp SEMICOLON
Rule 58    read -> READ LPAREN var RPAREN SEMICOLON
Rule 59    print -> PRINT LPAREN printp SEMICOLON
Rule 60    printp -> exp RPAREN
Rule 61    printp -> exp COMMA printp
Rule 62    var -> ID
Rule 63    call -> ID LPAREN callp RPAREN SEMICOLON
Rule 64    callp -> exp COMMA callp
Rule 65    callp -> exp
Rule 66    callp -> <empty>
Rule 67    if -> IF LPAREN exp RPAREN quadsIf statements ifelse jumpsIf
Rule 68    ifelse -> <empty>
Rule 69    ifelse -> ELSE quadsElse statements
Rule 70    quadsIf -> <empty>
Rule 71    jumpsIf -> <empty>
Rule 72    quadsElse -> <empty>
Rule 73    while -> WHILE LPAREN saveJumps exp RPAREN quadsWhile statements jumpsWhile whilep
Rule 74    whilep -> SEMICOLON
Rule 75    whilep -> statements whilep
Rule 76    saveJumps -> <empty>
Rule 77    quadsWhile -> <empty>
Rule 78    jumpsWhile -> <empty>
Rule 79    for -> FOR LPAREN var SEMICOLON exp SEMICOLON exp RPAREN LBRACKET statements forp
Rule 80    forp -> RBRACKET
Rule 81    forp -> statements forp
Rule 82    funcesp -> array
Rule 83    funcesp -> matrix
Rule 84    funcesp -> mean
Rule 85    funcesp -> layers
Rule 86    funcesp -> sequential
Rule 87    funcesp -> compile
Rule 88    funcesp -> fit
Rule 89    funcesp -> predict
Rule 90    funcesp -> getweights
Rule 91    array -> ID EQUAL ARRAY LPAREN var arrayp
Rule 92    arrayp -> RPAREN
Rule 93    arrayp -> COMMA var RPAREN
Rule 94    matrix -> ID EQUAL MATRIX LPAREN array matrixp
Rule 95    matrixp -> RPAREN
Rule 96    matrixp -> COMMA array RPAREN
Rule 97    mean -> MEAN LPAREN array RPAREN
Rule 98    layers -> ID EQUAL LAYERS LPAREN UNITS EQUAL INT RPAREN
Rule 99    sequential -> ID EQUAL SEQUENTIAL LPAREN LBRACKET layers sequentialp
Rule 100   sequentialp -> RBRACKET RPAREN
Rule 101   sequentialp -> COMMA layers sequentialp
Rule 102   compile -> sequential DOT COMPILE LPAREN RPAREN
Rule 103   fit -> ID EQUAL sequential DOT FIT LPAREN array COMMA array COMMA EPOCHS EQUAL INT COMMA VERBOSE EQUAL fitp
Rule 104   fitp -> TRUE RPAREN
Rule 105   fitp -> FALSE RPAREN
Rule 106   predict -> ID EQUAL sequential DOT PREDICT LPAREN LBRACKET predictp
Rule 107   predictp -> INT RBRACKET RPAREN
Rule 108   predictp -> FLOAT RBRACKET RPAREN
Rule 109   getweights -> layers DOT GETWEIGHTS LPAREN RPAREN
Rule 110   empty -> <empty>

Terminals, with rules where they appear

AND                  : 30
ARRAY                : 91
ASSIGN               : 
CHAR                 : 
COLON                : 
COMMA                : 7 25 61 64 93 96 101 103 103 103
COMPILE              : 102
CTF                  : 45
CTI                  : 44
DIFF                 : 36
DIV                  : 42
DOT                  : 102 103 106 109
ELSE                 : 69
END                  : 
EPOCHS               : 103
EQUAL                : 35 57 91 94 98 98 99 103 103 103 106
FALSE                : 105
FIT                  : 103
FLOAT                : 10 108
FOR                  : 79
FUNCESP              : 
FUNCTION             : 11 13
GETWEIGHTS           : 109
GT                   : 34
GTE                  : 
ID                   : 1 7 8 12 24 25 62 63 91 94 98 99 103 106
IF                   : 67
IFEQUAL              : 
INT                  : 9 98 103 107
LAYERS               : 98
LBRACE               : 11 13 15
LBRACKET             : 79 99 106
LPAREN               : 11 13 15 43 58 59 63 67 73 79 91 94 97 98 99 102 103 106 109
LT                   : 33
LTE                  : 
MAIN                 : 15
MATRIX               : 94
MEAN                 : 97
MINUS                : 39
MULT                 : 41
NUMPY                : 
OR                   : 28
PLUS                 : 38
PREDICT              : 106
PRINT                : 59
PROGRAM              : 1
QUOTE                : 
RBRACE               : 11 13 15
RBRACKET             : 80 100 107 108
READ                 : 58
RETURN               : 11
RPAREN               : 11 13 15 43 58 60 63 67 73 79 92 93 95 96 97 98 100 102 104 105 107 108 109
SEMICOLON            : 1 6 11 57 58 59 63 74 79 79
SEQUENTIAL           : 99
STRING               : 
TRUE                 : 104
UNITS                : 98
VAR                  : 3 4
VERBOSE              : 103
VOID                 : 13
WHILE                : 73
error                : 

Nonterminals, with rules where they appear

array                : 82 94 96 97 103 103
arrayp               : 91
assign               : 48
body                 : 11 13 15 20 21
call                 : 47 51
callp                : 63 64
compile              : 87
decfunc              : 11 13
decfuncmain          : 15
decvar               : 1 4 20 22
decvarp              : 3 4
decvarpp             : 6 7
empty                : 
exp                  : 11 28 43 57 60 61 64 65 67 73 79 79
f                    : 40 41 42
fit                  : 88
fitp                 : 103
for                  : 56
forp                 : 79 81
funcesp              : 
function             : 16 18 49
getweights           : 90
gexp                 : 29 30
gexpp                : 32
gotomain             : 1
if                   : 54
ifelse               : 67
jumpsIf              : 67
jumpsWhile           : 73
layers               : 85 99 101 109
mainfunction         : 1
matrix               : 83
matrixp              : 94
mean                 : 84
mexp                 : 31 32 32 38 39
modules              : 1 16 17
param                : 11 13 25
predict              : 89
predictp             : 106
print                : 53
printp               : 59 61
program              : 0
quadsElse            : 69
quadsIf              : 67
quadsWhile           : 73
read                 : 52
saveJumps            : 73
sequential           : 86 102 103 106
sequentialp          : 99 101
statements           : 20 21 67 69 73 75 79 81
t                    : 37 38 39 41 42
texp                 : 27 28 30
type                 : 6 11 24 25
var                  : 46 57 58 79 91 93
voidfunction         : 17 19 50
while                : 55
whilep               : 73 75

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . PROGRAM gotomain ID SEMICOLON decvar modules mainfunction

    PROGRAM         shift and go to state 2

    program                        shift and go to state 1

state 1

    (0) S' -> program .



state 2

    (1) program -> PROGRAM . gotomain ID SEMICOLON decvar modules mainfunction
    (2) gotomain -> .

    ID              reduce using rule 2 (gotomain -> .)

    gotomain                       shift and go to state 3

state 3

    (1) program -> PROGRAM gotomain . ID SEMICOLON decvar modules mainfunction

    ID              shift and go to state 4


state 4

    (1) program -> PROGRAM gotomain ID . SEMICOLON decvar modules mainfunction

    SEMICOLON       shift and go to state 5


state 5

    (1) program -> PROGRAM gotomain ID SEMICOLON . decvar modules mainfunction
    (3) decvar -> . VAR decvarp
    (4) decvar -> . VAR decvarp decvar
    (5) decvar -> .

    VAR             shift and go to state 7
    FUNCTION        reduce using rule 5 (decvar -> .)

    decvar                         shift and go to state 6

state 6

    (1) program -> PROGRAM gotomain ID SEMICOLON decvar . modules mainfunction
    (16) modules -> . function modules
    (17) modules -> . voidfunction modules
    (18) modules -> . function
    (19) modules -> . voidfunction
    (11) function -> . FUNCTION type decfunc LPAREN param RPAREN LBRACE body RETURN exp SEMICOLON RBRACE
    (13) voidfunction -> . FUNCTION VOID decfunc LPAREN param RPAREN LBRACE body RBRACE

    FUNCTION        shift and go to state 11

    modules                        shift and go to state 8
    function                       shift and go to state 9
    voidfunction                   shift and go to state 10

state 7

    (3) decvar -> VAR . decvarp
    (4) decvar -> VAR . decvarp decvar
    (6) decvarp -> . type decvarpp SEMICOLON
    (9) type -> . INT
    (10) type -> . FLOAT

    INT             shift and go to state 14
    FLOAT           shift and go to state 15

    decvarp                        shift and go to state 12
    type                           shift and go to state 13

state 8

    (1) program -> PROGRAM gotomain ID SEMICOLON decvar modules . mainfunction
    (15) mainfunction -> . MAIN decfuncmain LPAREN RPAREN LBRACE body RBRACE

    MAIN            shift and go to state 17

    mainfunction                   shift and go to state 16

state 9

    (16) modules -> function . modules
    (18) modules -> function .
    (16) modules -> . function modules
    (17) modules -> . voidfunction modules
    (18) modules -> . function
    (19) modules -> . voidfunction
    (11) function -> . FUNCTION type decfunc LPAREN param RPAREN LBRACE body RETURN exp SEMICOLON RBRACE
    (13) voidfunction -> . FUNCTION VOID decfunc LPAREN param RPAREN LBRACE body RBRACE

    MAIN            reduce using rule 18 (modules -> function .)
    FUNCTION        shift and go to state 11

    function                       shift and go to state 9
    modules                        shift and go to state 18
    voidfunction                   shift and go to state 10

state 10

    (17) modules -> voidfunction . modules
    (19) modules -> voidfunction .
    (16) modules -> . function modules
    (17) modules -> . voidfunction modules
    (18) modules -> . function
    (19) modules -> . voidfunction
    (11) function -> . FUNCTION type decfunc LPAREN param RPAREN LBRACE body RETURN exp SEMICOLON RBRACE
    (13) voidfunction -> . FUNCTION VOID decfunc LPAREN param RPAREN LBRACE body RBRACE

    MAIN            reduce using rule 19 (modules -> voidfunction .)
    FUNCTION        shift and go to state 11

    voidfunction                   shift and go to state 10
    modules                        shift and go to state 19
    function                       shift and go to state 9

state 11

    (11) function -> FUNCTION . type decfunc LPAREN param RPAREN LBRACE body RETURN exp SEMICOLON RBRACE
    (13) voidfunction -> FUNCTION . VOID decfunc LPAREN param RPAREN LBRACE body RBRACE
    (9) type -> . INT
    (10) type -> . FLOAT

    VOID            shift and go to state 21
    INT             shift and go to state 14
    FLOAT           shift and go to state 15

    type                           shift and go to state 20

state 12

    (3) decvar -> VAR decvarp .
    (4) decvar -> VAR decvarp . decvar
    (3) decvar -> . VAR decvarp
    (4) decvar -> . VAR decvarp decvar
    (5) decvar -> .

  ! reduce/reduce conflict for FUNCTION resolved using rule 3 (decvar -> VAR decvarp .)
  ! reduce/reduce conflict for ID resolved using rule 3 (decvar -> VAR decvarp .)
  ! reduce/reduce conflict for READ resolved using rule 3 (decvar -> VAR decvarp .)
  ! reduce/reduce conflict for PRINT resolved using rule 3 (decvar -> VAR decvarp .)
  ! reduce/reduce conflict for IF resolved using rule 3 (decvar -> VAR decvarp .)
  ! reduce/reduce conflict for WHILE resolved using rule 3 (decvar -> VAR decvarp .)
  ! reduce/reduce conflict for FOR resolved using rule 3 (decvar -> VAR decvarp .)
  ! reduce/reduce conflict for RBRACE resolved using rule 3 (decvar -> VAR decvarp .)
  ! reduce/reduce conflict for RETURN resolved using rule 3 (decvar -> VAR decvarp .)
    FUNCTION        reduce using rule 3 (decvar -> VAR decvarp .)
    ID              reduce using rule 3 (decvar -> VAR decvarp .)
    READ            reduce using rule 3 (decvar -> VAR decvarp .)
    PRINT           reduce using rule 3 (decvar -> VAR decvarp .)
    IF              reduce using rule 3 (decvar -> VAR decvarp .)
    WHILE           reduce using rule 3 (decvar -> VAR decvarp .)
    FOR             reduce using rule 3 (decvar -> VAR decvarp .)
    RBRACE          reduce using rule 3 (decvar -> VAR decvarp .)
    RETURN          reduce using rule 3 (decvar -> VAR decvarp .)
    VAR             shift and go to state 7

  ! FUNCTION        [ reduce using rule 5 (decvar -> .) ]
  ! ID              [ reduce using rule 5 (decvar -> .) ]
  ! READ            [ reduce using rule 5 (decvar -> .) ]
  ! PRINT           [ reduce using rule 5 (decvar -> .) ]
  ! IF              [ reduce using rule 5 (decvar -> .) ]
  ! WHILE           [ reduce using rule 5 (decvar -> .) ]
  ! FOR             [ reduce using rule 5 (decvar -> .) ]
  ! RBRACE          [ reduce using rule 5 (decvar -> .) ]
  ! RETURN          [ reduce using rule 5 (decvar -> .) ]

    decvar                         shift and go to state 22

state 13

    (6) decvarp -> type . decvarpp SEMICOLON
    (7) decvarpp -> . ID COMMA decvarpp
    (8) decvarpp -> . ID

    ID              shift and go to state 24

    decvarpp                       shift and go to state 23

state 14

    (9) type -> INT .

    ID              reduce using rule 9 (type -> INT .)


state 15

    (10) type -> FLOAT .

    ID              reduce using rule 10 (type -> FLOAT .)


state 16

    (1) program -> PROGRAM gotomain ID SEMICOLON decvar modules mainfunction .

    $end            reduce using rule 1 (program -> PROGRAM gotomain ID SEMICOLON decvar modules mainfunction .)


state 17

    (15) mainfunction -> MAIN . decfuncmain LPAREN RPAREN LBRACE body RBRACE
    (14) decfuncmain -> .

    LPAREN          reduce using rule 14 (decfuncmain -> .)

    decfuncmain                    shift and go to state 25

state 18

    (16) modules -> function modules .

    MAIN            reduce using rule 16 (modules -> function modules .)


state 19

    (17) modules -> voidfunction modules .

    MAIN            reduce using rule 17 (modules -> voidfunction modules .)


state 20

    (11) function -> FUNCTION type . decfunc LPAREN param RPAREN LBRACE body RETURN exp SEMICOLON RBRACE
    (12) decfunc -> . ID

    ID              shift and go to state 27

    decfunc                        shift and go to state 26

state 21

    (13) voidfunction -> FUNCTION VOID . decfunc LPAREN param RPAREN LBRACE body RBRACE
    (12) decfunc -> . ID

    ID              shift and go to state 27

    decfunc                        shift and go to state 28

state 22

    (4) decvar -> VAR decvarp decvar .

    FUNCTION        reduce using rule 4 (decvar -> VAR decvarp decvar .)
    ID              reduce using rule 4 (decvar -> VAR decvarp decvar .)
    READ            reduce using rule 4 (decvar -> VAR decvarp decvar .)
    PRINT           reduce using rule 4 (decvar -> VAR decvarp decvar .)
    IF              reduce using rule 4 (decvar -> VAR decvarp decvar .)
    WHILE           reduce using rule 4 (decvar -> VAR decvarp decvar .)
    FOR             reduce using rule 4 (decvar -> VAR decvarp decvar .)
    RBRACE          reduce using rule 4 (decvar -> VAR decvarp decvar .)
    RETURN          reduce using rule 4 (decvar -> VAR decvarp decvar .)


state 23

    (6) decvarp -> type decvarpp . SEMICOLON

    SEMICOLON       shift and go to state 29


state 24

    (7) decvarpp -> ID . COMMA decvarpp
    (8) decvarpp -> ID .

    COMMA           shift and go to state 30
    SEMICOLON       reduce using rule 8 (decvarpp -> ID .)


state 25

    (15) mainfunction -> MAIN decfuncmain . LPAREN RPAREN LBRACE body RBRACE

    LPAREN          shift and go to state 31


state 26

    (11) function -> FUNCTION type decfunc . LPAREN param RPAREN LBRACE body RETURN exp SEMICOLON RBRACE

    LPAREN          shift and go to state 32


state 27

    (12) decfunc -> ID .

    LPAREN          reduce using rule 12 (decfunc -> ID .)


state 28

    (13) voidfunction -> FUNCTION VOID decfunc . LPAREN param RPAREN LBRACE body RBRACE

    LPAREN          shift and go to state 33


state 29

    (6) decvarp -> type decvarpp SEMICOLON .

    VAR             reduce using rule 6 (decvarp -> type decvarpp SEMICOLON .)
    FUNCTION        reduce using rule 6 (decvarp -> type decvarpp SEMICOLON .)
    ID              reduce using rule 6 (decvarp -> type decvarpp SEMICOLON .)
    READ            reduce using rule 6 (decvarp -> type decvarpp SEMICOLON .)
    PRINT           reduce using rule 6 (decvarp -> type decvarpp SEMICOLON .)
    IF              reduce using rule 6 (decvarp -> type decvarpp SEMICOLON .)
    WHILE           reduce using rule 6 (decvarp -> type decvarpp SEMICOLON .)
    FOR             reduce using rule 6 (decvarp -> type decvarpp SEMICOLON .)
    RBRACE          reduce using rule 6 (decvarp -> type decvarpp SEMICOLON .)
    RETURN          reduce using rule 6 (decvarp -> type decvarpp SEMICOLON .)


state 30

    (7) decvarpp -> ID COMMA . decvarpp
    (7) decvarpp -> . ID COMMA decvarpp
    (8) decvarpp -> . ID

    ID              shift and go to state 24

    decvarpp                       shift and go to state 34

state 31

    (15) mainfunction -> MAIN decfuncmain LPAREN . RPAREN LBRACE body RBRACE

    RPAREN          shift and go to state 35


state 32

    (11) function -> FUNCTION type decfunc LPAREN . param RPAREN LBRACE body RETURN exp SEMICOLON RBRACE
    (24) param -> . type ID
    (25) param -> . type ID COMMA param
    (26) param -> .
    (9) type -> . INT
    (10) type -> . FLOAT

    RPAREN          reduce using rule 26 (param -> .)
    INT             shift and go to state 14
    FLOAT           shift and go to state 15

    type                           shift and go to state 36
    param                          shift and go to state 37

state 33

    (13) voidfunction -> FUNCTION VOID decfunc LPAREN . param RPAREN LBRACE body RBRACE
    (24) param -> . type ID
    (25) param -> . type ID COMMA param
    (26) param -> .
    (9) type -> . INT
    (10) type -> . FLOAT

    RPAREN          reduce using rule 26 (param -> .)
    INT             shift and go to state 14
    FLOAT           shift and go to state 15

    param                          shift and go to state 38
    type                           shift and go to state 36

state 34

    (7) decvarpp -> ID COMMA decvarpp .

    SEMICOLON       reduce using rule 7 (decvarpp -> ID COMMA decvarpp .)


state 35

    (15) mainfunction -> MAIN decfuncmain LPAREN RPAREN . LBRACE body RBRACE

    LBRACE          shift and go to state 39


state 36

    (24) param -> type . ID
    (25) param -> type . ID COMMA param

    ID              shift and go to state 40


state 37

    (11) function -> FUNCTION type decfunc LPAREN param . RPAREN LBRACE body RETURN exp SEMICOLON RBRACE

    RPAREN          shift and go to state 41


state 38

    (13) voidfunction -> FUNCTION VOID decfunc LPAREN param . RPAREN LBRACE body RBRACE

    RPAREN          shift and go to state 42


state 39

    (15) mainfunction -> MAIN decfuncmain LPAREN RPAREN LBRACE . body RBRACE
    (20) body -> . decvar statements body
    (21) body -> . statements body
    (22) body -> . decvar
    (23) body -> .
    (3) decvar -> . VAR decvarp
    (4) decvar -> . VAR decvarp decvar
    (5) decvar -> .
    (48) statements -> . assign
    (49) statements -> . function
    (50) statements -> . voidfunction
    (51) statements -> . call
    (52) statements -> . read
    (53) statements -> . print
    (54) statements -> . if
    (55) statements -> . while
    (56) statements -> . for
    (57) assign -> . var EQUAL exp SEMICOLON
    (11) function -> . FUNCTION type decfunc LPAREN param RPAREN LBRACE body RETURN exp SEMICOLON RBRACE
    (13) voidfunction -> . FUNCTION VOID decfunc LPAREN param RPAREN LBRACE body RBRACE
    (63) call -> . ID LPAREN callp RPAREN SEMICOLON
    (58) read -> . READ LPAREN var RPAREN SEMICOLON
    (59) print -> . PRINT LPAREN printp SEMICOLON
    (67) if -> . IF LPAREN exp RPAREN quadsIf statements ifelse jumpsIf
    (73) while -> . WHILE LPAREN saveJumps exp RPAREN quadsWhile statements jumpsWhile whilep
    (79) for -> . FOR LPAREN var SEMICOLON exp SEMICOLON exp RPAREN LBRACKET statements forp
    (62) var -> . ID

  ! reduce/reduce conflict for RBRACE resolved using rule 5 (decvar -> .)
  ! shift/reduce conflict for FUNCTION resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for READ resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
    VAR             shift and go to state 7
    RBRACE          reduce using rule 5 (decvar -> .)
    FUNCTION        shift and go to state 11
    ID              shift and go to state 56
    READ            shift and go to state 57
    PRINT           shift and go to state 58
    IF              shift and go to state 59
    WHILE           shift and go to state 60
    FOR             shift and go to state 61

  ! RBRACE          [ reduce using rule 23 (body -> .) ]
  ! FUNCTION        [ reduce using rule 5 (decvar -> .) ]
  ! ID              [ reduce using rule 5 (decvar -> .) ]
  ! READ            [ reduce using rule 5 (decvar -> .) ]
  ! PRINT           [ reduce using rule 5 (decvar -> .) ]
  ! IF              [ reduce using rule 5 (decvar -> .) ]
  ! WHILE           [ reduce using rule 5 (decvar -> .) ]
  ! FOR             [ reduce using rule 5 (decvar -> .) ]

    body                           shift and go to state 43
    decvar                         shift and go to state 44
    statements                     shift and go to state 45
    assign                         shift and go to state 46
    function                       shift and go to state 47
    voidfunction                   shift and go to state 48
    call                           shift and go to state 49
    read                           shift and go to state 50
    print                          shift and go to state 51
    if                             shift and go to state 52
    while                          shift and go to state 53
    for                            shift and go to state 54
    var                            shift and go to state 55

state 40

    (24) param -> type ID .
    (25) param -> type ID . COMMA param

    RPAREN          reduce using rule 24 (param -> type ID .)
    COMMA           shift and go to state 62


state 41

    (11) function -> FUNCTION type decfunc LPAREN param RPAREN . LBRACE body RETURN exp SEMICOLON RBRACE

    LBRACE          shift and go to state 63


state 42

    (13) voidfunction -> FUNCTION VOID decfunc LPAREN param RPAREN . LBRACE body RBRACE

    LBRACE          shift and go to state 64


state 43

    (15) mainfunction -> MAIN decfuncmain LPAREN RPAREN LBRACE body . RBRACE

    RBRACE          shift and go to state 65


state 44

    (20) body -> decvar . statements body
    (22) body -> decvar .
    (48) statements -> . assign
    (49) statements -> . function
    (50) statements -> . voidfunction
    (51) statements -> . call
    (52) statements -> . read
    (53) statements -> . print
    (54) statements -> . if
    (55) statements -> . while
    (56) statements -> . for
    (57) assign -> . var EQUAL exp SEMICOLON
    (11) function -> . FUNCTION type decfunc LPAREN param RPAREN LBRACE body RETURN exp SEMICOLON RBRACE
    (13) voidfunction -> . FUNCTION VOID decfunc LPAREN param RPAREN LBRACE body RBRACE
    (63) call -> . ID LPAREN callp RPAREN SEMICOLON
    (58) read -> . READ LPAREN var RPAREN SEMICOLON
    (59) print -> . PRINT LPAREN printp SEMICOLON
    (67) if -> . IF LPAREN exp RPAREN quadsIf statements ifelse jumpsIf
    (73) while -> . WHILE LPAREN saveJumps exp RPAREN quadsWhile statements jumpsWhile whilep
    (79) for -> . FOR LPAREN var SEMICOLON exp SEMICOLON exp RPAREN LBRACKET statements forp
    (62) var -> . ID

    RBRACE          reduce using rule 22 (body -> decvar .)
    RETURN          reduce using rule 22 (body -> decvar .)
    FUNCTION        shift and go to state 11
    ID              shift and go to state 56
    READ            shift and go to state 57
    PRINT           shift and go to state 58
    IF              shift and go to state 59
    WHILE           shift and go to state 60
    FOR             shift and go to state 61

    statements                     shift and go to state 66
    assign                         shift and go to state 46
    function                       shift and go to state 47
    voidfunction                   shift and go to state 48
    call                           shift and go to state 49
    read                           shift and go to state 50
    print                          shift and go to state 51
    if                             shift and go to state 52
    while                          shift and go to state 53
    for                            shift and go to state 54
    var                            shift and go to state 55

state 45

    (21) body -> statements . body
    (20) body -> . decvar statements body
    (21) body -> . statements body
    (22) body -> . decvar
    (23) body -> .
    (3) decvar -> . VAR decvarp
    (4) decvar -> . VAR decvarp decvar
    (5) decvar -> .
    (48) statements -> . assign
    (49) statements -> . function
    (50) statements -> . voidfunction
    (51) statements -> . call
    (52) statements -> . read
    (53) statements -> . print
    (54) statements -> . if
    (55) statements -> . while
    (56) statements -> . for
    (57) assign -> . var EQUAL exp SEMICOLON
    (11) function -> . FUNCTION type decfunc LPAREN param RPAREN LBRACE body RETURN exp SEMICOLON RBRACE
    (13) voidfunction -> . FUNCTION VOID decfunc LPAREN param RPAREN LBRACE body RBRACE
    (63) call -> . ID LPAREN callp RPAREN SEMICOLON
    (58) read -> . READ LPAREN var RPAREN SEMICOLON
    (59) print -> . PRINT LPAREN printp SEMICOLON
    (67) if -> . IF LPAREN exp RPAREN quadsIf statements ifelse jumpsIf
    (73) while -> . WHILE LPAREN saveJumps exp RPAREN quadsWhile statements jumpsWhile whilep
    (79) for -> . FOR LPAREN var SEMICOLON exp SEMICOLON exp RPAREN LBRACKET statements forp
    (62) var -> . ID

  ! reduce/reduce conflict for RBRACE resolved using rule 5 (decvar -> .)
  ! reduce/reduce conflict for RETURN resolved using rule 5 (decvar -> .)
  ! shift/reduce conflict for FUNCTION resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for READ resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
    VAR             shift and go to state 7
    RBRACE          reduce using rule 5 (decvar -> .)
    RETURN          reduce using rule 5 (decvar -> .)
    FUNCTION        shift and go to state 11
    ID              shift and go to state 56
    READ            shift and go to state 57
    PRINT           shift and go to state 58
    IF              shift and go to state 59
    WHILE           shift and go to state 60
    FOR             shift and go to state 61

  ! RBRACE          [ reduce using rule 23 (body -> .) ]
  ! RETURN          [ reduce using rule 23 (body -> .) ]
  ! FUNCTION        [ reduce using rule 5 (decvar -> .) ]
  ! ID              [ reduce using rule 5 (decvar -> .) ]
  ! READ            [ reduce using rule 5 (decvar -> .) ]
  ! PRINT           [ reduce using rule 5 (decvar -> .) ]
  ! IF              [ reduce using rule 5 (decvar -> .) ]
  ! WHILE           [ reduce using rule 5 (decvar -> .) ]
  ! FOR             [ reduce using rule 5 (decvar -> .) ]

    statements                     shift and go to state 45
    body                           shift and go to state 67
    decvar                         shift and go to state 44
    assign                         shift and go to state 46
    function                       shift and go to state 47
    voidfunction                   shift and go to state 48
    call                           shift and go to state 49
    read                           shift and go to state 50
    print                          shift and go to state 51
    if                             shift and go to state 52
    while                          shift and go to state 53
    for                            shift and go to state 54
    var                            shift and go to state 55

state 46

    (48) statements -> assign .

    VAR             reduce using rule 48 (statements -> assign .)
    FUNCTION        reduce using rule 48 (statements -> assign .)
    ID              reduce using rule 48 (statements -> assign .)
    READ            reduce using rule 48 (statements -> assign .)
    PRINT           reduce using rule 48 (statements -> assign .)
    IF              reduce using rule 48 (statements -> assign .)
    WHILE           reduce using rule 48 (statements -> assign .)
    FOR             reduce using rule 48 (statements -> assign .)
    RBRACE          reduce using rule 48 (statements -> assign .)
    RETURN          reduce using rule 48 (statements -> assign .)
    ELSE            reduce using rule 48 (statements -> assign .)
    SEMICOLON       reduce using rule 48 (statements -> assign .)
    RBRACKET        reduce using rule 48 (statements -> assign .)


state 47

    (49) statements -> function .

    VAR             reduce using rule 49 (statements -> function .)
    FUNCTION        reduce using rule 49 (statements -> function .)
    ID              reduce using rule 49 (statements -> function .)
    READ            reduce using rule 49 (statements -> function .)
    PRINT           reduce using rule 49 (statements -> function .)
    IF              reduce using rule 49 (statements -> function .)
    WHILE           reduce using rule 49 (statements -> function .)
    FOR             reduce using rule 49 (statements -> function .)
    RBRACE          reduce using rule 49 (statements -> function .)
    RETURN          reduce using rule 49 (statements -> function .)
    ELSE            reduce using rule 49 (statements -> function .)
    SEMICOLON       reduce using rule 49 (statements -> function .)
    RBRACKET        reduce using rule 49 (statements -> function .)


state 48

    (50) statements -> voidfunction .

    VAR             reduce using rule 50 (statements -> voidfunction .)
    FUNCTION        reduce using rule 50 (statements -> voidfunction .)
    ID              reduce using rule 50 (statements -> voidfunction .)
    READ            reduce using rule 50 (statements -> voidfunction .)
    PRINT           reduce using rule 50 (statements -> voidfunction .)
    IF              reduce using rule 50 (statements -> voidfunction .)
    WHILE           reduce using rule 50 (statements -> voidfunction .)
    FOR             reduce using rule 50 (statements -> voidfunction .)
    RBRACE          reduce using rule 50 (statements -> voidfunction .)
    RETURN          reduce using rule 50 (statements -> voidfunction .)
    ELSE            reduce using rule 50 (statements -> voidfunction .)
    SEMICOLON       reduce using rule 50 (statements -> voidfunction .)
    RBRACKET        reduce using rule 50 (statements -> voidfunction .)


state 49

    (51) statements -> call .

    VAR             reduce using rule 51 (statements -> call .)
    FUNCTION        reduce using rule 51 (statements -> call .)
    ID              reduce using rule 51 (statements -> call .)
    READ            reduce using rule 51 (statements -> call .)
    PRINT           reduce using rule 51 (statements -> call .)
    IF              reduce using rule 51 (statements -> call .)
    WHILE           reduce using rule 51 (statements -> call .)
    FOR             reduce using rule 51 (statements -> call .)
    RBRACE          reduce using rule 51 (statements -> call .)
    RETURN          reduce using rule 51 (statements -> call .)
    ELSE            reduce using rule 51 (statements -> call .)
    SEMICOLON       reduce using rule 51 (statements -> call .)
    RBRACKET        reduce using rule 51 (statements -> call .)


state 50

    (52) statements -> read .

    VAR             reduce using rule 52 (statements -> read .)
    FUNCTION        reduce using rule 52 (statements -> read .)
    ID              reduce using rule 52 (statements -> read .)
    READ            reduce using rule 52 (statements -> read .)
    PRINT           reduce using rule 52 (statements -> read .)
    IF              reduce using rule 52 (statements -> read .)
    WHILE           reduce using rule 52 (statements -> read .)
    FOR             reduce using rule 52 (statements -> read .)
    RBRACE          reduce using rule 52 (statements -> read .)
    RETURN          reduce using rule 52 (statements -> read .)
    ELSE            reduce using rule 52 (statements -> read .)
    SEMICOLON       reduce using rule 52 (statements -> read .)
    RBRACKET        reduce using rule 52 (statements -> read .)


state 51

    (53) statements -> print .

    VAR             reduce using rule 53 (statements -> print .)
    FUNCTION        reduce using rule 53 (statements -> print .)
    ID              reduce using rule 53 (statements -> print .)
    READ            reduce using rule 53 (statements -> print .)
    PRINT           reduce using rule 53 (statements -> print .)
    IF              reduce using rule 53 (statements -> print .)
    WHILE           reduce using rule 53 (statements -> print .)
    FOR             reduce using rule 53 (statements -> print .)
    RBRACE          reduce using rule 53 (statements -> print .)
    RETURN          reduce using rule 53 (statements -> print .)
    ELSE            reduce using rule 53 (statements -> print .)
    SEMICOLON       reduce using rule 53 (statements -> print .)
    RBRACKET        reduce using rule 53 (statements -> print .)


state 52

    (54) statements -> if .

    VAR             reduce using rule 54 (statements -> if .)
    FUNCTION        reduce using rule 54 (statements -> if .)
    ID              reduce using rule 54 (statements -> if .)
    READ            reduce using rule 54 (statements -> if .)
    PRINT           reduce using rule 54 (statements -> if .)
    IF              reduce using rule 54 (statements -> if .)
    WHILE           reduce using rule 54 (statements -> if .)
    FOR             reduce using rule 54 (statements -> if .)
    RBRACE          reduce using rule 54 (statements -> if .)
    RETURN          reduce using rule 54 (statements -> if .)
    ELSE            reduce using rule 54 (statements -> if .)
    SEMICOLON       reduce using rule 54 (statements -> if .)
    RBRACKET        reduce using rule 54 (statements -> if .)


state 53

    (55) statements -> while .

    VAR             reduce using rule 55 (statements -> while .)
    FUNCTION        reduce using rule 55 (statements -> while .)
    ID              reduce using rule 55 (statements -> while .)
    READ            reduce using rule 55 (statements -> while .)
    PRINT           reduce using rule 55 (statements -> while .)
    IF              reduce using rule 55 (statements -> while .)
    WHILE           reduce using rule 55 (statements -> while .)
    FOR             reduce using rule 55 (statements -> while .)
    RBRACE          reduce using rule 55 (statements -> while .)
    RETURN          reduce using rule 55 (statements -> while .)
    ELSE            reduce using rule 55 (statements -> while .)
    SEMICOLON       reduce using rule 55 (statements -> while .)
    RBRACKET        reduce using rule 55 (statements -> while .)


state 54

    (56) statements -> for .

    VAR             reduce using rule 56 (statements -> for .)
    FUNCTION        reduce using rule 56 (statements -> for .)
    ID              reduce using rule 56 (statements -> for .)
    READ            reduce using rule 56 (statements -> for .)
    PRINT           reduce using rule 56 (statements -> for .)
    IF              reduce using rule 56 (statements -> for .)
    WHILE           reduce using rule 56 (statements -> for .)
    FOR             reduce using rule 56 (statements -> for .)
    RBRACE          reduce using rule 56 (statements -> for .)
    RETURN          reduce using rule 56 (statements -> for .)
    ELSE            reduce using rule 56 (statements -> for .)
    SEMICOLON       reduce using rule 56 (statements -> for .)
    RBRACKET        reduce using rule 56 (statements -> for .)


state 55

    (57) assign -> var . EQUAL exp SEMICOLON

    EQUAL           shift and go to state 68


state 56

    (63) call -> ID . LPAREN callp RPAREN SEMICOLON
    (62) var -> ID .

    LPAREN          shift and go to state 69
    EQUAL           reduce using rule 62 (var -> ID .)


state 57

    (58) read -> READ . LPAREN var RPAREN SEMICOLON

    LPAREN          shift and go to state 70


state 58

    (59) print -> PRINT . LPAREN printp SEMICOLON

    LPAREN          shift and go to state 71


state 59

    (67) if -> IF . LPAREN exp RPAREN quadsIf statements ifelse jumpsIf

    LPAREN          shift and go to state 72


state 60

    (73) while -> WHILE . LPAREN saveJumps exp RPAREN quadsWhile statements jumpsWhile whilep

    LPAREN          shift and go to state 73


state 61

    (79) for -> FOR . LPAREN var SEMICOLON exp SEMICOLON exp RPAREN LBRACKET statements forp

    LPAREN          shift and go to state 74


state 62

    (25) param -> type ID COMMA . param
    (24) param -> . type ID
    (25) param -> . type ID COMMA param
    (26) param -> .
    (9) type -> . INT
    (10) type -> . FLOAT

    RPAREN          reduce using rule 26 (param -> .)
    INT             shift and go to state 14
    FLOAT           shift and go to state 15

    type                           shift and go to state 36
    param                          shift and go to state 75

state 63

    (11) function -> FUNCTION type decfunc LPAREN param RPAREN LBRACE . body RETURN exp SEMICOLON RBRACE
    (20) body -> . decvar statements body
    (21) body -> . statements body
    (22) body -> . decvar
    (23) body -> .
    (3) decvar -> . VAR decvarp
    (4) decvar -> . VAR decvarp decvar
    (5) decvar -> .
    (48) statements -> . assign
    (49) statements -> . function
    (50) statements -> . voidfunction
    (51) statements -> . call
    (52) statements -> . read
    (53) statements -> . print
    (54) statements -> . if
    (55) statements -> . while
    (56) statements -> . for
    (57) assign -> . var EQUAL exp SEMICOLON
    (11) function -> . FUNCTION type decfunc LPAREN param RPAREN LBRACE body RETURN exp SEMICOLON RBRACE
    (13) voidfunction -> . FUNCTION VOID decfunc LPAREN param RPAREN LBRACE body RBRACE
    (63) call -> . ID LPAREN callp RPAREN SEMICOLON
    (58) read -> . READ LPAREN var RPAREN SEMICOLON
    (59) print -> . PRINT LPAREN printp SEMICOLON
    (67) if -> . IF LPAREN exp RPAREN quadsIf statements ifelse jumpsIf
    (73) while -> . WHILE LPAREN saveJumps exp RPAREN quadsWhile statements jumpsWhile whilep
    (79) for -> . FOR LPAREN var SEMICOLON exp SEMICOLON exp RPAREN LBRACKET statements forp
    (62) var -> . ID

  ! reduce/reduce conflict for RETURN resolved using rule 5 (decvar -> .)
  ! shift/reduce conflict for FUNCTION resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for READ resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
    VAR             shift and go to state 7
    RETURN          reduce using rule 5 (decvar -> .)
    FUNCTION        shift and go to state 11
    ID              shift and go to state 56
    READ            shift and go to state 57
    PRINT           shift and go to state 58
    IF              shift and go to state 59
    WHILE           shift and go to state 60
    FOR             shift and go to state 61

  ! RETURN          [ reduce using rule 23 (body -> .) ]
  ! FUNCTION        [ reduce using rule 5 (decvar -> .) ]
  ! ID              [ reduce using rule 5 (decvar -> .) ]
  ! READ            [ reduce using rule 5 (decvar -> .) ]
  ! PRINT           [ reduce using rule 5 (decvar -> .) ]
  ! IF              [ reduce using rule 5 (decvar -> .) ]
  ! WHILE           [ reduce using rule 5 (decvar -> .) ]
  ! FOR             [ reduce using rule 5 (decvar -> .) ]

    body                           shift and go to state 76
    decvar                         shift and go to state 44
    statements                     shift and go to state 45
    assign                         shift and go to state 46
    function                       shift and go to state 47
    voidfunction                   shift and go to state 48
    call                           shift and go to state 49
    read                           shift and go to state 50
    print                          shift and go to state 51
    if                             shift and go to state 52
    while                          shift and go to state 53
    for                            shift and go to state 54
    var                            shift and go to state 55

state 64

    (13) voidfunction -> FUNCTION VOID decfunc LPAREN param RPAREN LBRACE . body RBRACE
    (20) body -> . decvar statements body
    (21) body -> . statements body
    (22) body -> . decvar
    (23) body -> .
    (3) decvar -> . VAR decvarp
    (4) decvar -> . VAR decvarp decvar
    (5) decvar -> .
    (48) statements -> . assign
    (49) statements -> . function
    (50) statements -> . voidfunction
    (51) statements -> . call
    (52) statements -> . read
    (53) statements -> . print
    (54) statements -> . if
    (55) statements -> . while
    (56) statements -> . for
    (57) assign -> . var EQUAL exp SEMICOLON
    (11) function -> . FUNCTION type decfunc LPAREN param RPAREN LBRACE body RETURN exp SEMICOLON RBRACE
    (13) voidfunction -> . FUNCTION VOID decfunc LPAREN param RPAREN LBRACE body RBRACE
    (63) call -> . ID LPAREN callp RPAREN SEMICOLON
    (58) read -> . READ LPAREN var RPAREN SEMICOLON
    (59) print -> . PRINT LPAREN printp SEMICOLON
    (67) if -> . IF LPAREN exp RPAREN quadsIf statements ifelse jumpsIf
    (73) while -> . WHILE LPAREN saveJumps exp RPAREN quadsWhile statements jumpsWhile whilep
    (79) for -> . FOR LPAREN var SEMICOLON exp SEMICOLON exp RPAREN LBRACKET statements forp
    (62) var -> . ID

  ! reduce/reduce conflict for RBRACE resolved using rule 5 (decvar -> .)
  ! shift/reduce conflict for FUNCTION resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for READ resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
    VAR             shift and go to state 7
    RBRACE          reduce using rule 5 (decvar -> .)
    FUNCTION        shift and go to state 11
    ID              shift and go to state 56
    READ            shift and go to state 57
    PRINT           shift and go to state 58
    IF              shift and go to state 59
    WHILE           shift and go to state 60
    FOR             shift and go to state 61

  ! RBRACE          [ reduce using rule 23 (body -> .) ]
  ! FUNCTION        [ reduce using rule 5 (decvar -> .) ]
  ! ID              [ reduce using rule 5 (decvar -> .) ]
  ! READ            [ reduce using rule 5 (decvar -> .) ]
  ! PRINT           [ reduce using rule 5 (decvar -> .) ]
  ! IF              [ reduce using rule 5 (decvar -> .) ]
  ! WHILE           [ reduce using rule 5 (decvar -> .) ]
  ! FOR             [ reduce using rule 5 (decvar -> .) ]

    body                           shift and go to state 77
    decvar                         shift and go to state 44
    statements                     shift and go to state 45
    assign                         shift and go to state 46
    function                       shift and go to state 47
    voidfunction                   shift and go to state 48
    call                           shift and go to state 49
    read                           shift and go to state 50
    print                          shift and go to state 51
    if                             shift and go to state 52
    while                          shift and go to state 53
    for                            shift and go to state 54
    var                            shift and go to state 55

state 65

    (15) mainfunction -> MAIN decfuncmain LPAREN RPAREN LBRACE body RBRACE .

    $end            reduce using rule 15 (mainfunction -> MAIN decfuncmain LPAREN RPAREN LBRACE body RBRACE .)


state 66

    (20) body -> decvar statements . body
    (20) body -> . decvar statements body
    (21) body -> . statements body
    (22) body -> . decvar
    (23) body -> .
    (3) decvar -> . VAR decvarp
    (4) decvar -> . VAR decvarp decvar
    (5) decvar -> .
    (48) statements -> . assign
    (49) statements -> . function
    (50) statements -> . voidfunction
    (51) statements -> . call
    (52) statements -> . read
    (53) statements -> . print
    (54) statements -> . if
    (55) statements -> . while
    (56) statements -> . for
    (57) assign -> . var EQUAL exp SEMICOLON
    (11) function -> . FUNCTION type decfunc LPAREN param RPAREN LBRACE body RETURN exp SEMICOLON RBRACE
    (13) voidfunction -> . FUNCTION VOID decfunc LPAREN param RPAREN LBRACE body RBRACE
    (63) call -> . ID LPAREN callp RPAREN SEMICOLON
    (58) read -> . READ LPAREN var RPAREN SEMICOLON
    (59) print -> . PRINT LPAREN printp SEMICOLON
    (67) if -> . IF LPAREN exp RPAREN quadsIf statements ifelse jumpsIf
    (73) while -> . WHILE LPAREN saveJumps exp RPAREN quadsWhile statements jumpsWhile whilep
    (79) for -> . FOR LPAREN var SEMICOLON exp SEMICOLON exp RPAREN LBRACKET statements forp
    (62) var -> . ID

  ! reduce/reduce conflict for RBRACE resolved using rule 5 (decvar -> .)
  ! reduce/reduce conflict for RETURN resolved using rule 5 (decvar -> .)
  ! shift/reduce conflict for FUNCTION resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for READ resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
    VAR             shift and go to state 7
    RBRACE          reduce using rule 5 (decvar -> .)
    RETURN          reduce using rule 5 (decvar -> .)
    FUNCTION        shift and go to state 11
    ID              shift and go to state 56
    READ            shift and go to state 57
    PRINT           shift and go to state 58
    IF              shift and go to state 59
    WHILE           shift and go to state 60
    FOR             shift and go to state 61

  ! RBRACE          [ reduce using rule 23 (body -> .) ]
  ! RETURN          [ reduce using rule 23 (body -> .) ]
  ! FUNCTION        [ reduce using rule 5 (decvar -> .) ]
  ! ID              [ reduce using rule 5 (decvar -> .) ]
  ! READ            [ reduce using rule 5 (decvar -> .) ]
  ! PRINT           [ reduce using rule 5 (decvar -> .) ]
  ! IF              [ reduce using rule 5 (decvar -> .) ]
  ! WHILE           [ reduce using rule 5 (decvar -> .) ]
  ! FOR             [ reduce using rule 5 (decvar -> .) ]

    decvar                         shift and go to state 44
    statements                     shift and go to state 45
    body                           shift and go to state 78
    assign                         shift and go to state 46
    function                       shift and go to state 47
    voidfunction                   shift and go to state 48
    call                           shift and go to state 49
    read                           shift and go to state 50
    print                          shift and go to state 51
    if                             shift and go to state 52
    while                          shift and go to state 53
    for                            shift and go to state 54
    var                            shift and go to state 55

state 67

    (21) body -> statements body .

    RBRACE          reduce using rule 21 (body -> statements body .)
    RETURN          reduce using rule 21 (body -> statements body .)


state 68

    (57) assign -> var EQUAL . exp SEMICOLON
    (27) exp -> . texp
    (28) exp -> . texp OR exp
    (29) texp -> . gexp
    (30) texp -> . gexp AND texp
    (31) gexp -> . mexp
    (32) gexp -> . mexp gexpp mexp
    (37) mexp -> . t
    (38) mexp -> . mexp PLUS t
    (39) mexp -> . mexp MINUS t
    (40) t -> . f
    (41) t -> . t MULT f
    (42) t -> . t DIV f
    (43) f -> . LPAREN exp RPAREN
    (44) f -> . CTI
    (45) f -> . CTF
    (46) f -> . var
    (47) f -> . call
    (62) var -> . ID
    (63) call -> . ID LPAREN callp RPAREN SEMICOLON

    LPAREN          shift and go to state 86
    CTI             shift and go to state 87
    CTF             shift and go to state 88
    ID              shift and go to state 90

    var                            shift and go to state 79
    exp                            shift and go to state 80
    texp                           shift and go to state 81
    gexp                           shift and go to state 82
    mexp                           shift and go to state 83
    t                              shift and go to state 84
    f                              shift and go to state 85
    call                           shift and go to state 89

state 69

    (63) call -> ID LPAREN . callp RPAREN SEMICOLON
    (64) callp -> . exp COMMA callp
    (65) callp -> . exp
    (66) callp -> .
    (27) exp -> . texp
    (28) exp -> . texp OR exp
    (29) texp -> . gexp
    (30) texp -> . gexp AND texp
    (31) gexp -> . mexp
    (32) gexp -> . mexp gexpp mexp
    (37) mexp -> . t
    (38) mexp -> . mexp PLUS t
    (39) mexp -> . mexp MINUS t
    (40) t -> . f
    (41) t -> . t MULT f
    (42) t -> . t DIV f
    (43) f -> . LPAREN exp RPAREN
    (44) f -> . CTI
    (45) f -> . CTF
    (46) f -> . var
    (47) f -> . call
    (62) var -> . ID
    (63) call -> . ID LPAREN callp RPAREN SEMICOLON

    RPAREN          reduce using rule 66 (callp -> .)
    LPAREN          shift and go to state 86
    CTI             shift and go to state 87
    CTF             shift and go to state 88
    ID              shift and go to state 90

    callp                          shift and go to state 91
    exp                            shift and go to state 92
    texp                           shift and go to state 81
    gexp                           shift and go to state 82
    mexp                           shift and go to state 83
    t                              shift and go to state 84
    f                              shift and go to state 85
    var                            shift and go to state 79
    call                           shift and go to state 89

state 70

    (58) read -> READ LPAREN . var RPAREN SEMICOLON
    (62) var -> . ID

    ID              shift and go to state 94

    var                            shift and go to state 93

state 71

    (59) print -> PRINT LPAREN . printp SEMICOLON
    (60) printp -> . exp RPAREN
    (61) printp -> . exp COMMA printp
    (27) exp -> . texp
    (28) exp -> . texp OR exp
    (29) texp -> . gexp
    (30) texp -> . gexp AND texp
    (31) gexp -> . mexp
    (32) gexp -> . mexp gexpp mexp
    (37) mexp -> . t
    (38) mexp -> . mexp PLUS t
    (39) mexp -> . mexp MINUS t
    (40) t -> . f
    (41) t -> . t MULT f
    (42) t -> . t DIV f
    (43) f -> . LPAREN exp RPAREN
    (44) f -> . CTI
    (45) f -> . CTF
    (46) f -> . var
    (47) f -> . call
    (62) var -> . ID
    (63) call -> . ID LPAREN callp RPAREN SEMICOLON

    LPAREN          shift and go to state 86
    CTI             shift and go to state 87
    CTF             shift and go to state 88
    ID              shift and go to state 90

    printp                         shift and go to state 95
    exp                            shift and go to state 96
    texp                           shift and go to state 81
    gexp                           shift and go to state 82
    mexp                           shift and go to state 83
    t                              shift and go to state 84
    f                              shift and go to state 85
    var                            shift and go to state 79
    call                           shift and go to state 89

state 72

    (67) if -> IF LPAREN . exp RPAREN quadsIf statements ifelse jumpsIf
    (27) exp -> . texp
    (28) exp -> . texp OR exp
    (29) texp -> . gexp
    (30) texp -> . gexp AND texp
    (31) gexp -> . mexp
    (32) gexp -> . mexp gexpp mexp
    (37) mexp -> . t
    (38) mexp -> . mexp PLUS t
    (39) mexp -> . mexp MINUS t
    (40) t -> . f
    (41) t -> . t MULT f
    (42) t -> . t DIV f
    (43) f -> . LPAREN exp RPAREN
    (44) f -> . CTI
    (45) f -> . CTF
    (46) f -> . var
    (47) f -> . call
    (62) var -> . ID
    (63) call -> . ID LPAREN callp RPAREN SEMICOLON

    LPAREN          shift and go to state 86
    CTI             shift and go to state 87
    CTF             shift and go to state 88
    ID              shift and go to state 90

    exp                            shift and go to state 97
    texp                           shift and go to state 81
    gexp                           shift and go to state 82
    mexp                           shift and go to state 83
    t                              shift and go to state 84
    f                              shift and go to state 85
    var                            shift and go to state 79
    call                           shift and go to state 89

state 73

    (73) while -> WHILE LPAREN . saveJumps exp RPAREN quadsWhile statements jumpsWhile whilep
    (76) saveJumps -> .

    LPAREN          reduce using rule 76 (saveJumps -> .)
    CTI             reduce using rule 76 (saveJumps -> .)
    CTF             reduce using rule 76 (saveJumps -> .)
    ID              reduce using rule 76 (saveJumps -> .)

    saveJumps                      shift and go to state 98

state 74

    (79) for -> FOR LPAREN . var SEMICOLON exp SEMICOLON exp RPAREN LBRACKET statements forp
    (62) var -> . ID

    ID              shift and go to state 94

    var                            shift and go to state 99

state 75

    (25) param -> type ID COMMA param .

    RPAREN          reduce using rule 25 (param -> type ID COMMA param .)


state 76

    (11) function -> FUNCTION type decfunc LPAREN param RPAREN LBRACE body . RETURN exp SEMICOLON RBRACE

    RETURN          shift and go to state 100


state 77

    (13) voidfunction -> FUNCTION VOID decfunc LPAREN param RPAREN LBRACE body . RBRACE

    RBRACE          shift and go to state 101


state 78

    (20) body -> decvar statements body .

    RBRACE          reduce using rule 20 (body -> decvar statements body .)
    RETURN          reduce using rule 20 (body -> decvar statements body .)


state 79

    (46) f -> var .

    MULT            reduce using rule 46 (f -> var .)
    DIV             reduce using rule 46 (f -> var .)
    PLUS            reduce using rule 46 (f -> var .)
    MINUS           reduce using rule 46 (f -> var .)
    LT              reduce using rule 46 (f -> var .)
    GT              reduce using rule 46 (f -> var .)
    EQUAL           reduce using rule 46 (f -> var .)
    DIFF            reduce using rule 46 (f -> var .)
    AND             reduce using rule 46 (f -> var .)
    OR              reduce using rule 46 (f -> var .)
    SEMICOLON       reduce using rule 46 (f -> var .)
    COMMA           reduce using rule 46 (f -> var .)
    RPAREN          reduce using rule 46 (f -> var .)


state 80

    (57) assign -> var EQUAL exp . SEMICOLON

    SEMICOLON       shift and go to state 102


state 81

    (27) exp -> texp .
    (28) exp -> texp . OR exp

    SEMICOLON       reduce using rule 27 (exp -> texp .)
    COMMA           reduce using rule 27 (exp -> texp .)
    RPAREN          reduce using rule 27 (exp -> texp .)
    OR              shift and go to state 103


state 82

    (29) texp -> gexp .
    (30) texp -> gexp . AND texp

    OR              reduce using rule 29 (texp -> gexp .)
    SEMICOLON       reduce using rule 29 (texp -> gexp .)
    COMMA           reduce using rule 29 (texp -> gexp .)
    RPAREN          reduce using rule 29 (texp -> gexp .)
    AND             shift and go to state 104


state 83

    (31) gexp -> mexp .
    (32) gexp -> mexp . gexpp mexp
    (38) mexp -> mexp . PLUS t
    (39) mexp -> mexp . MINUS t
    (33) gexpp -> . LT
    (34) gexpp -> . GT
    (35) gexpp -> . EQUAL
    (36) gexpp -> . DIFF

    AND             reduce using rule 31 (gexp -> mexp .)
    OR              reduce using rule 31 (gexp -> mexp .)
    SEMICOLON       reduce using rule 31 (gexp -> mexp .)
    COMMA           reduce using rule 31 (gexp -> mexp .)
    RPAREN          reduce using rule 31 (gexp -> mexp .)
    PLUS            shift and go to state 106
    MINUS           shift and go to state 107
    LT              shift and go to state 108
    GT              shift and go to state 109
    EQUAL           shift and go to state 110
    DIFF            shift and go to state 111

    gexpp                          shift and go to state 105

state 84

    (37) mexp -> t .
    (41) t -> t . MULT f
    (42) t -> t . DIV f

    PLUS            reduce using rule 37 (mexp -> t .)
    MINUS           reduce using rule 37 (mexp -> t .)
    LT              reduce using rule 37 (mexp -> t .)
    GT              reduce using rule 37 (mexp -> t .)
    EQUAL           reduce using rule 37 (mexp -> t .)
    DIFF            reduce using rule 37 (mexp -> t .)
    AND             reduce using rule 37 (mexp -> t .)
    OR              reduce using rule 37 (mexp -> t .)
    SEMICOLON       reduce using rule 37 (mexp -> t .)
    COMMA           reduce using rule 37 (mexp -> t .)
    RPAREN          reduce using rule 37 (mexp -> t .)
    MULT            shift and go to state 112
    DIV             shift and go to state 113


state 85

    (40) t -> f .

    MULT            reduce using rule 40 (t -> f .)
    DIV             reduce using rule 40 (t -> f .)
    PLUS            reduce using rule 40 (t -> f .)
    MINUS           reduce using rule 40 (t -> f .)
    LT              reduce using rule 40 (t -> f .)
    GT              reduce using rule 40 (t -> f .)
    EQUAL           reduce using rule 40 (t -> f .)
    DIFF            reduce using rule 40 (t -> f .)
    AND             reduce using rule 40 (t -> f .)
    OR              reduce using rule 40 (t -> f .)
    SEMICOLON       reduce using rule 40 (t -> f .)
    COMMA           reduce using rule 40 (t -> f .)
    RPAREN          reduce using rule 40 (t -> f .)


state 86

    (43) f -> LPAREN . exp RPAREN
    (27) exp -> . texp
    (28) exp -> . texp OR exp
    (29) texp -> . gexp
    (30) texp -> . gexp AND texp
    (31) gexp -> . mexp
    (32) gexp -> . mexp gexpp mexp
    (37) mexp -> . t
    (38) mexp -> . mexp PLUS t
    (39) mexp -> . mexp MINUS t
    (40) t -> . f
    (41) t -> . t MULT f
    (42) t -> . t DIV f
    (43) f -> . LPAREN exp RPAREN
    (44) f -> . CTI
    (45) f -> . CTF
    (46) f -> . var
    (47) f -> . call
    (62) var -> . ID
    (63) call -> . ID LPAREN callp RPAREN SEMICOLON

    LPAREN          shift and go to state 86
    CTI             shift and go to state 87
    CTF             shift and go to state 88
    ID              shift and go to state 90

    exp                            shift and go to state 114
    texp                           shift and go to state 81
    gexp                           shift and go to state 82
    mexp                           shift and go to state 83
    t                              shift and go to state 84
    f                              shift and go to state 85
    var                            shift and go to state 79
    call                           shift and go to state 89

state 87

    (44) f -> CTI .

    MULT            reduce using rule 44 (f -> CTI .)
    DIV             reduce using rule 44 (f -> CTI .)
    PLUS            reduce using rule 44 (f -> CTI .)
    MINUS           reduce using rule 44 (f -> CTI .)
    LT              reduce using rule 44 (f -> CTI .)
    GT              reduce using rule 44 (f -> CTI .)
    EQUAL           reduce using rule 44 (f -> CTI .)
    DIFF            reduce using rule 44 (f -> CTI .)
    AND             reduce using rule 44 (f -> CTI .)
    OR              reduce using rule 44 (f -> CTI .)
    SEMICOLON       reduce using rule 44 (f -> CTI .)
    COMMA           reduce using rule 44 (f -> CTI .)
    RPAREN          reduce using rule 44 (f -> CTI .)


state 88

    (45) f -> CTF .

    MULT            reduce using rule 45 (f -> CTF .)
    DIV             reduce using rule 45 (f -> CTF .)
    PLUS            reduce using rule 45 (f -> CTF .)
    MINUS           reduce using rule 45 (f -> CTF .)
    LT              reduce using rule 45 (f -> CTF .)
    GT              reduce using rule 45 (f -> CTF .)
    EQUAL           reduce using rule 45 (f -> CTF .)
    DIFF            reduce using rule 45 (f -> CTF .)
    AND             reduce using rule 45 (f -> CTF .)
    OR              reduce using rule 45 (f -> CTF .)
    SEMICOLON       reduce using rule 45 (f -> CTF .)
    COMMA           reduce using rule 45 (f -> CTF .)
    RPAREN          reduce using rule 45 (f -> CTF .)


state 89

    (47) f -> call .

    MULT            reduce using rule 47 (f -> call .)
    DIV             reduce using rule 47 (f -> call .)
    PLUS            reduce using rule 47 (f -> call .)
    MINUS           reduce using rule 47 (f -> call .)
    LT              reduce using rule 47 (f -> call .)
    GT              reduce using rule 47 (f -> call .)
    EQUAL           reduce using rule 47 (f -> call .)
    DIFF            reduce using rule 47 (f -> call .)
    AND             reduce using rule 47 (f -> call .)
    OR              reduce using rule 47 (f -> call .)
    SEMICOLON       reduce using rule 47 (f -> call .)
    COMMA           reduce using rule 47 (f -> call .)
    RPAREN          reduce using rule 47 (f -> call .)


state 90

    (62) var -> ID .
    (63) call -> ID . LPAREN callp RPAREN SEMICOLON

    MULT            reduce using rule 62 (var -> ID .)
    DIV             reduce using rule 62 (var -> ID .)
    PLUS            reduce using rule 62 (var -> ID .)
    MINUS           reduce using rule 62 (var -> ID .)
    LT              reduce using rule 62 (var -> ID .)
    GT              reduce using rule 62 (var -> ID .)
    EQUAL           reduce using rule 62 (var -> ID .)
    DIFF            reduce using rule 62 (var -> ID .)
    AND             reduce using rule 62 (var -> ID .)
    OR              reduce using rule 62 (var -> ID .)
    SEMICOLON       reduce using rule 62 (var -> ID .)
    COMMA           reduce using rule 62 (var -> ID .)
    RPAREN          reduce using rule 62 (var -> ID .)
    LPAREN          shift and go to state 69


state 91

    (63) call -> ID LPAREN callp . RPAREN SEMICOLON

    RPAREN          shift and go to state 115


state 92

    (64) callp -> exp . COMMA callp
    (65) callp -> exp .

    COMMA           shift and go to state 116
    RPAREN          reduce using rule 65 (callp -> exp .)


state 93

    (58) read -> READ LPAREN var . RPAREN SEMICOLON

    RPAREN          shift and go to state 117


state 94

    (62) var -> ID .

    RPAREN          reduce using rule 62 (var -> ID .)
    SEMICOLON       reduce using rule 62 (var -> ID .)


state 95

    (59) print -> PRINT LPAREN printp . SEMICOLON

    SEMICOLON       shift and go to state 118


state 96

    (60) printp -> exp . RPAREN
    (61) printp -> exp . COMMA printp

    RPAREN          shift and go to state 119
    COMMA           shift and go to state 120


state 97

    (67) if -> IF LPAREN exp . RPAREN quadsIf statements ifelse jumpsIf

    RPAREN          shift and go to state 121


state 98

    (73) while -> WHILE LPAREN saveJumps . exp RPAREN quadsWhile statements jumpsWhile whilep
    (27) exp -> . texp
    (28) exp -> . texp OR exp
    (29) texp -> . gexp
    (30) texp -> . gexp AND texp
    (31) gexp -> . mexp
    (32) gexp -> . mexp gexpp mexp
    (37) mexp -> . t
    (38) mexp -> . mexp PLUS t
    (39) mexp -> . mexp MINUS t
    (40) t -> . f
    (41) t -> . t MULT f
    (42) t -> . t DIV f
    (43) f -> . LPAREN exp RPAREN
    (44) f -> . CTI
    (45) f -> . CTF
    (46) f -> . var
    (47) f -> . call
    (62) var -> . ID
    (63) call -> . ID LPAREN callp RPAREN SEMICOLON

    LPAREN          shift and go to state 86
    CTI             shift and go to state 87
    CTF             shift and go to state 88
    ID              shift and go to state 90

    exp                            shift and go to state 122
    texp                           shift and go to state 81
    gexp                           shift and go to state 82
    mexp                           shift and go to state 83
    t                              shift and go to state 84
    f                              shift and go to state 85
    var                            shift and go to state 79
    call                           shift and go to state 89

state 99

    (79) for -> FOR LPAREN var . SEMICOLON exp SEMICOLON exp RPAREN LBRACKET statements forp

    SEMICOLON       shift and go to state 123


state 100

    (11) function -> FUNCTION type decfunc LPAREN param RPAREN LBRACE body RETURN . exp SEMICOLON RBRACE
    (27) exp -> . texp
    (28) exp -> . texp OR exp
    (29) texp -> . gexp
    (30) texp -> . gexp AND texp
    (31) gexp -> . mexp
    (32) gexp -> . mexp gexpp mexp
    (37) mexp -> . t
    (38) mexp -> . mexp PLUS t
    (39) mexp -> . mexp MINUS t
    (40) t -> . f
    (41) t -> . t MULT f
    (42) t -> . t DIV f
    (43) f -> . LPAREN exp RPAREN
    (44) f -> . CTI
    (45) f -> . CTF
    (46) f -> . var
    (47) f -> . call
    (62) var -> . ID
    (63) call -> . ID LPAREN callp RPAREN SEMICOLON

    LPAREN          shift and go to state 86
    CTI             shift and go to state 87
    CTF             shift and go to state 88
    ID              shift and go to state 90

    exp                            shift and go to state 124
    texp                           shift and go to state 81
    gexp                           shift and go to state 82
    mexp                           shift and go to state 83
    t                              shift and go to state 84
    f                              shift and go to state 85
    var                            shift and go to state 79
    call                           shift and go to state 89

state 101

    (13) voidfunction -> FUNCTION VOID decfunc LPAREN param RPAREN LBRACE body RBRACE .

    FUNCTION        reduce using rule 13 (voidfunction -> FUNCTION VOID decfunc LPAREN param RPAREN LBRACE body RBRACE .)
    MAIN            reduce using rule 13 (voidfunction -> FUNCTION VOID decfunc LPAREN param RPAREN LBRACE body RBRACE .)
    VAR             reduce using rule 13 (voidfunction -> FUNCTION VOID decfunc LPAREN param RPAREN LBRACE body RBRACE .)
    ID              reduce using rule 13 (voidfunction -> FUNCTION VOID decfunc LPAREN param RPAREN LBRACE body RBRACE .)
    READ            reduce using rule 13 (voidfunction -> FUNCTION VOID decfunc LPAREN param RPAREN LBRACE body RBRACE .)
    PRINT           reduce using rule 13 (voidfunction -> FUNCTION VOID decfunc LPAREN param RPAREN LBRACE body RBRACE .)
    IF              reduce using rule 13 (voidfunction -> FUNCTION VOID decfunc LPAREN param RPAREN LBRACE body RBRACE .)
    WHILE           reduce using rule 13 (voidfunction -> FUNCTION VOID decfunc LPAREN param RPAREN LBRACE body RBRACE .)
    FOR             reduce using rule 13 (voidfunction -> FUNCTION VOID decfunc LPAREN param RPAREN LBRACE body RBRACE .)
    RBRACE          reduce using rule 13 (voidfunction -> FUNCTION VOID decfunc LPAREN param RPAREN LBRACE body RBRACE .)
    RETURN          reduce using rule 13 (voidfunction -> FUNCTION VOID decfunc LPAREN param RPAREN LBRACE body RBRACE .)
    ELSE            reduce using rule 13 (voidfunction -> FUNCTION VOID decfunc LPAREN param RPAREN LBRACE body RBRACE .)
    SEMICOLON       reduce using rule 13 (voidfunction -> FUNCTION VOID decfunc LPAREN param RPAREN LBRACE body RBRACE .)
    RBRACKET        reduce using rule 13 (voidfunction -> FUNCTION VOID decfunc LPAREN param RPAREN LBRACE body RBRACE .)


state 102

    (57) assign -> var EQUAL exp SEMICOLON .

    VAR             reduce using rule 57 (assign -> var EQUAL exp SEMICOLON .)
    FUNCTION        reduce using rule 57 (assign -> var EQUAL exp SEMICOLON .)
    ID              reduce using rule 57 (assign -> var EQUAL exp SEMICOLON .)
    READ            reduce using rule 57 (assign -> var EQUAL exp SEMICOLON .)
    PRINT           reduce using rule 57 (assign -> var EQUAL exp SEMICOLON .)
    IF              reduce using rule 57 (assign -> var EQUAL exp SEMICOLON .)
    WHILE           reduce using rule 57 (assign -> var EQUAL exp SEMICOLON .)
    FOR             reduce using rule 57 (assign -> var EQUAL exp SEMICOLON .)
    RBRACE          reduce using rule 57 (assign -> var EQUAL exp SEMICOLON .)
    RETURN          reduce using rule 57 (assign -> var EQUAL exp SEMICOLON .)
    ELSE            reduce using rule 57 (assign -> var EQUAL exp SEMICOLON .)
    SEMICOLON       reduce using rule 57 (assign -> var EQUAL exp SEMICOLON .)
    RBRACKET        reduce using rule 57 (assign -> var EQUAL exp SEMICOLON .)


state 103

    (28) exp -> texp OR . exp
    (27) exp -> . texp
    (28) exp -> . texp OR exp
    (29) texp -> . gexp
    (30) texp -> . gexp AND texp
    (31) gexp -> . mexp
    (32) gexp -> . mexp gexpp mexp
    (37) mexp -> . t
    (38) mexp -> . mexp PLUS t
    (39) mexp -> . mexp MINUS t
    (40) t -> . f
    (41) t -> . t MULT f
    (42) t -> . t DIV f
    (43) f -> . LPAREN exp RPAREN
    (44) f -> . CTI
    (45) f -> . CTF
    (46) f -> . var
    (47) f -> . call
    (62) var -> . ID
    (63) call -> . ID LPAREN callp RPAREN SEMICOLON

    LPAREN          shift and go to state 86
    CTI             shift and go to state 87
    CTF             shift and go to state 88
    ID              shift and go to state 90

    texp                           shift and go to state 81
    exp                            shift and go to state 125
    gexp                           shift and go to state 82
    mexp                           shift and go to state 83
    t                              shift and go to state 84
    f                              shift and go to state 85
    var                            shift and go to state 79
    call                           shift and go to state 89

state 104

    (30) texp -> gexp AND . texp
    (29) texp -> . gexp
    (30) texp -> . gexp AND texp
    (31) gexp -> . mexp
    (32) gexp -> . mexp gexpp mexp
    (37) mexp -> . t
    (38) mexp -> . mexp PLUS t
    (39) mexp -> . mexp MINUS t
    (40) t -> . f
    (41) t -> . t MULT f
    (42) t -> . t DIV f
    (43) f -> . LPAREN exp RPAREN
    (44) f -> . CTI
    (45) f -> . CTF
    (46) f -> . var
    (47) f -> . call
    (62) var -> . ID
    (63) call -> . ID LPAREN callp RPAREN SEMICOLON

    LPAREN          shift and go to state 86
    CTI             shift and go to state 87
    CTF             shift and go to state 88
    ID              shift and go to state 90

    gexp                           shift and go to state 82
    texp                           shift and go to state 126
    mexp                           shift and go to state 83
    t                              shift and go to state 84
    f                              shift and go to state 85
    var                            shift and go to state 79
    call                           shift and go to state 89

state 105

    (32) gexp -> mexp gexpp . mexp
    (37) mexp -> . t
    (38) mexp -> . mexp PLUS t
    (39) mexp -> . mexp MINUS t
    (40) t -> . f
    (41) t -> . t MULT f
    (42) t -> . t DIV f
    (43) f -> . LPAREN exp RPAREN
    (44) f -> . CTI
    (45) f -> . CTF
    (46) f -> . var
    (47) f -> . call
    (62) var -> . ID
    (63) call -> . ID LPAREN callp RPAREN SEMICOLON

    LPAREN          shift and go to state 86
    CTI             shift and go to state 87
    CTF             shift and go to state 88
    ID              shift and go to state 90

    mexp                           shift and go to state 127
    t                              shift and go to state 84
    f                              shift and go to state 85
    var                            shift and go to state 79
    call                           shift and go to state 89

state 106

    (38) mexp -> mexp PLUS . t
    (40) t -> . f
    (41) t -> . t MULT f
    (42) t -> . t DIV f
    (43) f -> . LPAREN exp RPAREN
    (44) f -> . CTI
    (45) f -> . CTF
    (46) f -> . var
    (47) f -> . call
    (62) var -> . ID
    (63) call -> . ID LPAREN callp RPAREN SEMICOLON

    LPAREN          shift and go to state 86
    CTI             shift and go to state 87
    CTF             shift and go to state 88
    ID              shift and go to state 90

    t                              shift and go to state 128
    f                              shift and go to state 85
    var                            shift and go to state 79
    call                           shift and go to state 89

state 107

    (39) mexp -> mexp MINUS . t
    (40) t -> . f
    (41) t -> . t MULT f
    (42) t -> . t DIV f
    (43) f -> . LPAREN exp RPAREN
    (44) f -> . CTI
    (45) f -> . CTF
    (46) f -> . var
    (47) f -> . call
    (62) var -> . ID
    (63) call -> . ID LPAREN callp RPAREN SEMICOLON

    LPAREN          shift and go to state 86
    CTI             shift and go to state 87
    CTF             shift and go to state 88
    ID              shift and go to state 90

    t                              shift and go to state 129
    f                              shift and go to state 85
    var                            shift and go to state 79
    call                           shift and go to state 89

state 108

    (33) gexpp -> LT .

    LPAREN          reduce using rule 33 (gexpp -> LT .)
    CTI             reduce using rule 33 (gexpp -> LT .)
    CTF             reduce using rule 33 (gexpp -> LT .)
    ID              reduce using rule 33 (gexpp -> LT .)


state 109

    (34) gexpp -> GT .

    LPAREN          reduce using rule 34 (gexpp -> GT .)
    CTI             reduce using rule 34 (gexpp -> GT .)
    CTF             reduce using rule 34 (gexpp -> GT .)
    ID              reduce using rule 34 (gexpp -> GT .)


state 110

    (35) gexpp -> EQUAL .

    LPAREN          reduce using rule 35 (gexpp -> EQUAL .)
    CTI             reduce using rule 35 (gexpp -> EQUAL .)
    CTF             reduce using rule 35 (gexpp -> EQUAL .)
    ID              reduce using rule 35 (gexpp -> EQUAL .)


state 111

    (36) gexpp -> DIFF .

    LPAREN          reduce using rule 36 (gexpp -> DIFF .)
    CTI             reduce using rule 36 (gexpp -> DIFF .)
    CTF             reduce using rule 36 (gexpp -> DIFF .)
    ID              reduce using rule 36 (gexpp -> DIFF .)


state 112

    (41) t -> t MULT . f
    (43) f -> . LPAREN exp RPAREN
    (44) f -> . CTI
    (45) f -> . CTF
    (46) f -> . var
    (47) f -> . call
    (62) var -> . ID
    (63) call -> . ID LPAREN callp RPAREN SEMICOLON

    LPAREN          shift and go to state 86
    CTI             shift and go to state 87
    CTF             shift and go to state 88
    ID              shift and go to state 90

    f                              shift and go to state 130
    var                            shift and go to state 79
    call                           shift and go to state 89

state 113

    (42) t -> t DIV . f
    (43) f -> . LPAREN exp RPAREN
    (44) f -> . CTI
    (45) f -> . CTF
    (46) f -> . var
    (47) f -> . call
    (62) var -> . ID
    (63) call -> . ID LPAREN callp RPAREN SEMICOLON

    LPAREN          shift and go to state 86
    CTI             shift and go to state 87
    CTF             shift and go to state 88
    ID              shift and go to state 90

    f                              shift and go to state 131
    var                            shift and go to state 79
    call                           shift and go to state 89

state 114

    (43) f -> LPAREN exp . RPAREN

    RPAREN          shift and go to state 132


state 115

    (63) call -> ID LPAREN callp RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 133


state 116

    (64) callp -> exp COMMA . callp
    (64) callp -> . exp COMMA callp
    (65) callp -> . exp
    (66) callp -> .
    (27) exp -> . texp
    (28) exp -> . texp OR exp
    (29) texp -> . gexp
    (30) texp -> . gexp AND texp
    (31) gexp -> . mexp
    (32) gexp -> . mexp gexpp mexp
    (37) mexp -> . t
    (38) mexp -> . mexp PLUS t
    (39) mexp -> . mexp MINUS t
    (40) t -> . f
    (41) t -> . t MULT f
    (42) t -> . t DIV f
    (43) f -> . LPAREN exp RPAREN
    (44) f -> . CTI
    (45) f -> . CTF
    (46) f -> . var
    (47) f -> . call
    (62) var -> . ID
    (63) call -> . ID LPAREN callp RPAREN SEMICOLON

    RPAREN          reduce using rule 66 (callp -> .)
    LPAREN          shift and go to state 86
    CTI             shift and go to state 87
    CTF             shift and go to state 88
    ID              shift and go to state 90

    exp                            shift and go to state 92
    callp                          shift and go to state 134
    texp                           shift and go to state 81
    gexp                           shift and go to state 82
    mexp                           shift and go to state 83
    t                              shift and go to state 84
    f                              shift and go to state 85
    var                            shift and go to state 79
    call                           shift and go to state 89

state 117

    (58) read -> READ LPAREN var RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 135


state 118

    (59) print -> PRINT LPAREN printp SEMICOLON .

    VAR             reduce using rule 59 (print -> PRINT LPAREN printp SEMICOLON .)
    FUNCTION        reduce using rule 59 (print -> PRINT LPAREN printp SEMICOLON .)
    ID              reduce using rule 59 (print -> PRINT LPAREN printp SEMICOLON .)
    READ            reduce using rule 59 (print -> PRINT LPAREN printp SEMICOLON .)
    PRINT           reduce using rule 59 (print -> PRINT LPAREN printp SEMICOLON .)
    IF              reduce using rule 59 (print -> PRINT LPAREN printp SEMICOLON .)
    WHILE           reduce using rule 59 (print -> PRINT LPAREN printp SEMICOLON .)
    FOR             reduce using rule 59 (print -> PRINT LPAREN printp SEMICOLON .)
    RBRACE          reduce using rule 59 (print -> PRINT LPAREN printp SEMICOLON .)
    RETURN          reduce using rule 59 (print -> PRINT LPAREN printp SEMICOLON .)
    ELSE            reduce using rule 59 (print -> PRINT LPAREN printp SEMICOLON .)
    SEMICOLON       reduce using rule 59 (print -> PRINT LPAREN printp SEMICOLON .)
    RBRACKET        reduce using rule 59 (print -> PRINT LPAREN printp SEMICOLON .)


state 119

    (60) printp -> exp RPAREN .

    SEMICOLON       reduce using rule 60 (printp -> exp RPAREN .)


state 120

    (61) printp -> exp COMMA . printp
    (60) printp -> . exp RPAREN
    (61) printp -> . exp COMMA printp
    (27) exp -> . texp
    (28) exp -> . texp OR exp
    (29) texp -> . gexp
    (30) texp -> . gexp AND texp
    (31) gexp -> . mexp
    (32) gexp -> . mexp gexpp mexp
    (37) mexp -> . t
    (38) mexp -> . mexp PLUS t
    (39) mexp -> . mexp MINUS t
    (40) t -> . f
    (41) t -> . t MULT f
    (42) t -> . t DIV f
    (43) f -> . LPAREN exp RPAREN
    (44) f -> . CTI
    (45) f -> . CTF
    (46) f -> . var
    (47) f -> . call
    (62) var -> . ID
    (63) call -> . ID LPAREN callp RPAREN SEMICOLON

    LPAREN          shift and go to state 86
    CTI             shift and go to state 87
    CTF             shift and go to state 88
    ID              shift and go to state 90

    exp                            shift and go to state 96
    printp                         shift and go to state 136
    texp                           shift and go to state 81
    gexp                           shift and go to state 82
    mexp                           shift and go to state 83
    t                              shift and go to state 84
    f                              shift and go to state 85
    var                            shift and go to state 79
    call                           shift and go to state 89

state 121

    (67) if -> IF LPAREN exp RPAREN . quadsIf statements ifelse jumpsIf
    (70) quadsIf -> .

    FUNCTION        reduce using rule 70 (quadsIf -> .)
    ID              reduce using rule 70 (quadsIf -> .)
    READ            reduce using rule 70 (quadsIf -> .)
    PRINT           reduce using rule 70 (quadsIf -> .)
    IF              reduce using rule 70 (quadsIf -> .)
    WHILE           reduce using rule 70 (quadsIf -> .)
    FOR             reduce using rule 70 (quadsIf -> .)

    quadsIf                        shift and go to state 137

state 122

    (73) while -> WHILE LPAREN saveJumps exp . RPAREN quadsWhile statements jumpsWhile whilep

    RPAREN          shift and go to state 138


state 123

    (79) for -> FOR LPAREN var SEMICOLON . exp SEMICOLON exp RPAREN LBRACKET statements forp
    (27) exp -> . texp
    (28) exp -> . texp OR exp
    (29) texp -> . gexp
    (30) texp -> . gexp AND texp
    (31) gexp -> . mexp
    (32) gexp -> . mexp gexpp mexp
    (37) mexp -> . t
    (38) mexp -> . mexp PLUS t
    (39) mexp -> . mexp MINUS t
    (40) t -> . f
    (41) t -> . t MULT f
    (42) t -> . t DIV f
    (43) f -> . LPAREN exp RPAREN
    (44) f -> . CTI
    (45) f -> . CTF
    (46) f -> . var
    (47) f -> . call
    (62) var -> . ID
    (63) call -> . ID LPAREN callp RPAREN SEMICOLON

    LPAREN          shift and go to state 86
    CTI             shift and go to state 87
    CTF             shift and go to state 88
    ID              shift and go to state 90

    var                            shift and go to state 79
    exp                            shift and go to state 139
    texp                           shift and go to state 81
    gexp                           shift and go to state 82
    mexp                           shift and go to state 83
    t                              shift and go to state 84
    f                              shift and go to state 85
    call                           shift and go to state 89

state 124

    (11) function -> FUNCTION type decfunc LPAREN param RPAREN LBRACE body RETURN exp . SEMICOLON RBRACE

    SEMICOLON       shift and go to state 140


state 125

    (28) exp -> texp OR exp .

    SEMICOLON       reduce using rule 28 (exp -> texp OR exp .)
    COMMA           reduce using rule 28 (exp -> texp OR exp .)
    RPAREN          reduce using rule 28 (exp -> texp OR exp .)


state 126

    (30) texp -> gexp AND texp .

    OR              reduce using rule 30 (texp -> gexp AND texp .)
    SEMICOLON       reduce using rule 30 (texp -> gexp AND texp .)
    COMMA           reduce using rule 30 (texp -> gexp AND texp .)
    RPAREN          reduce using rule 30 (texp -> gexp AND texp .)


state 127

    (32) gexp -> mexp gexpp mexp .
    (38) mexp -> mexp . PLUS t
    (39) mexp -> mexp . MINUS t

    AND             reduce using rule 32 (gexp -> mexp gexpp mexp .)
    OR              reduce using rule 32 (gexp -> mexp gexpp mexp .)
    SEMICOLON       reduce using rule 32 (gexp -> mexp gexpp mexp .)
    COMMA           reduce using rule 32 (gexp -> mexp gexpp mexp .)
    RPAREN          reduce using rule 32 (gexp -> mexp gexpp mexp .)
    PLUS            shift and go to state 106
    MINUS           shift and go to state 107


state 128

    (38) mexp -> mexp PLUS t .
    (41) t -> t . MULT f
    (42) t -> t . DIV f

    PLUS            reduce using rule 38 (mexp -> mexp PLUS t .)
    MINUS           reduce using rule 38 (mexp -> mexp PLUS t .)
    LT              reduce using rule 38 (mexp -> mexp PLUS t .)
    GT              reduce using rule 38 (mexp -> mexp PLUS t .)
    EQUAL           reduce using rule 38 (mexp -> mexp PLUS t .)
    DIFF            reduce using rule 38 (mexp -> mexp PLUS t .)
    AND             reduce using rule 38 (mexp -> mexp PLUS t .)
    OR              reduce using rule 38 (mexp -> mexp PLUS t .)
    SEMICOLON       reduce using rule 38 (mexp -> mexp PLUS t .)
    COMMA           reduce using rule 38 (mexp -> mexp PLUS t .)
    RPAREN          reduce using rule 38 (mexp -> mexp PLUS t .)
    MULT            shift and go to state 112
    DIV             shift and go to state 113


state 129

    (39) mexp -> mexp MINUS t .
    (41) t -> t . MULT f
    (42) t -> t . DIV f

    PLUS            reduce using rule 39 (mexp -> mexp MINUS t .)
    MINUS           reduce using rule 39 (mexp -> mexp MINUS t .)
    LT              reduce using rule 39 (mexp -> mexp MINUS t .)
    GT              reduce using rule 39 (mexp -> mexp MINUS t .)
    EQUAL           reduce using rule 39 (mexp -> mexp MINUS t .)
    DIFF            reduce using rule 39 (mexp -> mexp MINUS t .)
    AND             reduce using rule 39 (mexp -> mexp MINUS t .)
    OR              reduce using rule 39 (mexp -> mexp MINUS t .)
    SEMICOLON       reduce using rule 39 (mexp -> mexp MINUS t .)
    COMMA           reduce using rule 39 (mexp -> mexp MINUS t .)
    RPAREN          reduce using rule 39 (mexp -> mexp MINUS t .)
    MULT            shift and go to state 112
    DIV             shift and go to state 113


state 130

    (41) t -> t MULT f .

    MULT            reduce using rule 41 (t -> t MULT f .)
    DIV             reduce using rule 41 (t -> t MULT f .)
    PLUS            reduce using rule 41 (t -> t MULT f .)
    MINUS           reduce using rule 41 (t -> t MULT f .)
    LT              reduce using rule 41 (t -> t MULT f .)
    GT              reduce using rule 41 (t -> t MULT f .)
    EQUAL           reduce using rule 41 (t -> t MULT f .)
    DIFF            reduce using rule 41 (t -> t MULT f .)
    AND             reduce using rule 41 (t -> t MULT f .)
    OR              reduce using rule 41 (t -> t MULT f .)
    SEMICOLON       reduce using rule 41 (t -> t MULT f .)
    COMMA           reduce using rule 41 (t -> t MULT f .)
    RPAREN          reduce using rule 41 (t -> t MULT f .)


state 131

    (42) t -> t DIV f .

    MULT            reduce using rule 42 (t -> t DIV f .)
    DIV             reduce using rule 42 (t -> t DIV f .)
    PLUS            reduce using rule 42 (t -> t DIV f .)
    MINUS           reduce using rule 42 (t -> t DIV f .)
    LT              reduce using rule 42 (t -> t DIV f .)
    GT              reduce using rule 42 (t -> t DIV f .)
    EQUAL           reduce using rule 42 (t -> t DIV f .)
    DIFF            reduce using rule 42 (t -> t DIV f .)
    AND             reduce using rule 42 (t -> t DIV f .)
    OR              reduce using rule 42 (t -> t DIV f .)
    SEMICOLON       reduce using rule 42 (t -> t DIV f .)
    COMMA           reduce using rule 42 (t -> t DIV f .)
    RPAREN          reduce using rule 42 (t -> t DIV f .)


state 132

    (43) f -> LPAREN exp RPAREN .

    MULT            reduce using rule 43 (f -> LPAREN exp RPAREN .)
    DIV             reduce using rule 43 (f -> LPAREN exp RPAREN .)
    PLUS            reduce using rule 43 (f -> LPAREN exp RPAREN .)
    MINUS           reduce using rule 43 (f -> LPAREN exp RPAREN .)
    LT              reduce using rule 43 (f -> LPAREN exp RPAREN .)
    GT              reduce using rule 43 (f -> LPAREN exp RPAREN .)
    EQUAL           reduce using rule 43 (f -> LPAREN exp RPAREN .)
    DIFF            reduce using rule 43 (f -> LPAREN exp RPAREN .)
    AND             reduce using rule 43 (f -> LPAREN exp RPAREN .)
    OR              reduce using rule 43 (f -> LPAREN exp RPAREN .)
    SEMICOLON       reduce using rule 43 (f -> LPAREN exp RPAREN .)
    COMMA           reduce using rule 43 (f -> LPAREN exp RPAREN .)
    RPAREN          reduce using rule 43 (f -> LPAREN exp RPAREN .)


state 133

    (63) call -> ID LPAREN callp RPAREN SEMICOLON .

    VAR             reduce using rule 63 (call -> ID LPAREN callp RPAREN SEMICOLON .)
    FUNCTION        reduce using rule 63 (call -> ID LPAREN callp RPAREN SEMICOLON .)
    ID              reduce using rule 63 (call -> ID LPAREN callp RPAREN SEMICOLON .)
    READ            reduce using rule 63 (call -> ID LPAREN callp RPAREN SEMICOLON .)
    PRINT           reduce using rule 63 (call -> ID LPAREN callp RPAREN SEMICOLON .)
    IF              reduce using rule 63 (call -> ID LPAREN callp RPAREN SEMICOLON .)
    WHILE           reduce using rule 63 (call -> ID LPAREN callp RPAREN SEMICOLON .)
    FOR             reduce using rule 63 (call -> ID LPAREN callp RPAREN SEMICOLON .)
    RBRACE          reduce using rule 63 (call -> ID LPAREN callp RPAREN SEMICOLON .)
    RETURN          reduce using rule 63 (call -> ID LPAREN callp RPAREN SEMICOLON .)
    MULT            reduce using rule 63 (call -> ID LPAREN callp RPAREN SEMICOLON .)
    DIV             reduce using rule 63 (call -> ID LPAREN callp RPAREN SEMICOLON .)
    PLUS            reduce using rule 63 (call -> ID LPAREN callp RPAREN SEMICOLON .)
    MINUS           reduce using rule 63 (call -> ID LPAREN callp RPAREN SEMICOLON .)
    LT              reduce using rule 63 (call -> ID LPAREN callp RPAREN SEMICOLON .)
    GT              reduce using rule 63 (call -> ID LPAREN callp RPAREN SEMICOLON .)
    EQUAL           reduce using rule 63 (call -> ID LPAREN callp RPAREN SEMICOLON .)
    DIFF            reduce using rule 63 (call -> ID LPAREN callp RPAREN SEMICOLON .)
    AND             reduce using rule 63 (call -> ID LPAREN callp RPAREN SEMICOLON .)
    OR              reduce using rule 63 (call -> ID LPAREN callp RPAREN SEMICOLON .)
    SEMICOLON       reduce using rule 63 (call -> ID LPAREN callp RPAREN SEMICOLON .)
    COMMA           reduce using rule 63 (call -> ID LPAREN callp RPAREN SEMICOLON .)
    RPAREN          reduce using rule 63 (call -> ID LPAREN callp RPAREN SEMICOLON .)
    ELSE            reduce using rule 63 (call -> ID LPAREN callp RPAREN SEMICOLON .)
    RBRACKET        reduce using rule 63 (call -> ID LPAREN callp RPAREN SEMICOLON .)


state 134

    (64) callp -> exp COMMA callp .

    RPAREN          reduce using rule 64 (callp -> exp COMMA callp .)


state 135

    (58) read -> READ LPAREN var RPAREN SEMICOLON .

    VAR             reduce using rule 58 (read -> READ LPAREN var RPAREN SEMICOLON .)
    FUNCTION        reduce using rule 58 (read -> READ LPAREN var RPAREN SEMICOLON .)
    ID              reduce using rule 58 (read -> READ LPAREN var RPAREN SEMICOLON .)
    READ            reduce using rule 58 (read -> READ LPAREN var RPAREN SEMICOLON .)
    PRINT           reduce using rule 58 (read -> READ LPAREN var RPAREN SEMICOLON .)
    IF              reduce using rule 58 (read -> READ LPAREN var RPAREN SEMICOLON .)
    WHILE           reduce using rule 58 (read -> READ LPAREN var RPAREN SEMICOLON .)
    FOR             reduce using rule 58 (read -> READ LPAREN var RPAREN SEMICOLON .)
    RBRACE          reduce using rule 58 (read -> READ LPAREN var RPAREN SEMICOLON .)
    RETURN          reduce using rule 58 (read -> READ LPAREN var RPAREN SEMICOLON .)
    ELSE            reduce using rule 58 (read -> READ LPAREN var RPAREN SEMICOLON .)
    SEMICOLON       reduce using rule 58 (read -> READ LPAREN var RPAREN SEMICOLON .)
    RBRACKET        reduce using rule 58 (read -> READ LPAREN var RPAREN SEMICOLON .)


state 136

    (61) printp -> exp COMMA printp .

    SEMICOLON       reduce using rule 61 (printp -> exp COMMA printp .)


state 137

    (67) if -> IF LPAREN exp RPAREN quadsIf . statements ifelse jumpsIf
    (48) statements -> . assign
    (49) statements -> . function
    (50) statements -> . voidfunction
    (51) statements -> . call
    (52) statements -> . read
    (53) statements -> . print
    (54) statements -> . if
    (55) statements -> . while
    (56) statements -> . for
    (57) assign -> . var EQUAL exp SEMICOLON
    (11) function -> . FUNCTION type decfunc LPAREN param RPAREN LBRACE body RETURN exp SEMICOLON RBRACE
    (13) voidfunction -> . FUNCTION VOID decfunc LPAREN param RPAREN LBRACE body RBRACE
    (63) call -> . ID LPAREN callp RPAREN SEMICOLON
    (58) read -> . READ LPAREN var RPAREN SEMICOLON
    (59) print -> . PRINT LPAREN printp SEMICOLON
    (67) if -> . IF LPAREN exp RPAREN quadsIf statements ifelse jumpsIf
    (73) while -> . WHILE LPAREN saveJumps exp RPAREN quadsWhile statements jumpsWhile whilep
    (79) for -> . FOR LPAREN var SEMICOLON exp SEMICOLON exp RPAREN LBRACKET statements forp
    (62) var -> . ID

    FUNCTION        shift and go to state 11
    ID              shift and go to state 56
    READ            shift and go to state 57
    PRINT           shift and go to state 58
    IF              shift and go to state 59
    WHILE           shift and go to state 60
    FOR             shift and go to state 61

    statements                     shift and go to state 141
    assign                         shift and go to state 46
    function                       shift and go to state 47
    voidfunction                   shift and go to state 48
    call                           shift and go to state 49
    read                           shift and go to state 50
    print                          shift and go to state 51
    if                             shift and go to state 52
    while                          shift and go to state 53
    for                            shift and go to state 54
    var                            shift and go to state 55

state 138

    (73) while -> WHILE LPAREN saveJumps exp RPAREN . quadsWhile statements jumpsWhile whilep
    (77) quadsWhile -> .

    FUNCTION        reduce using rule 77 (quadsWhile -> .)
    ID              reduce using rule 77 (quadsWhile -> .)
    READ            reduce using rule 77 (quadsWhile -> .)
    PRINT           reduce using rule 77 (quadsWhile -> .)
    IF              reduce using rule 77 (quadsWhile -> .)
    WHILE           reduce using rule 77 (quadsWhile -> .)
    FOR             reduce using rule 77 (quadsWhile -> .)

    quadsWhile                     shift and go to state 142

state 139

    (79) for -> FOR LPAREN var SEMICOLON exp . SEMICOLON exp RPAREN LBRACKET statements forp

    SEMICOLON       shift and go to state 143


state 140

    (11) function -> FUNCTION type decfunc LPAREN param RPAREN LBRACE body RETURN exp SEMICOLON . RBRACE

    RBRACE          shift and go to state 144


state 141

    (67) if -> IF LPAREN exp RPAREN quadsIf statements . ifelse jumpsIf
    (68) ifelse -> .
    (69) ifelse -> . ELSE quadsElse statements

  ! shift/reduce conflict for ELSE resolved as shift
    VAR             reduce using rule 68 (ifelse -> .)
    FUNCTION        reduce using rule 68 (ifelse -> .)
    ID              reduce using rule 68 (ifelse -> .)
    READ            reduce using rule 68 (ifelse -> .)
    PRINT           reduce using rule 68 (ifelse -> .)
    IF              reduce using rule 68 (ifelse -> .)
    WHILE           reduce using rule 68 (ifelse -> .)
    FOR             reduce using rule 68 (ifelse -> .)
    RBRACE          reduce using rule 68 (ifelse -> .)
    RETURN          reduce using rule 68 (ifelse -> .)
    SEMICOLON       reduce using rule 68 (ifelse -> .)
    RBRACKET        reduce using rule 68 (ifelse -> .)
    ELSE            shift and go to state 146

  ! ELSE            [ reduce using rule 68 (ifelse -> .) ]

    ifelse                         shift and go to state 145

state 142

    (73) while -> WHILE LPAREN saveJumps exp RPAREN quadsWhile . statements jumpsWhile whilep
    (48) statements -> . assign
    (49) statements -> . function
    (50) statements -> . voidfunction
    (51) statements -> . call
    (52) statements -> . read
    (53) statements -> . print
    (54) statements -> . if
    (55) statements -> . while
    (56) statements -> . for
    (57) assign -> . var EQUAL exp SEMICOLON
    (11) function -> . FUNCTION type decfunc LPAREN param RPAREN LBRACE body RETURN exp SEMICOLON RBRACE
    (13) voidfunction -> . FUNCTION VOID decfunc LPAREN param RPAREN LBRACE body RBRACE
    (63) call -> . ID LPAREN callp RPAREN SEMICOLON
    (58) read -> . READ LPAREN var RPAREN SEMICOLON
    (59) print -> . PRINT LPAREN printp SEMICOLON
    (67) if -> . IF LPAREN exp RPAREN quadsIf statements ifelse jumpsIf
    (73) while -> . WHILE LPAREN saveJumps exp RPAREN quadsWhile statements jumpsWhile whilep
    (79) for -> . FOR LPAREN var SEMICOLON exp SEMICOLON exp RPAREN LBRACKET statements forp
    (62) var -> . ID

    FUNCTION        shift and go to state 11
    ID              shift and go to state 56
    READ            shift and go to state 57
    PRINT           shift and go to state 58
    IF              shift and go to state 59
    WHILE           shift and go to state 60
    FOR             shift and go to state 61

    statements                     shift and go to state 147
    assign                         shift and go to state 46
    function                       shift and go to state 47
    voidfunction                   shift and go to state 48
    call                           shift and go to state 49
    read                           shift and go to state 50
    print                          shift and go to state 51
    if                             shift and go to state 52
    while                          shift and go to state 53
    for                            shift and go to state 54
    var                            shift and go to state 55

state 143

    (79) for -> FOR LPAREN var SEMICOLON exp SEMICOLON . exp RPAREN LBRACKET statements forp
    (27) exp -> . texp
    (28) exp -> . texp OR exp
    (29) texp -> . gexp
    (30) texp -> . gexp AND texp
    (31) gexp -> . mexp
    (32) gexp -> . mexp gexpp mexp
    (37) mexp -> . t
    (38) mexp -> . mexp PLUS t
    (39) mexp -> . mexp MINUS t
    (40) t -> . f
    (41) t -> . t MULT f
    (42) t -> . t DIV f
    (43) f -> . LPAREN exp RPAREN
    (44) f -> . CTI
    (45) f -> . CTF
    (46) f -> . var
    (47) f -> . call
    (62) var -> . ID
    (63) call -> . ID LPAREN callp RPAREN SEMICOLON

    LPAREN          shift and go to state 86
    CTI             shift and go to state 87
    CTF             shift and go to state 88
    ID              shift and go to state 90

    var                            shift and go to state 79
    exp                            shift and go to state 148
    texp                           shift and go to state 81
    gexp                           shift and go to state 82
    mexp                           shift and go to state 83
    t                              shift and go to state 84
    f                              shift and go to state 85
    call                           shift and go to state 89

state 144

    (11) function -> FUNCTION type decfunc LPAREN param RPAREN LBRACE body RETURN exp SEMICOLON RBRACE .

    FUNCTION        reduce using rule 11 (function -> FUNCTION type decfunc LPAREN param RPAREN LBRACE body RETURN exp SEMICOLON RBRACE .)
    MAIN            reduce using rule 11 (function -> FUNCTION type decfunc LPAREN param RPAREN LBRACE body RETURN exp SEMICOLON RBRACE .)
    VAR             reduce using rule 11 (function -> FUNCTION type decfunc LPAREN param RPAREN LBRACE body RETURN exp SEMICOLON RBRACE .)
    ID              reduce using rule 11 (function -> FUNCTION type decfunc LPAREN param RPAREN LBRACE body RETURN exp SEMICOLON RBRACE .)
    READ            reduce using rule 11 (function -> FUNCTION type decfunc LPAREN param RPAREN LBRACE body RETURN exp SEMICOLON RBRACE .)
    PRINT           reduce using rule 11 (function -> FUNCTION type decfunc LPAREN param RPAREN LBRACE body RETURN exp SEMICOLON RBRACE .)
    IF              reduce using rule 11 (function -> FUNCTION type decfunc LPAREN param RPAREN LBRACE body RETURN exp SEMICOLON RBRACE .)
    WHILE           reduce using rule 11 (function -> FUNCTION type decfunc LPAREN param RPAREN LBRACE body RETURN exp SEMICOLON RBRACE .)
    FOR             reduce using rule 11 (function -> FUNCTION type decfunc LPAREN param RPAREN LBRACE body RETURN exp SEMICOLON RBRACE .)
    RBRACE          reduce using rule 11 (function -> FUNCTION type decfunc LPAREN param RPAREN LBRACE body RETURN exp SEMICOLON RBRACE .)
    RETURN          reduce using rule 11 (function -> FUNCTION type decfunc LPAREN param RPAREN LBRACE body RETURN exp SEMICOLON RBRACE .)
    ELSE            reduce using rule 11 (function -> FUNCTION type decfunc LPAREN param RPAREN LBRACE body RETURN exp SEMICOLON RBRACE .)
    SEMICOLON       reduce using rule 11 (function -> FUNCTION type decfunc LPAREN param RPAREN LBRACE body RETURN exp SEMICOLON RBRACE .)
    RBRACKET        reduce using rule 11 (function -> FUNCTION type decfunc LPAREN param RPAREN LBRACE body RETURN exp SEMICOLON RBRACE .)


state 145

    (67) if -> IF LPAREN exp RPAREN quadsIf statements ifelse . jumpsIf
    (71) jumpsIf -> .

    VAR             reduce using rule 71 (jumpsIf -> .)
    FUNCTION        reduce using rule 71 (jumpsIf -> .)
    ID              reduce using rule 71 (jumpsIf -> .)
    READ            reduce using rule 71 (jumpsIf -> .)
    PRINT           reduce using rule 71 (jumpsIf -> .)
    IF              reduce using rule 71 (jumpsIf -> .)
    WHILE           reduce using rule 71 (jumpsIf -> .)
    FOR             reduce using rule 71 (jumpsIf -> .)
    RBRACE          reduce using rule 71 (jumpsIf -> .)
    RETURN          reduce using rule 71 (jumpsIf -> .)
    ELSE            reduce using rule 71 (jumpsIf -> .)
    SEMICOLON       reduce using rule 71 (jumpsIf -> .)
    RBRACKET        reduce using rule 71 (jumpsIf -> .)

    jumpsIf                        shift and go to state 149

state 146

    (69) ifelse -> ELSE . quadsElse statements
    (72) quadsElse -> .

    FUNCTION        reduce using rule 72 (quadsElse -> .)
    ID              reduce using rule 72 (quadsElse -> .)
    READ            reduce using rule 72 (quadsElse -> .)
    PRINT           reduce using rule 72 (quadsElse -> .)
    IF              reduce using rule 72 (quadsElse -> .)
    WHILE           reduce using rule 72 (quadsElse -> .)
    FOR             reduce using rule 72 (quadsElse -> .)

    quadsElse                      shift and go to state 150

state 147

    (73) while -> WHILE LPAREN saveJumps exp RPAREN quadsWhile statements . jumpsWhile whilep
    (78) jumpsWhile -> .

    SEMICOLON       reduce using rule 78 (jumpsWhile -> .)
    FUNCTION        reduce using rule 78 (jumpsWhile -> .)
    ID              reduce using rule 78 (jumpsWhile -> .)
    READ            reduce using rule 78 (jumpsWhile -> .)
    PRINT           reduce using rule 78 (jumpsWhile -> .)
    IF              reduce using rule 78 (jumpsWhile -> .)
    WHILE           reduce using rule 78 (jumpsWhile -> .)
    FOR             reduce using rule 78 (jumpsWhile -> .)

    jumpsWhile                     shift and go to state 151

state 148

    (79) for -> FOR LPAREN var SEMICOLON exp SEMICOLON exp . RPAREN LBRACKET statements forp

    RPAREN          shift and go to state 152


state 149

    (67) if -> IF LPAREN exp RPAREN quadsIf statements ifelse jumpsIf .

    VAR             reduce using rule 67 (if -> IF LPAREN exp RPAREN quadsIf statements ifelse jumpsIf .)
    FUNCTION        reduce using rule 67 (if -> IF LPAREN exp RPAREN quadsIf statements ifelse jumpsIf .)
    ID              reduce using rule 67 (if -> IF LPAREN exp RPAREN quadsIf statements ifelse jumpsIf .)
    READ            reduce using rule 67 (if -> IF LPAREN exp RPAREN quadsIf statements ifelse jumpsIf .)
    PRINT           reduce using rule 67 (if -> IF LPAREN exp RPAREN quadsIf statements ifelse jumpsIf .)
    IF              reduce using rule 67 (if -> IF LPAREN exp RPAREN quadsIf statements ifelse jumpsIf .)
    WHILE           reduce using rule 67 (if -> IF LPAREN exp RPAREN quadsIf statements ifelse jumpsIf .)
    FOR             reduce using rule 67 (if -> IF LPAREN exp RPAREN quadsIf statements ifelse jumpsIf .)
    RBRACE          reduce using rule 67 (if -> IF LPAREN exp RPAREN quadsIf statements ifelse jumpsIf .)
    RETURN          reduce using rule 67 (if -> IF LPAREN exp RPAREN quadsIf statements ifelse jumpsIf .)
    ELSE            reduce using rule 67 (if -> IF LPAREN exp RPAREN quadsIf statements ifelse jumpsIf .)
    SEMICOLON       reduce using rule 67 (if -> IF LPAREN exp RPAREN quadsIf statements ifelse jumpsIf .)
    RBRACKET        reduce using rule 67 (if -> IF LPAREN exp RPAREN quadsIf statements ifelse jumpsIf .)


state 150

    (69) ifelse -> ELSE quadsElse . statements
    (48) statements -> . assign
    (49) statements -> . function
    (50) statements -> . voidfunction
    (51) statements -> . call
    (52) statements -> . read
    (53) statements -> . print
    (54) statements -> . if
    (55) statements -> . while
    (56) statements -> . for
    (57) assign -> . var EQUAL exp SEMICOLON
    (11) function -> . FUNCTION type decfunc LPAREN param RPAREN LBRACE body RETURN exp SEMICOLON RBRACE
    (13) voidfunction -> . FUNCTION VOID decfunc LPAREN param RPAREN LBRACE body RBRACE
    (63) call -> . ID LPAREN callp RPAREN SEMICOLON
    (58) read -> . READ LPAREN var RPAREN SEMICOLON
    (59) print -> . PRINT LPAREN printp SEMICOLON
    (67) if -> . IF LPAREN exp RPAREN quadsIf statements ifelse jumpsIf
    (73) while -> . WHILE LPAREN saveJumps exp RPAREN quadsWhile statements jumpsWhile whilep
    (79) for -> . FOR LPAREN var SEMICOLON exp SEMICOLON exp RPAREN LBRACKET statements forp
    (62) var -> . ID

    FUNCTION        shift and go to state 11
    ID              shift and go to state 56
    READ            shift and go to state 57
    PRINT           shift and go to state 58
    IF              shift and go to state 59
    WHILE           shift and go to state 60
    FOR             shift and go to state 61

    statements                     shift and go to state 153
    assign                         shift and go to state 46
    function                       shift and go to state 47
    voidfunction                   shift and go to state 48
    call                           shift and go to state 49
    read                           shift and go to state 50
    print                          shift and go to state 51
    if                             shift and go to state 52
    while                          shift and go to state 53
    for                            shift and go to state 54
    var                            shift and go to state 55

state 151

    (73) while -> WHILE LPAREN saveJumps exp RPAREN quadsWhile statements jumpsWhile . whilep
    (74) whilep -> . SEMICOLON
    (75) whilep -> . statements whilep
    (48) statements -> . assign
    (49) statements -> . function
    (50) statements -> . voidfunction
    (51) statements -> . call
    (52) statements -> . read
    (53) statements -> . print
    (54) statements -> . if
    (55) statements -> . while
    (56) statements -> . for
    (57) assign -> . var EQUAL exp SEMICOLON
    (11) function -> . FUNCTION type decfunc LPAREN param RPAREN LBRACE body RETURN exp SEMICOLON RBRACE
    (13) voidfunction -> . FUNCTION VOID decfunc LPAREN param RPAREN LBRACE body RBRACE
    (63) call -> . ID LPAREN callp RPAREN SEMICOLON
    (58) read -> . READ LPAREN var RPAREN SEMICOLON
    (59) print -> . PRINT LPAREN printp SEMICOLON
    (67) if -> . IF LPAREN exp RPAREN quadsIf statements ifelse jumpsIf
    (73) while -> . WHILE LPAREN saveJumps exp RPAREN quadsWhile statements jumpsWhile whilep
    (79) for -> . FOR LPAREN var SEMICOLON exp SEMICOLON exp RPAREN LBRACKET statements forp
    (62) var -> . ID

    SEMICOLON       shift and go to state 156
    FUNCTION        shift and go to state 11
    ID              shift and go to state 56
    READ            shift and go to state 57
    PRINT           shift and go to state 58
    IF              shift and go to state 59
    WHILE           shift and go to state 60
    FOR             shift and go to state 61

    statements                     shift and go to state 154
    whilep                         shift and go to state 155
    assign                         shift and go to state 46
    function                       shift and go to state 47
    voidfunction                   shift and go to state 48
    call                           shift and go to state 49
    read                           shift and go to state 50
    print                          shift and go to state 51
    if                             shift and go to state 52
    while                          shift and go to state 53
    for                            shift and go to state 54
    var                            shift and go to state 55

state 152

    (79) for -> FOR LPAREN var SEMICOLON exp SEMICOLON exp RPAREN . LBRACKET statements forp

    LBRACKET        shift and go to state 157


state 153

    (69) ifelse -> ELSE quadsElse statements .

    ELSE            reduce using rule 69 (ifelse -> ELSE quadsElse statements .)
    VAR             reduce using rule 69 (ifelse -> ELSE quadsElse statements .)
    FUNCTION        reduce using rule 69 (ifelse -> ELSE quadsElse statements .)
    ID              reduce using rule 69 (ifelse -> ELSE quadsElse statements .)
    READ            reduce using rule 69 (ifelse -> ELSE quadsElse statements .)
    PRINT           reduce using rule 69 (ifelse -> ELSE quadsElse statements .)
    IF              reduce using rule 69 (ifelse -> ELSE quadsElse statements .)
    WHILE           reduce using rule 69 (ifelse -> ELSE quadsElse statements .)
    FOR             reduce using rule 69 (ifelse -> ELSE quadsElse statements .)
    RBRACE          reduce using rule 69 (ifelse -> ELSE quadsElse statements .)
    RETURN          reduce using rule 69 (ifelse -> ELSE quadsElse statements .)
    SEMICOLON       reduce using rule 69 (ifelse -> ELSE quadsElse statements .)
    RBRACKET        reduce using rule 69 (ifelse -> ELSE quadsElse statements .)


state 154

    (75) whilep -> statements . whilep
    (74) whilep -> . SEMICOLON
    (75) whilep -> . statements whilep
    (48) statements -> . assign
    (49) statements -> . function
    (50) statements -> . voidfunction
    (51) statements -> . call
    (52) statements -> . read
    (53) statements -> . print
    (54) statements -> . if
    (55) statements -> . while
    (56) statements -> . for
    (57) assign -> . var EQUAL exp SEMICOLON
    (11) function -> . FUNCTION type decfunc LPAREN param RPAREN LBRACE body RETURN exp SEMICOLON RBRACE
    (13) voidfunction -> . FUNCTION VOID decfunc LPAREN param RPAREN LBRACE body RBRACE
    (63) call -> . ID LPAREN callp RPAREN SEMICOLON
    (58) read -> . READ LPAREN var RPAREN SEMICOLON
    (59) print -> . PRINT LPAREN printp SEMICOLON
    (67) if -> . IF LPAREN exp RPAREN quadsIf statements ifelse jumpsIf
    (73) while -> . WHILE LPAREN saveJumps exp RPAREN quadsWhile statements jumpsWhile whilep
    (79) for -> . FOR LPAREN var SEMICOLON exp SEMICOLON exp RPAREN LBRACKET statements forp
    (62) var -> . ID

    SEMICOLON       shift and go to state 156
    FUNCTION        shift and go to state 11
    ID              shift and go to state 56
    READ            shift and go to state 57
    PRINT           shift and go to state 58
    IF              shift and go to state 59
    WHILE           shift and go to state 60
    FOR             shift and go to state 61

    statements                     shift and go to state 154
    whilep                         shift and go to state 158
    assign                         shift and go to state 46
    function                       shift and go to state 47
    voidfunction                   shift and go to state 48
    call                           shift and go to state 49
    read                           shift and go to state 50
    print                          shift and go to state 51
    if                             shift and go to state 52
    while                          shift and go to state 53
    for                            shift and go to state 54
    var                            shift and go to state 55

state 155

    (73) while -> WHILE LPAREN saveJumps exp RPAREN quadsWhile statements jumpsWhile whilep .

    VAR             reduce using rule 73 (while -> WHILE LPAREN saveJumps exp RPAREN quadsWhile statements jumpsWhile whilep .)
    FUNCTION        reduce using rule 73 (while -> WHILE LPAREN saveJumps exp RPAREN quadsWhile statements jumpsWhile whilep .)
    ID              reduce using rule 73 (while -> WHILE LPAREN saveJumps exp RPAREN quadsWhile statements jumpsWhile whilep .)
    READ            reduce using rule 73 (while -> WHILE LPAREN saveJumps exp RPAREN quadsWhile statements jumpsWhile whilep .)
    PRINT           reduce using rule 73 (while -> WHILE LPAREN saveJumps exp RPAREN quadsWhile statements jumpsWhile whilep .)
    IF              reduce using rule 73 (while -> WHILE LPAREN saveJumps exp RPAREN quadsWhile statements jumpsWhile whilep .)
    WHILE           reduce using rule 73 (while -> WHILE LPAREN saveJumps exp RPAREN quadsWhile statements jumpsWhile whilep .)
    FOR             reduce using rule 73 (while -> WHILE LPAREN saveJumps exp RPAREN quadsWhile statements jumpsWhile whilep .)
    RBRACE          reduce using rule 73 (while -> WHILE LPAREN saveJumps exp RPAREN quadsWhile statements jumpsWhile whilep .)
    RETURN          reduce using rule 73 (while -> WHILE LPAREN saveJumps exp RPAREN quadsWhile statements jumpsWhile whilep .)
    ELSE            reduce using rule 73 (while -> WHILE LPAREN saveJumps exp RPAREN quadsWhile statements jumpsWhile whilep .)
    SEMICOLON       reduce using rule 73 (while -> WHILE LPAREN saveJumps exp RPAREN quadsWhile statements jumpsWhile whilep .)
    RBRACKET        reduce using rule 73 (while -> WHILE LPAREN saveJumps exp RPAREN quadsWhile statements jumpsWhile whilep .)


state 156

    (74) whilep -> SEMICOLON .

    VAR             reduce using rule 74 (whilep -> SEMICOLON .)
    FUNCTION        reduce using rule 74 (whilep -> SEMICOLON .)
    ID              reduce using rule 74 (whilep -> SEMICOLON .)
    READ            reduce using rule 74 (whilep -> SEMICOLON .)
    PRINT           reduce using rule 74 (whilep -> SEMICOLON .)
    IF              reduce using rule 74 (whilep -> SEMICOLON .)
    WHILE           reduce using rule 74 (whilep -> SEMICOLON .)
    FOR             reduce using rule 74 (whilep -> SEMICOLON .)
    RBRACE          reduce using rule 74 (whilep -> SEMICOLON .)
    RETURN          reduce using rule 74 (whilep -> SEMICOLON .)
    ELSE            reduce using rule 74 (whilep -> SEMICOLON .)
    SEMICOLON       reduce using rule 74 (whilep -> SEMICOLON .)
    RBRACKET        reduce using rule 74 (whilep -> SEMICOLON .)


state 157

    (79) for -> FOR LPAREN var SEMICOLON exp SEMICOLON exp RPAREN LBRACKET . statements forp
    (48) statements -> . assign
    (49) statements -> . function
    (50) statements -> . voidfunction
    (51) statements -> . call
    (52) statements -> . read
    (53) statements -> . print
    (54) statements -> . if
    (55) statements -> . while
    (56) statements -> . for
    (57) assign -> . var EQUAL exp SEMICOLON
    (11) function -> . FUNCTION type decfunc LPAREN param RPAREN LBRACE body RETURN exp SEMICOLON RBRACE
    (13) voidfunction -> . FUNCTION VOID decfunc LPAREN param RPAREN LBRACE body RBRACE
    (63) call -> . ID LPAREN callp RPAREN SEMICOLON
    (58) read -> . READ LPAREN var RPAREN SEMICOLON
    (59) print -> . PRINT LPAREN printp SEMICOLON
    (67) if -> . IF LPAREN exp RPAREN quadsIf statements ifelse jumpsIf
    (73) while -> . WHILE LPAREN saveJumps exp RPAREN quadsWhile statements jumpsWhile whilep
    (79) for -> . FOR LPAREN var SEMICOLON exp SEMICOLON exp RPAREN LBRACKET statements forp
    (62) var -> . ID

    FUNCTION        shift and go to state 11
    ID              shift and go to state 56
    READ            shift and go to state 57
    PRINT           shift and go to state 58
    IF              shift and go to state 59
    WHILE           shift and go to state 60
    FOR             shift and go to state 61

    var                            shift and go to state 55
    statements                     shift and go to state 159
    assign                         shift and go to state 46
    function                       shift and go to state 47
    voidfunction                   shift and go to state 48
    call                           shift and go to state 49
    read                           shift and go to state 50
    print                          shift and go to state 51
    if                             shift and go to state 52
    while                          shift and go to state 53
    for                            shift and go to state 54

state 158

    (75) whilep -> statements whilep .

    VAR             reduce using rule 75 (whilep -> statements whilep .)
    FUNCTION        reduce using rule 75 (whilep -> statements whilep .)
    ID              reduce using rule 75 (whilep -> statements whilep .)
    READ            reduce using rule 75 (whilep -> statements whilep .)
    PRINT           reduce using rule 75 (whilep -> statements whilep .)
    IF              reduce using rule 75 (whilep -> statements whilep .)
    WHILE           reduce using rule 75 (whilep -> statements whilep .)
    FOR             reduce using rule 75 (whilep -> statements whilep .)
    RBRACE          reduce using rule 75 (whilep -> statements whilep .)
    RETURN          reduce using rule 75 (whilep -> statements whilep .)
    ELSE            reduce using rule 75 (whilep -> statements whilep .)
    SEMICOLON       reduce using rule 75 (whilep -> statements whilep .)
    RBRACKET        reduce using rule 75 (whilep -> statements whilep .)


state 159

    (79) for -> FOR LPAREN var SEMICOLON exp SEMICOLON exp RPAREN LBRACKET statements . forp
    (80) forp -> . RBRACKET
    (81) forp -> . statements forp
    (48) statements -> . assign
    (49) statements -> . function
    (50) statements -> . voidfunction
    (51) statements -> . call
    (52) statements -> . read
    (53) statements -> . print
    (54) statements -> . if
    (55) statements -> . while
    (56) statements -> . for
    (57) assign -> . var EQUAL exp SEMICOLON
    (11) function -> . FUNCTION type decfunc LPAREN param RPAREN LBRACE body RETURN exp SEMICOLON RBRACE
    (13) voidfunction -> . FUNCTION VOID decfunc LPAREN param RPAREN LBRACE body RBRACE
    (63) call -> . ID LPAREN callp RPAREN SEMICOLON
    (58) read -> . READ LPAREN var RPAREN SEMICOLON
    (59) print -> . PRINT LPAREN printp SEMICOLON
    (67) if -> . IF LPAREN exp RPAREN quadsIf statements ifelse jumpsIf
    (73) while -> . WHILE LPAREN saveJumps exp RPAREN quadsWhile statements jumpsWhile whilep
    (79) for -> . FOR LPAREN var SEMICOLON exp SEMICOLON exp RPAREN LBRACKET statements forp
    (62) var -> . ID

    RBRACKET        shift and go to state 162
    FUNCTION        shift and go to state 11
    ID              shift and go to state 56
    READ            shift and go to state 57
    PRINT           shift and go to state 58
    IF              shift and go to state 59
    WHILE           shift and go to state 60
    FOR             shift and go to state 61

    var                            shift and go to state 55
    statements                     shift and go to state 160
    forp                           shift and go to state 161
    assign                         shift and go to state 46
    function                       shift and go to state 47
    voidfunction                   shift and go to state 48
    call                           shift and go to state 49
    read                           shift and go to state 50
    print                          shift and go to state 51
    if                             shift and go to state 52
    while                          shift and go to state 53
    for                            shift and go to state 54

state 160

    (81) forp -> statements . forp
    (80) forp -> . RBRACKET
    (81) forp -> . statements forp
    (48) statements -> . assign
    (49) statements -> . function
    (50) statements -> . voidfunction
    (51) statements -> . call
    (52) statements -> . read
    (53) statements -> . print
    (54) statements -> . if
    (55) statements -> . while
    (56) statements -> . for
    (57) assign -> . var EQUAL exp SEMICOLON
    (11) function -> . FUNCTION type decfunc LPAREN param RPAREN LBRACE body RETURN exp SEMICOLON RBRACE
    (13) voidfunction -> . FUNCTION VOID decfunc LPAREN param RPAREN LBRACE body RBRACE
    (63) call -> . ID LPAREN callp RPAREN SEMICOLON
    (58) read -> . READ LPAREN var RPAREN SEMICOLON
    (59) print -> . PRINT LPAREN printp SEMICOLON
    (67) if -> . IF LPAREN exp RPAREN quadsIf statements ifelse jumpsIf
    (73) while -> . WHILE LPAREN saveJumps exp RPAREN quadsWhile statements jumpsWhile whilep
    (79) for -> . FOR LPAREN var SEMICOLON exp SEMICOLON exp RPAREN LBRACKET statements forp
    (62) var -> . ID

    RBRACKET        shift and go to state 162
    FUNCTION        shift and go to state 11
    ID              shift and go to state 56
    READ            shift and go to state 57
    PRINT           shift and go to state 58
    IF              shift and go to state 59
    WHILE           shift and go to state 60
    FOR             shift and go to state 61

    statements                     shift and go to state 160
    forp                           shift and go to state 163
    assign                         shift and go to state 46
    function                       shift and go to state 47
    voidfunction                   shift and go to state 48
    call                           shift and go to state 49
    read                           shift and go to state 50
    print                          shift and go to state 51
    if                             shift and go to state 52
    while                          shift and go to state 53
    for                            shift and go to state 54
    var                            shift and go to state 55

state 161

    (79) for -> FOR LPAREN var SEMICOLON exp SEMICOLON exp RPAREN LBRACKET statements forp .

    VAR             reduce using rule 79 (for -> FOR LPAREN var SEMICOLON exp SEMICOLON exp RPAREN LBRACKET statements forp .)
    FUNCTION        reduce using rule 79 (for -> FOR LPAREN var SEMICOLON exp SEMICOLON exp RPAREN LBRACKET statements forp .)
    ID              reduce using rule 79 (for -> FOR LPAREN var SEMICOLON exp SEMICOLON exp RPAREN LBRACKET statements forp .)
    READ            reduce using rule 79 (for -> FOR LPAREN var SEMICOLON exp SEMICOLON exp RPAREN LBRACKET statements forp .)
    PRINT           reduce using rule 79 (for -> FOR LPAREN var SEMICOLON exp SEMICOLON exp RPAREN LBRACKET statements forp .)
    IF              reduce using rule 79 (for -> FOR LPAREN var SEMICOLON exp SEMICOLON exp RPAREN LBRACKET statements forp .)
    WHILE           reduce using rule 79 (for -> FOR LPAREN var SEMICOLON exp SEMICOLON exp RPAREN LBRACKET statements forp .)
    FOR             reduce using rule 79 (for -> FOR LPAREN var SEMICOLON exp SEMICOLON exp RPAREN LBRACKET statements forp .)
    RBRACE          reduce using rule 79 (for -> FOR LPAREN var SEMICOLON exp SEMICOLON exp RPAREN LBRACKET statements forp .)
    RETURN          reduce using rule 79 (for -> FOR LPAREN var SEMICOLON exp SEMICOLON exp RPAREN LBRACKET statements forp .)
    ELSE            reduce using rule 79 (for -> FOR LPAREN var SEMICOLON exp SEMICOLON exp RPAREN LBRACKET statements forp .)
    SEMICOLON       reduce using rule 79 (for -> FOR LPAREN var SEMICOLON exp SEMICOLON exp RPAREN LBRACKET statements forp .)
    RBRACKET        reduce using rule 79 (for -> FOR LPAREN var SEMICOLON exp SEMICOLON exp RPAREN LBRACKET statements forp .)


state 162

    (80) forp -> RBRACKET .

    VAR             reduce using rule 80 (forp -> RBRACKET .)
    FUNCTION        reduce using rule 80 (forp -> RBRACKET .)
    ID              reduce using rule 80 (forp -> RBRACKET .)
    READ            reduce using rule 80 (forp -> RBRACKET .)
    PRINT           reduce using rule 80 (forp -> RBRACKET .)
    IF              reduce using rule 80 (forp -> RBRACKET .)
    WHILE           reduce using rule 80 (forp -> RBRACKET .)
    FOR             reduce using rule 80 (forp -> RBRACKET .)
    RBRACE          reduce using rule 80 (forp -> RBRACKET .)
    RETURN          reduce using rule 80 (forp -> RBRACKET .)
    ELSE            reduce using rule 80 (forp -> RBRACKET .)
    SEMICOLON       reduce using rule 80 (forp -> RBRACKET .)
    RBRACKET        reduce using rule 80 (forp -> RBRACKET .)


state 163

    (81) forp -> statements forp .

    VAR             reduce using rule 81 (forp -> statements forp .)
    FUNCTION        reduce using rule 81 (forp -> statements forp .)
    ID              reduce using rule 81 (forp -> statements forp .)
    READ            reduce using rule 81 (forp -> statements forp .)
    PRINT           reduce using rule 81 (forp -> statements forp .)
    IF              reduce using rule 81 (forp -> statements forp .)
    WHILE           reduce using rule 81 (forp -> statements forp .)
    FOR             reduce using rule 81 (forp -> statements forp .)
    RBRACE          reduce using rule 81 (forp -> statements forp .)
    RETURN          reduce using rule 81 (forp -> statements forp .)
    ELSE            reduce using rule 81 (forp -> statements forp .)
    SEMICOLON       reduce using rule 81 (forp -> statements forp .)
    RBRACKET        reduce using rule 81 (forp -> statements forp .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for FUNCTION in state 39 resolved as shift
WARNING: shift/reduce conflict for ID in state 39 resolved as shift
WARNING: shift/reduce conflict for READ in state 39 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 39 resolved as shift
WARNING: shift/reduce conflict for IF in state 39 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 39 resolved as shift
WARNING: shift/reduce conflict for FOR in state 39 resolved as shift
WARNING: shift/reduce conflict for FUNCTION in state 45 resolved as shift
WARNING: shift/reduce conflict for ID in state 45 resolved as shift
WARNING: shift/reduce conflict for READ in state 45 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 45 resolved as shift
WARNING: shift/reduce conflict for IF in state 45 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 45 resolved as shift
WARNING: shift/reduce conflict for FOR in state 45 resolved as shift
WARNING: shift/reduce conflict for FUNCTION in state 63 resolved as shift
WARNING: shift/reduce conflict for ID in state 63 resolved as shift
WARNING: shift/reduce conflict for READ in state 63 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 63 resolved as shift
WARNING: shift/reduce conflict for IF in state 63 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 63 resolved as shift
WARNING: shift/reduce conflict for FOR in state 63 resolved as shift
WARNING: shift/reduce conflict for FUNCTION in state 64 resolved as shift
WARNING: shift/reduce conflict for ID in state 64 resolved as shift
WARNING: shift/reduce conflict for READ in state 64 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 64 resolved as shift
WARNING: shift/reduce conflict for IF in state 64 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 64 resolved as shift
WARNING: shift/reduce conflict for FOR in state 64 resolved as shift
WARNING: shift/reduce conflict for FUNCTION in state 66 resolved as shift
WARNING: shift/reduce conflict for ID in state 66 resolved as shift
WARNING: shift/reduce conflict for READ in state 66 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 66 resolved as shift
WARNING: shift/reduce conflict for IF in state 66 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 66 resolved as shift
WARNING: shift/reduce conflict for FOR in state 66 resolved as shift
WARNING: shift/reduce conflict for ELSE in state 141 resolved as shift
WARNING: reduce/reduce conflict in state 12 resolved using rule (decvar -> VAR decvarp)
WARNING: rejected rule (decvar -> <empty>) in state 12
WARNING: reduce/reduce conflict in state 39 resolved using rule (decvar -> <empty>)
WARNING: rejected rule (body -> <empty>) in state 39
WARNING: reduce/reduce conflict in state 45 resolved using rule (decvar -> <empty>)
WARNING: rejected rule (body -> <empty>) in state 45
WARNING: reduce/reduce conflict in state 63 resolved using rule (decvar -> <empty>)
WARNING: rejected rule (body -> <empty>) in state 63
WARNING: reduce/reduce conflict in state 64 resolved using rule (decvar -> <empty>)
WARNING: rejected rule (body -> <empty>) in state 64
WARNING: reduce/reduce conflict in state 66 resolved using rule (decvar -> <empty>)
WARNING: rejected rule (body -> <empty>) in state 66
WARNING: Rule (body -> <empty>) is never reduced
