Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    ASSIGN
    CHAR
    COLON
    END
    FUNCESP
    GTE
    LTE
    NUMPY
    QUOTE
    STRING

Grammar

Rule 0     S' -> program
Rule 1     program -> PROGRAM gotomain ID SEMICOLON decvar modules mainfunction
Rule 2     gotomain -> <empty>
Rule 3     decvar -> VAR decvarp
Rule 4     decvar -> VAR decvarp decvar
Rule 5     decvar -> <empty>
Rule 6     decvarp -> type decvarpp SEMICOLON
Rule 7     decvarpp -> ID COMMA decvarpp
Rule 8     decvarpp -> ID
Rule 9     type -> INT
Rule 10    type -> FLOAT
Rule 11    function -> FUNCTION decfunctype decfunc LPAREN param RPAREN LBRACE body RETURN exp SEMICOLON RBRACE
Rule 12    decfunctype -> type
Rule 13    decfunc -> ID
Rule 14    voidfunction -> FUNCTION VOID decfunc LPAREN param RPAREN LBRACE body RBRACE
Rule 15    decfuncmain -> <empty>
Rule 16    mainfunction -> MAIN decfuncmain LPAREN RPAREN LBRACE body RBRACE
Rule 17    modules -> function modules
Rule 18    modules -> voidfunction modules
Rule 19    modules -> function
Rule 20    modules -> voidfunction
Rule 21    body -> decvar statements body
Rule 22    body -> statements body
Rule 23    body -> decvar
Rule 24    body -> <empty>
Rule 25    param -> type ID
Rule 26    param -> type ID COMMA param
Rule 27    param -> <empty>
Rule 28    exp -> texp
Rule 29    exp -> texp OR exp
Rule 30    texp -> gexp
Rule 31    texp -> gexp AND texp
Rule 32    gexp -> mexp
Rule 33    gexp -> mexp gexpp mexp
Rule 34    gexpp -> LT
Rule 35    gexpp -> GT
Rule 36    gexpp -> IFEQUAL
Rule 37    gexpp -> DIFF
Rule 38    mexp -> t
Rule 39    mexp -> mexp PLUS t
Rule 40    mexp -> mexp MINUS t
Rule 41    t -> f
Rule 42    t -> t MULT f
Rule 43    t -> t DIV f
Rule 44    f -> LPAREN exp RPAREN
Rule 45    f -> CTI
Rule 46    f -> CTF
Rule 47    f -> var
Rule 48    f -> call
Rule 49    statements -> assign
Rule 50    statements -> function
Rule 51    statements -> voidfunction
Rule 52    statements -> call
Rule 53    statements -> read
Rule 54    statements -> print
Rule 55    statements -> if
Rule 56    statements -> while
Rule 57    statements -> for
Rule 58    assign -> var EQUAL exp SEMICOLON
Rule 59    read -> READ LPAREN var RPAREN SEMICOLON
Rule 60    print -> PRINT LPAREN printp SEMICOLON
Rule 61    printp -> exp RPAREN
Rule 62    printp -> exp COMMA printp
Rule 63    var -> ID
Rule 64    call -> ID LPAREN callp RPAREN
Rule 65    callp -> exp COMMA callp
Rule 66    callp -> exp
Rule 67    callp -> <empty>
Rule 68    if -> IF LPAREN exp RPAREN quadsIf LBRACE statements RBRACE ifelse jumpsIf SEMICOLON
Rule 69    ifelse -> <empty>
Rule 70    ifelse -> ELSE quadsElse LBRACE statements RBRACE
Rule 71    quadsIf -> <empty>
Rule 72    jumpsIf -> <empty>
Rule 73    quadsElse -> <empty>
Rule 74    while -> WHILE LPAREN saveJumps exp RPAREN quadsWhile statements jumpsWhile whilep
Rule 75    whilep -> SEMICOLON
Rule 76    whilep -> statements whilep
Rule 77    saveJumps -> <empty>
Rule 78    quadsWhile -> <empty>
Rule 79    jumpsWhile -> <empty>
Rule 80    for -> FOR LPAREN var SEMICOLON exp SEMICOLON exp RPAREN LBRACKET statements forp
Rule 81    forp -> RBRACKET
Rule 82    forp -> statements forp
Rule 83    funcesp -> array
Rule 84    funcesp -> matrix
Rule 85    funcesp -> mean
Rule 86    funcesp -> layers
Rule 87    funcesp -> sequential
Rule 88    funcesp -> compile
Rule 89    funcesp -> fit
Rule 90    funcesp -> predict
Rule 91    funcesp -> getweights
Rule 92    array -> ID EQUAL ARRAY LPAREN var arrayp
Rule 93    arrayp -> RPAREN
Rule 94    arrayp -> COMMA var RPAREN
Rule 95    matrix -> ID EQUAL MATRIX LPAREN array matrixp
Rule 96    matrixp -> RPAREN
Rule 97    matrixp -> COMMA array RPAREN
Rule 98    mean -> MEAN LPAREN array RPAREN
Rule 99    layers -> ID EQUAL LAYERS LPAREN UNITS EQUAL INT RPAREN
Rule 100   sequential -> ID EQUAL SEQUENTIAL LPAREN LBRACKET layers sequentialp
Rule 101   sequentialp -> RBRACKET RPAREN
Rule 102   sequentialp -> COMMA layers sequentialp
Rule 103   compile -> sequential DOT COMPILE LPAREN RPAREN
Rule 104   fit -> ID EQUAL sequential DOT FIT LPAREN array COMMA array COMMA EPOCHS EQUAL INT COMMA VERBOSE EQUAL fitp
Rule 105   fitp -> TRUE RPAREN
Rule 106   fitp -> FALSE RPAREN
Rule 107   predict -> ID EQUAL sequential DOT PREDICT LPAREN LBRACKET predictp
Rule 108   predictp -> INT RBRACKET RPAREN
Rule 109   predictp -> FLOAT RBRACKET RPAREN
Rule 110   getweights -> layers DOT GETWEIGHTS LPAREN RPAREN
Rule 111   empty -> <empty>

Terminals, with rules where they appear

AND                  : 31
ARRAY                : 92
ASSIGN               : 
CHAR                 : 
COLON                : 
COMMA                : 7 26 62 65 94 97 102 104 104 104
COMPILE              : 103
CTF                  : 46
CTI                  : 45
DIFF                 : 37
DIV                  : 43
DOT                  : 103 104 107 110
ELSE                 : 70
END                  : 
EPOCHS               : 104
EQUAL                : 58 92 95 99 99 100 104 104 104 107
FALSE                : 106
FIT                  : 104
FLOAT                : 10 109
FOR                  : 80
FUNCESP              : 
FUNCTION             : 11 14
GETWEIGHTS           : 110
GT                   : 35
GTE                  : 
ID                   : 1 7 8 13 25 26 63 64 92 95 99 100 104 107
IF                   : 68
IFEQUAL              : 36
INT                  : 9 99 104 108
LAYERS               : 99
LBRACE               : 11 14 16 68 70
LBRACKET             : 80 100 107
LPAREN               : 11 14 16 44 59 60 64 68 74 80 92 95 98 99 100 103 104 107 110
LT                   : 34
LTE                  : 
MAIN                 : 16
MATRIX               : 95
MEAN                 : 98
MINUS                : 40
MULT                 : 42
NUMPY                : 
OR                   : 29
PLUS                 : 39
PREDICT              : 107
PRINT                : 60
PROGRAM              : 1
QUOTE                : 
RBRACE               : 11 14 16 68 70
RBRACKET             : 81 101 108 109
READ                 : 59
RETURN               : 11
RPAREN               : 11 14 16 44 59 61 64 68 74 80 93 94 96 97 98 99 101 103 105 106 108 109 110
SEMICOLON            : 1 6 11 58 59 60 68 75 80 80
SEQUENTIAL           : 100
STRING               : 
TRUE                 : 105
UNITS                : 99
VAR                  : 3 4
VERBOSE              : 104
VOID                 : 14
WHILE                : 74
error                : 

Nonterminals, with rules where they appear

array                : 83 95 97 98 104 104
arrayp               : 92
assign               : 49
body                 : 11 14 16 21 22
call                 : 48 52
callp                : 64 65
compile              : 88
decfunc              : 11 14
decfuncmain          : 16
decfunctype          : 11
decvar               : 1 4 21 23
decvarp              : 3 4
decvarpp             : 6 7
empty                : 
exp                  : 11 29 44 58 61 62 65 66 68 74 80 80
f                    : 41 42 43
fit                  : 89
fitp                 : 104
for                  : 57
forp                 : 80 82
funcesp              : 
function             : 17 19 50
getweights           : 91
gexp                 : 30 31
gexpp                : 33
gotomain             : 1
if                   : 55
ifelse               : 68
jumpsIf              : 68
jumpsWhile           : 74
layers               : 86 100 102 110
mainfunction         : 1
matrix               : 84
matrixp              : 95
mean                 : 85
mexp                 : 32 33 33 39 40
modules              : 1 17 18
param                : 11 14 26
predict              : 90
predictp             : 107
print                : 54
printp               : 60 62
program              : 0
quadsElse            : 70
quadsIf              : 68
quadsWhile           : 74
read                 : 53
saveJumps            : 74
sequential           : 87 103 104 107
sequentialp          : 100 102
statements           : 21 22 68 70 74 76 80 82
t                    : 38 39 40 42 43
texp                 : 28 29 31
type                 : 6 12 25 26
var                  : 47 58 59 80 92 94
voidfunction         : 18 20 51
while                : 56
whilep               : 74 76

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . PROGRAM gotomain ID SEMICOLON decvar modules mainfunction

    PROGRAM         shift and go to state 2

    program                        shift and go to state 1

state 1

    (0) S' -> program .



state 2

    (1) program -> PROGRAM . gotomain ID SEMICOLON decvar modules mainfunction
    (2) gotomain -> .

    ID              reduce using rule 2 (gotomain -> .)

    gotomain                       shift and go to state 3

state 3

    (1) program -> PROGRAM gotomain . ID SEMICOLON decvar modules mainfunction

    ID              shift and go to state 4


state 4

    (1) program -> PROGRAM gotomain ID . SEMICOLON decvar modules mainfunction

    SEMICOLON       shift and go to state 5


state 5

    (1) program -> PROGRAM gotomain ID SEMICOLON . decvar modules mainfunction
    (3) decvar -> . VAR decvarp
    (4) decvar -> . VAR decvarp decvar
    (5) decvar -> .

    VAR             shift and go to state 7
    FUNCTION        reduce using rule 5 (decvar -> .)

    decvar                         shift and go to state 6

state 6

    (1) program -> PROGRAM gotomain ID SEMICOLON decvar . modules mainfunction
    (17) modules -> . function modules
    (18) modules -> . voidfunction modules
    (19) modules -> . function
    (20) modules -> . voidfunction
    (11) function -> . FUNCTION decfunctype decfunc LPAREN param RPAREN LBRACE body RETURN exp SEMICOLON RBRACE
    (14) voidfunction -> . FUNCTION VOID decfunc LPAREN param RPAREN LBRACE body RBRACE

    FUNCTION        shift and go to state 11

    modules                        shift and go to state 8
    function                       shift and go to state 9
    voidfunction                   shift and go to state 10

state 7

    (3) decvar -> VAR . decvarp
    (4) decvar -> VAR . decvarp decvar
    (6) decvarp -> . type decvarpp SEMICOLON
    (9) type -> . INT
    (10) type -> . FLOAT

    INT             shift and go to state 14
    FLOAT           shift and go to state 15

    decvarp                        shift and go to state 12
    type                           shift and go to state 13

state 8

    (1) program -> PROGRAM gotomain ID SEMICOLON decvar modules . mainfunction
    (16) mainfunction -> . MAIN decfuncmain LPAREN RPAREN LBRACE body RBRACE

    MAIN            shift and go to state 17

    mainfunction                   shift and go to state 16

state 9

    (17) modules -> function . modules
    (19) modules -> function .
    (17) modules -> . function modules
    (18) modules -> . voidfunction modules
    (19) modules -> . function
    (20) modules -> . voidfunction
    (11) function -> . FUNCTION decfunctype decfunc LPAREN param RPAREN LBRACE body RETURN exp SEMICOLON RBRACE
    (14) voidfunction -> . FUNCTION VOID decfunc LPAREN param RPAREN LBRACE body RBRACE

    MAIN            reduce using rule 19 (modules -> function .)
    FUNCTION        shift and go to state 11

    function                       shift and go to state 9
    modules                        shift and go to state 18
    voidfunction                   shift and go to state 10

state 10

    (18) modules -> voidfunction . modules
    (20) modules -> voidfunction .
    (17) modules -> . function modules
    (18) modules -> . voidfunction modules
    (19) modules -> . function
    (20) modules -> . voidfunction
    (11) function -> . FUNCTION decfunctype decfunc LPAREN param RPAREN LBRACE body RETURN exp SEMICOLON RBRACE
    (14) voidfunction -> . FUNCTION VOID decfunc LPAREN param RPAREN LBRACE body RBRACE

    MAIN            reduce using rule 20 (modules -> voidfunction .)
    FUNCTION        shift and go to state 11

    voidfunction                   shift and go to state 10
    modules                        shift and go to state 19
    function                       shift and go to state 9

state 11

    (11) function -> FUNCTION . decfunctype decfunc LPAREN param RPAREN LBRACE body RETURN exp SEMICOLON RBRACE
    (14) voidfunction -> FUNCTION . VOID decfunc LPAREN param RPAREN LBRACE body RBRACE
    (12) decfunctype -> . type
    (9) type -> . INT
    (10) type -> . FLOAT

    VOID            shift and go to state 21
    INT             shift and go to state 14
    FLOAT           shift and go to state 15

    decfunctype                    shift and go to state 20
    type                           shift and go to state 22

state 12

    (3) decvar -> VAR decvarp .
    (4) decvar -> VAR decvarp . decvar
    (3) decvar -> . VAR decvarp
    (4) decvar -> . VAR decvarp decvar
    (5) decvar -> .

  ! reduce/reduce conflict for FUNCTION resolved using rule 3 (decvar -> VAR decvarp .)
  ! reduce/reduce conflict for ID resolved using rule 3 (decvar -> VAR decvarp .)
  ! reduce/reduce conflict for READ resolved using rule 3 (decvar -> VAR decvarp .)
  ! reduce/reduce conflict for PRINT resolved using rule 3 (decvar -> VAR decvarp .)
  ! reduce/reduce conflict for IF resolved using rule 3 (decvar -> VAR decvarp .)
  ! reduce/reduce conflict for WHILE resolved using rule 3 (decvar -> VAR decvarp .)
  ! reduce/reduce conflict for FOR resolved using rule 3 (decvar -> VAR decvarp .)
  ! reduce/reduce conflict for RBRACE resolved using rule 3 (decvar -> VAR decvarp .)
  ! reduce/reduce conflict for RETURN resolved using rule 3 (decvar -> VAR decvarp .)
    FUNCTION        reduce using rule 3 (decvar -> VAR decvarp .)
    ID              reduce using rule 3 (decvar -> VAR decvarp .)
    READ            reduce using rule 3 (decvar -> VAR decvarp .)
    PRINT           reduce using rule 3 (decvar -> VAR decvarp .)
    IF              reduce using rule 3 (decvar -> VAR decvarp .)
    WHILE           reduce using rule 3 (decvar -> VAR decvarp .)
    FOR             reduce using rule 3 (decvar -> VAR decvarp .)
    RBRACE          reduce using rule 3 (decvar -> VAR decvarp .)
    RETURN          reduce using rule 3 (decvar -> VAR decvarp .)
    VAR             shift and go to state 7

  ! FUNCTION        [ reduce using rule 5 (decvar -> .) ]
  ! ID              [ reduce using rule 5 (decvar -> .) ]
  ! READ            [ reduce using rule 5 (decvar -> .) ]
  ! PRINT           [ reduce using rule 5 (decvar -> .) ]
  ! IF              [ reduce using rule 5 (decvar -> .) ]
  ! WHILE           [ reduce using rule 5 (decvar -> .) ]
  ! FOR             [ reduce using rule 5 (decvar -> .) ]
  ! RBRACE          [ reduce using rule 5 (decvar -> .) ]
  ! RETURN          [ reduce using rule 5 (decvar -> .) ]

    decvar                         shift and go to state 23

state 13

    (6) decvarp -> type . decvarpp SEMICOLON
    (7) decvarpp -> . ID COMMA decvarpp
    (8) decvarpp -> . ID

    ID              shift and go to state 25

    decvarpp                       shift and go to state 24

state 14

    (9) type -> INT .

    ID              reduce using rule 9 (type -> INT .)


state 15

    (10) type -> FLOAT .

    ID              reduce using rule 10 (type -> FLOAT .)


state 16

    (1) program -> PROGRAM gotomain ID SEMICOLON decvar modules mainfunction .

    $end            reduce using rule 1 (program -> PROGRAM gotomain ID SEMICOLON decvar modules mainfunction .)


state 17

    (16) mainfunction -> MAIN . decfuncmain LPAREN RPAREN LBRACE body RBRACE
    (15) decfuncmain -> .

    LPAREN          reduce using rule 15 (decfuncmain -> .)

    decfuncmain                    shift and go to state 26

state 18

    (17) modules -> function modules .

    MAIN            reduce using rule 17 (modules -> function modules .)


state 19

    (18) modules -> voidfunction modules .

    MAIN            reduce using rule 18 (modules -> voidfunction modules .)


state 20

    (11) function -> FUNCTION decfunctype . decfunc LPAREN param RPAREN LBRACE body RETURN exp SEMICOLON RBRACE
    (13) decfunc -> . ID

    ID              shift and go to state 28

    decfunc                        shift and go to state 27

state 21

    (14) voidfunction -> FUNCTION VOID . decfunc LPAREN param RPAREN LBRACE body RBRACE
    (13) decfunc -> . ID

    ID              shift and go to state 28

    decfunc                        shift and go to state 29

state 22

    (12) decfunctype -> type .

    ID              reduce using rule 12 (decfunctype -> type .)


state 23

    (4) decvar -> VAR decvarp decvar .

    FUNCTION        reduce using rule 4 (decvar -> VAR decvarp decvar .)
    ID              reduce using rule 4 (decvar -> VAR decvarp decvar .)
    READ            reduce using rule 4 (decvar -> VAR decvarp decvar .)
    PRINT           reduce using rule 4 (decvar -> VAR decvarp decvar .)
    IF              reduce using rule 4 (decvar -> VAR decvarp decvar .)
    WHILE           reduce using rule 4 (decvar -> VAR decvarp decvar .)
    FOR             reduce using rule 4 (decvar -> VAR decvarp decvar .)
    RBRACE          reduce using rule 4 (decvar -> VAR decvarp decvar .)
    RETURN          reduce using rule 4 (decvar -> VAR decvarp decvar .)


state 24

    (6) decvarp -> type decvarpp . SEMICOLON

    SEMICOLON       shift and go to state 30


state 25

    (7) decvarpp -> ID . COMMA decvarpp
    (8) decvarpp -> ID .

    COMMA           shift and go to state 31
    SEMICOLON       reduce using rule 8 (decvarpp -> ID .)


state 26

    (16) mainfunction -> MAIN decfuncmain . LPAREN RPAREN LBRACE body RBRACE

    LPAREN          shift and go to state 32


state 27

    (11) function -> FUNCTION decfunctype decfunc . LPAREN param RPAREN LBRACE body RETURN exp SEMICOLON RBRACE

    LPAREN          shift and go to state 33


state 28

    (13) decfunc -> ID .

    LPAREN          reduce using rule 13 (decfunc -> ID .)


state 29

    (14) voidfunction -> FUNCTION VOID decfunc . LPAREN param RPAREN LBRACE body RBRACE

    LPAREN          shift and go to state 34


state 30

    (6) decvarp -> type decvarpp SEMICOLON .

    VAR             reduce using rule 6 (decvarp -> type decvarpp SEMICOLON .)
    FUNCTION        reduce using rule 6 (decvarp -> type decvarpp SEMICOLON .)
    ID              reduce using rule 6 (decvarp -> type decvarpp SEMICOLON .)
    READ            reduce using rule 6 (decvarp -> type decvarpp SEMICOLON .)
    PRINT           reduce using rule 6 (decvarp -> type decvarpp SEMICOLON .)
    IF              reduce using rule 6 (decvarp -> type decvarpp SEMICOLON .)
    WHILE           reduce using rule 6 (decvarp -> type decvarpp SEMICOLON .)
    FOR             reduce using rule 6 (decvarp -> type decvarpp SEMICOLON .)
    RBRACE          reduce using rule 6 (decvarp -> type decvarpp SEMICOLON .)
    RETURN          reduce using rule 6 (decvarp -> type decvarpp SEMICOLON .)


state 31

    (7) decvarpp -> ID COMMA . decvarpp
    (7) decvarpp -> . ID COMMA decvarpp
    (8) decvarpp -> . ID

    ID              shift and go to state 25

    decvarpp                       shift and go to state 35

state 32

    (16) mainfunction -> MAIN decfuncmain LPAREN . RPAREN LBRACE body RBRACE

    RPAREN          shift and go to state 36


state 33

    (11) function -> FUNCTION decfunctype decfunc LPAREN . param RPAREN LBRACE body RETURN exp SEMICOLON RBRACE
    (25) param -> . type ID
    (26) param -> . type ID COMMA param
    (27) param -> .
    (9) type -> . INT
    (10) type -> . FLOAT

    RPAREN          reduce using rule 27 (param -> .)
    INT             shift and go to state 14
    FLOAT           shift and go to state 15

    param                          shift and go to state 37
    type                           shift and go to state 38

state 34

    (14) voidfunction -> FUNCTION VOID decfunc LPAREN . param RPAREN LBRACE body RBRACE
    (25) param -> . type ID
    (26) param -> . type ID COMMA param
    (27) param -> .
    (9) type -> . INT
    (10) type -> . FLOAT

    RPAREN          reduce using rule 27 (param -> .)
    INT             shift and go to state 14
    FLOAT           shift and go to state 15

    param                          shift and go to state 39
    type                           shift and go to state 38

state 35

    (7) decvarpp -> ID COMMA decvarpp .

    SEMICOLON       reduce using rule 7 (decvarpp -> ID COMMA decvarpp .)


state 36

    (16) mainfunction -> MAIN decfuncmain LPAREN RPAREN . LBRACE body RBRACE

    LBRACE          shift and go to state 40


state 37

    (11) function -> FUNCTION decfunctype decfunc LPAREN param . RPAREN LBRACE body RETURN exp SEMICOLON RBRACE

    RPAREN          shift and go to state 41


state 38

    (25) param -> type . ID
    (26) param -> type . ID COMMA param

    ID              shift and go to state 42


state 39

    (14) voidfunction -> FUNCTION VOID decfunc LPAREN param . RPAREN LBRACE body RBRACE

    RPAREN          shift and go to state 43


state 40

    (16) mainfunction -> MAIN decfuncmain LPAREN RPAREN LBRACE . body RBRACE
    (21) body -> . decvar statements body
    (22) body -> . statements body
    (23) body -> . decvar
    (24) body -> .
    (3) decvar -> . VAR decvarp
    (4) decvar -> . VAR decvarp decvar
    (5) decvar -> .
    (49) statements -> . assign
    (50) statements -> . function
    (51) statements -> . voidfunction
    (52) statements -> . call
    (53) statements -> . read
    (54) statements -> . print
    (55) statements -> . if
    (56) statements -> . while
    (57) statements -> . for
    (58) assign -> . var EQUAL exp SEMICOLON
    (11) function -> . FUNCTION decfunctype decfunc LPAREN param RPAREN LBRACE body RETURN exp SEMICOLON RBRACE
    (14) voidfunction -> . FUNCTION VOID decfunc LPAREN param RPAREN LBRACE body RBRACE
    (64) call -> . ID LPAREN callp RPAREN
    (59) read -> . READ LPAREN var RPAREN SEMICOLON
    (60) print -> . PRINT LPAREN printp SEMICOLON
    (68) if -> . IF LPAREN exp RPAREN quadsIf LBRACE statements RBRACE ifelse jumpsIf SEMICOLON
    (74) while -> . WHILE LPAREN saveJumps exp RPAREN quadsWhile statements jumpsWhile whilep
    (80) for -> . FOR LPAREN var SEMICOLON exp SEMICOLON exp RPAREN LBRACKET statements forp
    (63) var -> . ID

  ! reduce/reduce conflict for RBRACE resolved using rule 5 (decvar -> .)
  ! shift/reduce conflict for FUNCTION resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for READ resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
    VAR             shift and go to state 7
    RBRACE          reduce using rule 5 (decvar -> .)
    FUNCTION        shift and go to state 11
    ID              shift and go to state 57
    READ            shift and go to state 58
    PRINT           shift and go to state 59
    IF              shift and go to state 60
    WHILE           shift and go to state 61
    FOR             shift and go to state 62

  ! RBRACE          [ reduce using rule 24 (body -> .) ]
  ! FUNCTION        [ reduce using rule 5 (decvar -> .) ]
  ! ID              [ reduce using rule 5 (decvar -> .) ]
  ! READ            [ reduce using rule 5 (decvar -> .) ]
  ! PRINT           [ reduce using rule 5 (decvar -> .) ]
  ! IF              [ reduce using rule 5 (decvar -> .) ]
  ! WHILE           [ reduce using rule 5 (decvar -> .) ]
  ! FOR             [ reduce using rule 5 (decvar -> .) ]

    body                           shift and go to state 44
    decvar                         shift and go to state 45
    statements                     shift and go to state 46
    assign                         shift and go to state 47
    function                       shift and go to state 48
    voidfunction                   shift and go to state 49
    call                           shift and go to state 50
    read                           shift and go to state 51
    print                          shift and go to state 52
    if                             shift and go to state 53
    while                          shift and go to state 54
    for                            shift and go to state 55
    var                            shift and go to state 56

state 41

    (11) function -> FUNCTION decfunctype decfunc LPAREN param RPAREN . LBRACE body RETURN exp SEMICOLON RBRACE

    LBRACE          shift and go to state 63


state 42

    (25) param -> type ID .
    (26) param -> type ID . COMMA param

    RPAREN          reduce using rule 25 (param -> type ID .)
    COMMA           shift and go to state 64


state 43

    (14) voidfunction -> FUNCTION VOID decfunc LPAREN param RPAREN . LBRACE body RBRACE

    LBRACE          shift and go to state 65


state 44

    (16) mainfunction -> MAIN decfuncmain LPAREN RPAREN LBRACE body . RBRACE

    RBRACE          shift and go to state 66


state 45

    (21) body -> decvar . statements body
    (23) body -> decvar .
    (49) statements -> . assign
    (50) statements -> . function
    (51) statements -> . voidfunction
    (52) statements -> . call
    (53) statements -> . read
    (54) statements -> . print
    (55) statements -> . if
    (56) statements -> . while
    (57) statements -> . for
    (58) assign -> . var EQUAL exp SEMICOLON
    (11) function -> . FUNCTION decfunctype decfunc LPAREN param RPAREN LBRACE body RETURN exp SEMICOLON RBRACE
    (14) voidfunction -> . FUNCTION VOID decfunc LPAREN param RPAREN LBRACE body RBRACE
    (64) call -> . ID LPAREN callp RPAREN
    (59) read -> . READ LPAREN var RPAREN SEMICOLON
    (60) print -> . PRINT LPAREN printp SEMICOLON
    (68) if -> . IF LPAREN exp RPAREN quadsIf LBRACE statements RBRACE ifelse jumpsIf SEMICOLON
    (74) while -> . WHILE LPAREN saveJumps exp RPAREN quadsWhile statements jumpsWhile whilep
    (80) for -> . FOR LPAREN var SEMICOLON exp SEMICOLON exp RPAREN LBRACKET statements forp
    (63) var -> . ID

    RBRACE          reduce using rule 23 (body -> decvar .)
    RETURN          reduce using rule 23 (body -> decvar .)
    FUNCTION        shift and go to state 11
    ID              shift and go to state 57
    READ            shift and go to state 58
    PRINT           shift and go to state 59
    IF              shift and go to state 60
    WHILE           shift and go to state 61
    FOR             shift and go to state 62

    statements                     shift and go to state 67
    assign                         shift and go to state 47
    function                       shift and go to state 48
    voidfunction                   shift and go to state 49
    call                           shift and go to state 50
    read                           shift and go to state 51
    print                          shift and go to state 52
    if                             shift and go to state 53
    while                          shift and go to state 54
    for                            shift and go to state 55
    var                            shift and go to state 56

state 46

    (22) body -> statements . body
    (21) body -> . decvar statements body
    (22) body -> . statements body
    (23) body -> . decvar
    (24) body -> .
    (3) decvar -> . VAR decvarp
    (4) decvar -> . VAR decvarp decvar
    (5) decvar -> .
    (49) statements -> . assign
    (50) statements -> . function
    (51) statements -> . voidfunction
    (52) statements -> . call
    (53) statements -> . read
    (54) statements -> . print
    (55) statements -> . if
    (56) statements -> . while
    (57) statements -> . for
    (58) assign -> . var EQUAL exp SEMICOLON
    (11) function -> . FUNCTION decfunctype decfunc LPAREN param RPAREN LBRACE body RETURN exp SEMICOLON RBRACE
    (14) voidfunction -> . FUNCTION VOID decfunc LPAREN param RPAREN LBRACE body RBRACE
    (64) call -> . ID LPAREN callp RPAREN
    (59) read -> . READ LPAREN var RPAREN SEMICOLON
    (60) print -> . PRINT LPAREN printp SEMICOLON
    (68) if -> . IF LPAREN exp RPAREN quadsIf LBRACE statements RBRACE ifelse jumpsIf SEMICOLON
    (74) while -> . WHILE LPAREN saveJumps exp RPAREN quadsWhile statements jumpsWhile whilep
    (80) for -> . FOR LPAREN var SEMICOLON exp SEMICOLON exp RPAREN LBRACKET statements forp
    (63) var -> . ID

  ! reduce/reduce conflict for RBRACE resolved using rule 5 (decvar -> .)
  ! reduce/reduce conflict for RETURN resolved using rule 5 (decvar -> .)
  ! shift/reduce conflict for FUNCTION resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for READ resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
    VAR             shift and go to state 7
    RBRACE          reduce using rule 5 (decvar -> .)
    RETURN          reduce using rule 5 (decvar -> .)
    FUNCTION        shift and go to state 11
    ID              shift and go to state 57
    READ            shift and go to state 58
    PRINT           shift and go to state 59
    IF              shift and go to state 60
    WHILE           shift and go to state 61
    FOR             shift and go to state 62

  ! RBRACE          [ reduce using rule 24 (body -> .) ]
  ! RETURN          [ reduce using rule 24 (body -> .) ]
  ! FUNCTION        [ reduce using rule 5 (decvar -> .) ]
  ! ID              [ reduce using rule 5 (decvar -> .) ]
  ! READ            [ reduce using rule 5 (decvar -> .) ]
  ! PRINT           [ reduce using rule 5 (decvar -> .) ]
  ! IF              [ reduce using rule 5 (decvar -> .) ]
  ! WHILE           [ reduce using rule 5 (decvar -> .) ]
  ! FOR             [ reduce using rule 5 (decvar -> .) ]

    statements                     shift and go to state 46
    body                           shift and go to state 68
    decvar                         shift and go to state 45
    assign                         shift and go to state 47
    function                       shift and go to state 48
    voidfunction                   shift and go to state 49
    call                           shift and go to state 50
    read                           shift and go to state 51
    print                          shift and go to state 52
    if                             shift and go to state 53
    while                          shift and go to state 54
    for                            shift and go to state 55
    var                            shift and go to state 56

state 47

    (49) statements -> assign .

    VAR             reduce using rule 49 (statements -> assign .)
    FUNCTION        reduce using rule 49 (statements -> assign .)
    ID              reduce using rule 49 (statements -> assign .)
    READ            reduce using rule 49 (statements -> assign .)
    PRINT           reduce using rule 49 (statements -> assign .)
    IF              reduce using rule 49 (statements -> assign .)
    WHILE           reduce using rule 49 (statements -> assign .)
    FOR             reduce using rule 49 (statements -> assign .)
    RBRACE          reduce using rule 49 (statements -> assign .)
    RETURN          reduce using rule 49 (statements -> assign .)
    SEMICOLON       reduce using rule 49 (statements -> assign .)
    RBRACKET        reduce using rule 49 (statements -> assign .)


state 48

    (50) statements -> function .

    VAR             reduce using rule 50 (statements -> function .)
    FUNCTION        reduce using rule 50 (statements -> function .)
    ID              reduce using rule 50 (statements -> function .)
    READ            reduce using rule 50 (statements -> function .)
    PRINT           reduce using rule 50 (statements -> function .)
    IF              reduce using rule 50 (statements -> function .)
    WHILE           reduce using rule 50 (statements -> function .)
    FOR             reduce using rule 50 (statements -> function .)
    RBRACE          reduce using rule 50 (statements -> function .)
    RETURN          reduce using rule 50 (statements -> function .)
    SEMICOLON       reduce using rule 50 (statements -> function .)
    RBRACKET        reduce using rule 50 (statements -> function .)


state 49

    (51) statements -> voidfunction .

    VAR             reduce using rule 51 (statements -> voidfunction .)
    FUNCTION        reduce using rule 51 (statements -> voidfunction .)
    ID              reduce using rule 51 (statements -> voidfunction .)
    READ            reduce using rule 51 (statements -> voidfunction .)
    PRINT           reduce using rule 51 (statements -> voidfunction .)
    IF              reduce using rule 51 (statements -> voidfunction .)
    WHILE           reduce using rule 51 (statements -> voidfunction .)
    FOR             reduce using rule 51 (statements -> voidfunction .)
    RBRACE          reduce using rule 51 (statements -> voidfunction .)
    RETURN          reduce using rule 51 (statements -> voidfunction .)
    SEMICOLON       reduce using rule 51 (statements -> voidfunction .)
    RBRACKET        reduce using rule 51 (statements -> voidfunction .)


state 50

    (52) statements -> call .

    VAR             reduce using rule 52 (statements -> call .)
    FUNCTION        reduce using rule 52 (statements -> call .)
    ID              reduce using rule 52 (statements -> call .)
    READ            reduce using rule 52 (statements -> call .)
    PRINT           reduce using rule 52 (statements -> call .)
    IF              reduce using rule 52 (statements -> call .)
    WHILE           reduce using rule 52 (statements -> call .)
    FOR             reduce using rule 52 (statements -> call .)
    RBRACE          reduce using rule 52 (statements -> call .)
    RETURN          reduce using rule 52 (statements -> call .)
    SEMICOLON       reduce using rule 52 (statements -> call .)
    RBRACKET        reduce using rule 52 (statements -> call .)


state 51

    (53) statements -> read .

    VAR             reduce using rule 53 (statements -> read .)
    FUNCTION        reduce using rule 53 (statements -> read .)
    ID              reduce using rule 53 (statements -> read .)
    READ            reduce using rule 53 (statements -> read .)
    PRINT           reduce using rule 53 (statements -> read .)
    IF              reduce using rule 53 (statements -> read .)
    WHILE           reduce using rule 53 (statements -> read .)
    FOR             reduce using rule 53 (statements -> read .)
    RBRACE          reduce using rule 53 (statements -> read .)
    RETURN          reduce using rule 53 (statements -> read .)
    SEMICOLON       reduce using rule 53 (statements -> read .)
    RBRACKET        reduce using rule 53 (statements -> read .)


state 52

    (54) statements -> print .

    VAR             reduce using rule 54 (statements -> print .)
    FUNCTION        reduce using rule 54 (statements -> print .)
    ID              reduce using rule 54 (statements -> print .)
    READ            reduce using rule 54 (statements -> print .)
    PRINT           reduce using rule 54 (statements -> print .)
    IF              reduce using rule 54 (statements -> print .)
    WHILE           reduce using rule 54 (statements -> print .)
    FOR             reduce using rule 54 (statements -> print .)
    RBRACE          reduce using rule 54 (statements -> print .)
    RETURN          reduce using rule 54 (statements -> print .)
    SEMICOLON       reduce using rule 54 (statements -> print .)
    RBRACKET        reduce using rule 54 (statements -> print .)


state 53

    (55) statements -> if .

    VAR             reduce using rule 55 (statements -> if .)
    FUNCTION        reduce using rule 55 (statements -> if .)
    ID              reduce using rule 55 (statements -> if .)
    READ            reduce using rule 55 (statements -> if .)
    PRINT           reduce using rule 55 (statements -> if .)
    IF              reduce using rule 55 (statements -> if .)
    WHILE           reduce using rule 55 (statements -> if .)
    FOR             reduce using rule 55 (statements -> if .)
    RBRACE          reduce using rule 55 (statements -> if .)
    RETURN          reduce using rule 55 (statements -> if .)
    SEMICOLON       reduce using rule 55 (statements -> if .)
    RBRACKET        reduce using rule 55 (statements -> if .)


state 54

    (56) statements -> while .

    VAR             reduce using rule 56 (statements -> while .)
    FUNCTION        reduce using rule 56 (statements -> while .)
    ID              reduce using rule 56 (statements -> while .)
    READ            reduce using rule 56 (statements -> while .)
    PRINT           reduce using rule 56 (statements -> while .)
    IF              reduce using rule 56 (statements -> while .)
    WHILE           reduce using rule 56 (statements -> while .)
    FOR             reduce using rule 56 (statements -> while .)
    RBRACE          reduce using rule 56 (statements -> while .)
    RETURN          reduce using rule 56 (statements -> while .)
    SEMICOLON       reduce using rule 56 (statements -> while .)
    RBRACKET        reduce using rule 56 (statements -> while .)


state 55

    (57) statements -> for .

    VAR             reduce using rule 57 (statements -> for .)
    FUNCTION        reduce using rule 57 (statements -> for .)
    ID              reduce using rule 57 (statements -> for .)
    READ            reduce using rule 57 (statements -> for .)
    PRINT           reduce using rule 57 (statements -> for .)
    IF              reduce using rule 57 (statements -> for .)
    WHILE           reduce using rule 57 (statements -> for .)
    FOR             reduce using rule 57 (statements -> for .)
    RBRACE          reduce using rule 57 (statements -> for .)
    RETURN          reduce using rule 57 (statements -> for .)
    SEMICOLON       reduce using rule 57 (statements -> for .)
    RBRACKET        reduce using rule 57 (statements -> for .)


state 56

    (58) assign -> var . EQUAL exp SEMICOLON

    EQUAL           shift and go to state 69


state 57

    (64) call -> ID . LPAREN callp RPAREN
    (63) var -> ID .

    LPAREN          shift and go to state 70
    EQUAL           reduce using rule 63 (var -> ID .)


state 58

    (59) read -> READ . LPAREN var RPAREN SEMICOLON

    LPAREN          shift and go to state 71


state 59

    (60) print -> PRINT . LPAREN printp SEMICOLON

    LPAREN          shift and go to state 72


state 60

    (68) if -> IF . LPAREN exp RPAREN quadsIf LBRACE statements RBRACE ifelse jumpsIf SEMICOLON

    LPAREN          shift and go to state 73


state 61

    (74) while -> WHILE . LPAREN saveJumps exp RPAREN quadsWhile statements jumpsWhile whilep

    LPAREN          shift and go to state 74


state 62

    (80) for -> FOR . LPAREN var SEMICOLON exp SEMICOLON exp RPAREN LBRACKET statements forp

    LPAREN          shift and go to state 75


state 63

    (11) function -> FUNCTION decfunctype decfunc LPAREN param RPAREN LBRACE . body RETURN exp SEMICOLON RBRACE
    (21) body -> . decvar statements body
    (22) body -> . statements body
    (23) body -> . decvar
    (24) body -> .
    (3) decvar -> . VAR decvarp
    (4) decvar -> . VAR decvarp decvar
    (5) decvar -> .
    (49) statements -> . assign
    (50) statements -> . function
    (51) statements -> . voidfunction
    (52) statements -> . call
    (53) statements -> . read
    (54) statements -> . print
    (55) statements -> . if
    (56) statements -> . while
    (57) statements -> . for
    (58) assign -> . var EQUAL exp SEMICOLON
    (11) function -> . FUNCTION decfunctype decfunc LPAREN param RPAREN LBRACE body RETURN exp SEMICOLON RBRACE
    (14) voidfunction -> . FUNCTION VOID decfunc LPAREN param RPAREN LBRACE body RBRACE
    (64) call -> . ID LPAREN callp RPAREN
    (59) read -> . READ LPAREN var RPAREN SEMICOLON
    (60) print -> . PRINT LPAREN printp SEMICOLON
    (68) if -> . IF LPAREN exp RPAREN quadsIf LBRACE statements RBRACE ifelse jumpsIf SEMICOLON
    (74) while -> . WHILE LPAREN saveJumps exp RPAREN quadsWhile statements jumpsWhile whilep
    (80) for -> . FOR LPAREN var SEMICOLON exp SEMICOLON exp RPAREN LBRACKET statements forp
    (63) var -> . ID

  ! reduce/reduce conflict for RETURN resolved using rule 5 (decvar -> .)
  ! shift/reduce conflict for FUNCTION resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for READ resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
    VAR             shift and go to state 7
    RETURN          reduce using rule 5 (decvar -> .)
    FUNCTION        shift and go to state 11
    ID              shift and go to state 57
    READ            shift and go to state 58
    PRINT           shift and go to state 59
    IF              shift and go to state 60
    WHILE           shift and go to state 61
    FOR             shift and go to state 62

  ! RETURN          [ reduce using rule 24 (body -> .) ]
  ! FUNCTION        [ reduce using rule 5 (decvar -> .) ]
  ! ID              [ reduce using rule 5 (decvar -> .) ]
  ! READ            [ reduce using rule 5 (decvar -> .) ]
  ! PRINT           [ reduce using rule 5 (decvar -> .) ]
  ! IF              [ reduce using rule 5 (decvar -> .) ]
  ! WHILE           [ reduce using rule 5 (decvar -> .) ]
  ! FOR             [ reduce using rule 5 (decvar -> .) ]

    body                           shift and go to state 76
    decvar                         shift and go to state 45
    statements                     shift and go to state 46
    assign                         shift and go to state 47
    function                       shift and go to state 48
    voidfunction                   shift and go to state 49
    call                           shift and go to state 50
    read                           shift and go to state 51
    print                          shift and go to state 52
    if                             shift and go to state 53
    while                          shift and go to state 54
    for                            shift and go to state 55
    var                            shift and go to state 56

state 64

    (26) param -> type ID COMMA . param
    (25) param -> . type ID
    (26) param -> . type ID COMMA param
    (27) param -> .
    (9) type -> . INT
    (10) type -> . FLOAT

    RPAREN          reduce using rule 27 (param -> .)
    INT             shift and go to state 14
    FLOAT           shift and go to state 15

    type                           shift and go to state 38
    param                          shift and go to state 77

state 65

    (14) voidfunction -> FUNCTION VOID decfunc LPAREN param RPAREN LBRACE . body RBRACE
    (21) body -> . decvar statements body
    (22) body -> . statements body
    (23) body -> . decvar
    (24) body -> .
    (3) decvar -> . VAR decvarp
    (4) decvar -> . VAR decvarp decvar
    (5) decvar -> .
    (49) statements -> . assign
    (50) statements -> . function
    (51) statements -> . voidfunction
    (52) statements -> . call
    (53) statements -> . read
    (54) statements -> . print
    (55) statements -> . if
    (56) statements -> . while
    (57) statements -> . for
    (58) assign -> . var EQUAL exp SEMICOLON
    (11) function -> . FUNCTION decfunctype decfunc LPAREN param RPAREN LBRACE body RETURN exp SEMICOLON RBRACE
    (14) voidfunction -> . FUNCTION VOID decfunc LPAREN param RPAREN LBRACE body RBRACE
    (64) call -> . ID LPAREN callp RPAREN
    (59) read -> . READ LPAREN var RPAREN SEMICOLON
    (60) print -> . PRINT LPAREN printp SEMICOLON
    (68) if -> . IF LPAREN exp RPAREN quadsIf LBRACE statements RBRACE ifelse jumpsIf SEMICOLON
    (74) while -> . WHILE LPAREN saveJumps exp RPAREN quadsWhile statements jumpsWhile whilep
    (80) for -> . FOR LPAREN var SEMICOLON exp SEMICOLON exp RPAREN LBRACKET statements forp
    (63) var -> . ID

  ! reduce/reduce conflict for RBRACE resolved using rule 5 (decvar -> .)
  ! shift/reduce conflict for FUNCTION resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for READ resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
    VAR             shift and go to state 7
    RBRACE          reduce using rule 5 (decvar -> .)
    FUNCTION        shift and go to state 11
    ID              shift and go to state 57
    READ            shift and go to state 58
    PRINT           shift and go to state 59
    IF              shift and go to state 60
    WHILE           shift and go to state 61
    FOR             shift and go to state 62

  ! RBRACE          [ reduce using rule 24 (body -> .) ]
  ! FUNCTION        [ reduce using rule 5 (decvar -> .) ]
  ! ID              [ reduce using rule 5 (decvar -> .) ]
  ! READ            [ reduce using rule 5 (decvar -> .) ]
  ! PRINT           [ reduce using rule 5 (decvar -> .) ]
  ! IF              [ reduce using rule 5 (decvar -> .) ]
  ! WHILE           [ reduce using rule 5 (decvar -> .) ]
  ! FOR             [ reduce using rule 5 (decvar -> .) ]

    body                           shift and go to state 78
    decvar                         shift and go to state 45
    statements                     shift and go to state 46
    assign                         shift and go to state 47
    function                       shift and go to state 48
    voidfunction                   shift and go to state 49
    call                           shift and go to state 50
    read                           shift and go to state 51
    print                          shift and go to state 52
    if                             shift and go to state 53
    while                          shift and go to state 54
    for                            shift and go to state 55
    var                            shift and go to state 56

state 66

    (16) mainfunction -> MAIN decfuncmain LPAREN RPAREN LBRACE body RBRACE .

    $end            reduce using rule 16 (mainfunction -> MAIN decfuncmain LPAREN RPAREN LBRACE body RBRACE .)


state 67

    (21) body -> decvar statements . body
    (21) body -> . decvar statements body
    (22) body -> . statements body
    (23) body -> . decvar
    (24) body -> .
    (3) decvar -> . VAR decvarp
    (4) decvar -> . VAR decvarp decvar
    (5) decvar -> .
    (49) statements -> . assign
    (50) statements -> . function
    (51) statements -> . voidfunction
    (52) statements -> . call
    (53) statements -> . read
    (54) statements -> . print
    (55) statements -> . if
    (56) statements -> . while
    (57) statements -> . for
    (58) assign -> . var EQUAL exp SEMICOLON
    (11) function -> . FUNCTION decfunctype decfunc LPAREN param RPAREN LBRACE body RETURN exp SEMICOLON RBRACE
    (14) voidfunction -> . FUNCTION VOID decfunc LPAREN param RPAREN LBRACE body RBRACE
    (64) call -> . ID LPAREN callp RPAREN
    (59) read -> . READ LPAREN var RPAREN SEMICOLON
    (60) print -> . PRINT LPAREN printp SEMICOLON
    (68) if -> . IF LPAREN exp RPAREN quadsIf LBRACE statements RBRACE ifelse jumpsIf SEMICOLON
    (74) while -> . WHILE LPAREN saveJumps exp RPAREN quadsWhile statements jumpsWhile whilep
    (80) for -> . FOR LPAREN var SEMICOLON exp SEMICOLON exp RPAREN LBRACKET statements forp
    (63) var -> . ID

  ! reduce/reduce conflict for RBRACE resolved using rule 5 (decvar -> .)
  ! reduce/reduce conflict for RETURN resolved using rule 5 (decvar -> .)
  ! shift/reduce conflict for FUNCTION resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for READ resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
    VAR             shift and go to state 7
    RBRACE          reduce using rule 5 (decvar -> .)
    RETURN          reduce using rule 5 (decvar -> .)
    FUNCTION        shift and go to state 11
    ID              shift and go to state 57
    READ            shift and go to state 58
    PRINT           shift and go to state 59
    IF              shift and go to state 60
    WHILE           shift and go to state 61
    FOR             shift and go to state 62

  ! RBRACE          [ reduce using rule 24 (body -> .) ]
  ! RETURN          [ reduce using rule 24 (body -> .) ]
  ! FUNCTION        [ reduce using rule 5 (decvar -> .) ]
  ! ID              [ reduce using rule 5 (decvar -> .) ]
  ! READ            [ reduce using rule 5 (decvar -> .) ]
  ! PRINT           [ reduce using rule 5 (decvar -> .) ]
  ! IF              [ reduce using rule 5 (decvar -> .) ]
  ! WHILE           [ reduce using rule 5 (decvar -> .) ]
  ! FOR             [ reduce using rule 5 (decvar -> .) ]

    decvar                         shift and go to state 45
    statements                     shift and go to state 46
    body                           shift and go to state 79
    assign                         shift and go to state 47
    function                       shift and go to state 48
    voidfunction                   shift and go to state 49
    call                           shift and go to state 50
    read                           shift and go to state 51
    print                          shift and go to state 52
    if                             shift and go to state 53
    while                          shift and go to state 54
    for                            shift and go to state 55
    var                            shift and go to state 56

state 68

    (22) body -> statements body .

    RBRACE          reduce using rule 22 (body -> statements body .)
    RETURN          reduce using rule 22 (body -> statements body .)


state 69

    (58) assign -> var EQUAL . exp SEMICOLON
    (28) exp -> . texp
    (29) exp -> . texp OR exp
    (30) texp -> . gexp
    (31) texp -> . gexp AND texp
    (32) gexp -> . mexp
    (33) gexp -> . mexp gexpp mexp
    (38) mexp -> . t
    (39) mexp -> . mexp PLUS t
    (40) mexp -> . mexp MINUS t
    (41) t -> . f
    (42) t -> . t MULT f
    (43) t -> . t DIV f
    (44) f -> . LPAREN exp RPAREN
    (45) f -> . CTI
    (46) f -> . CTF
    (47) f -> . var
    (48) f -> . call
    (63) var -> . ID
    (64) call -> . ID LPAREN callp RPAREN

    LPAREN          shift and go to state 87
    CTI             shift and go to state 88
    CTF             shift and go to state 89
    ID              shift and go to state 91

    var                            shift and go to state 80
    exp                            shift and go to state 81
    texp                           shift and go to state 82
    gexp                           shift and go to state 83
    mexp                           shift and go to state 84
    t                              shift and go to state 85
    f                              shift and go to state 86
    call                           shift and go to state 90

state 70

    (64) call -> ID LPAREN . callp RPAREN
    (65) callp -> . exp COMMA callp
    (66) callp -> . exp
    (67) callp -> .
    (28) exp -> . texp
    (29) exp -> . texp OR exp
    (30) texp -> . gexp
    (31) texp -> . gexp AND texp
    (32) gexp -> . mexp
    (33) gexp -> . mexp gexpp mexp
    (38) mexp -> . t
    (39) mexp -> . mexp PLUS t
    (40) mexp -> . mexp MINUS t
    (41) t -> . f
    (42) t -> . t MULT f
    (43) t -> . t DIV f
    (44) f -> . LPAREN exp RPAREN
    (45) f -> . CTI
    (46) f -> . CTF
    (47) f -> . var
    (48) f -> . call
    (63) var -> . ID
    (64) call -> . ID LPAREN callp RPAREN

    RPAREN          reduce using rule 67 (callp -> .)
    LPAREN          shift and go to state 87
    CTI             shift and go to state 88
    CTF             shift and go to state 89
    ID              shift and go to state 91

    callp                          shift and go to state 92
    exp                            shift and go to state 93
    texp                           shift and go to state 82
    gexp                           shift and go to state 83
    mexp                           shift and go to state 84
    t                              shift and go to state 85
    f                              shift and go to state 86
    var                            shift and go to state 80
    call                           shift and go to state 90

state 71

    (59) read -> READ LPAREN . var RPAREN SEMICOLON
    (63) var -> . ID

    ID              shift and go to state 95

    var                            shift and go to state 94

state 72

    (60) print -> PRINT LPAREN . printp SEMICOLON
    (61) printp -> . exp RPAREN
    (62) printp -> . exp COMMA printp
    (28) exp -> . texp
    (29) exp -> . texp OR exp
    (30) texp -> . gexp
    (31) texp -> . gexp AND texp
    (32) gexp -> . mexp
    (33) gexp -> . mexp gexpp mexp
    (38) mexp -> . t
    (39) mexp -> . mexp PLUS t
    (40) mexp -> . mexp MINUS t
    (41) t -> . f
    (42) t -> . t MULT f
    (43) t -> . t DIV f
    (44) f -> . LPAREN exp RPAREN
    (45) f -> . CTI
    (46) f -> . CTF
    (47) f -> . var
    (48) f -> . call
    (63) var -> . ID
    (64) call -> . ID LPAREN callp RPAREN

    LPAREN          shift and go to state 87
    CTI             shift and go to state 88
    CTF             shift and go to state 89
    ID              shift and go to state 91

    printp                         shift and go to state 96
    exp                            shift and go to state 97
    texp                           shift and go to state 82
    gexp                           shift and go to state 83
    mexp                           shift and go to state 84
    t                              shift and go to state 85
    f                              shift and go to state 86
    var                            shift and go to state 80
    call                           shift and go to state 90

state 73

    (68) if -> IF LPAREN . exp RPAREN quadsIf LBRACE statements RBRACE ifelse jumpsIf SEMICOLON
    (28) exp -> . texp
    (29) exp -> . texp OR exp
    (30) texp -> . gexp
    (31) texp -> . gexp AND texp
    (32) gexp -> . mexp
    (33) gexp -> . mexp gexpp mexp
    (38) mexp -> . t
    (39) mexp -> . mexp PLUS t
    (40) mexp -> . mexp MINUS t
    (41) t -> . f
    (42) t -> . t MULT f
    (43) t -> . t DIV f
    (44) f -> . LPAREN exp RPAREN
    (45) f -> . CTI
    (46) f -> . CTF
    (47) f -> . var
    (48) f -> . call
    (63) var -> . ID
    (64) call -> . ID LPAREN callp RPAREN

    LPAREN          shift and go to state 87
    CTI             shift and go to state 88
    CTF             shift and go to state 89
    ID              shift and go to state 91

    exp                            shift and go to state 98
    texp                           shift and go to state 82
    gexp                           shift and go to state 83
    mexp                           shift and go to state 84
    t                              shift and go to state 85
    f                              shift and go to state 86
    var                            shift and go to state 80
    call                           shift and go to state 90

state 74

    (74) while -> WHILE LPAREN . saveJumps exp RPAREN quadsWhile statements jumpsWhile whilep
    (77) saveJumps -> .

    LPAREN          reduce using rule 77 (saveJumps -> .)
    CTI             reduce using rule 77 (saveJumps -> .)
    CTF             reduce using rule 77 (saveJumps -> .)
    ID              reduce using rule 77 (saveJumps -> .)

    saveJumps                      shift and go to state 99

state 75

    (80) for -> FOR LPAREN . var SEMICOLON exp SEMICOLON exp RPAREN LBRACKET statements forp
    (63) var -> . ID

    ID              shift and go to state 95

    var                            shift and go to state 100

state 76

    (11) function -> FUNCTION decfunctype decfunc LPAREN param RPAREN LBRACE body . RETURN exp SEMICOLON RBRACE

    RETURN          shift and go to state 101


state 77

    (26) param -> type ID COMMA param .

    RPAREN          reduce using rule 26 (param -> type ID COMMA param .)


state 78

    (14) voidfunction -> FUNCTION VOID decfunc LPAREN param RPAREN LBRACE body . RBRACE

    RBRACE          shift and go to state 102


state 79

    (21) body -> decvar statements body .

    RBRACE          reduce using rule 21 (body -> decvar statements body .)
    RETURN          reduce using rule 21 (body -> decvar statements body .)


state 80

    (47) f -> var .

    MULT            reduce using rule 47 (f -> var .)
    DIV             reduce using rule 47 (f -> var .)
    PLUS            reduce using rule 47 (f -> var .)
    MINUS           reduce using rule 47 (f -> var .)
    LT              reduce using rule 47 (f -> var .)
    GT              reduce using rule 47 (f -> var .)
    IFEQUAL         reduce using rule 47 (f -> var .)
    DIFF            reduce using rule 47 (f -> var .)
    AND             reduce using rule 47 (f -> var .)
    OR              reduce using rule 47 (f -> var .)
    SEMICOLON       reduce using rule 47 (f -> var .)
    COMMA           reduce using rule 47 (f -> var .)
    RPAREN          reduce using rule 47 (f -> var .)


state 81

    (58) assign -> var EQUAL exp . SEMICOLON

    SEMICOLON       shift and go to state 103


state 82

    (28) exp -> texp .
    (29) exp -> texp . OR exp

    SEMICOLON       reduce using rule 28 (exp -> texp .)
    COMMA           reduce using rule 28 (exp -> texp .)
    RPAREN          reduce using rule 28 (exp -> texp .)
    OR              shift and go to state 104


state 83

    (30) texp -> gexp .
    (31) texp -> gexp . AND texp

    OR              reduce using rule 30 (texp -> gexp .)
    SEMICOLON       reduce using rule 30 (texp -> gexp .)
    COMMA           reduce using rule 30 (texp -> gexp .)
    RPAREN          reduce using rule 30 (texp -> gexp .)
    AND             shift and go to state 105


state 84

    (32) gexp -> mexp .
    (33) gexp -> mexp . gexpp mexp
    (39) mexp -> mexp . PLUS t
    (40) mexp -> mexp . MINUS t
    (34) gexpp -> . LT
    (35) gexpp -> . GT
    (36) gexpp -> . IFEQUAL
    (37) gexpp -> . DIFF

    AND             reduce using rule 32 (gexp -> mexp .)
    OR              reduce using rule 32 (gexp -> mexp .)
    SEMICOLON       reduce using rule 32 (gexp -> mexp .)
    COMMA           reduce using rule 32 (gexp -> mexp .)
    RPAREN          reduce using rule 32 (gexp -> mexp .)
    PLUS            shift and go to state 107
    MINUS           shift and go to state 108
    LT              shift and go to state 109
    GT              shift and go to state 110
    IFEQUAL         shift and go to state 111
    DIFF            shift and go to state 112

    gexpp                          shift and go to state 106

state 85

    (38) mexp -> t .
    (42) t -> t . MULT f
    (43) t -> t . DIV f

    PLUS            reduce using rule 38 (mexp -> t .)
    MINUS           reduce using rule 38 (mexp -> t .)
    LT              reduce using rule 38 (mexp -> t .)
    GT              reduce using rule 38 (mexp -> t .)
    IFEQUAL         reduce using rule 38 (mexp -> t .)
    DIFF            reduce using rule 38 (mexp -> t .)
    AND             reduce using rule 38 (mexp -> t .)
    OR              reduce using rule 38 (mexp -> t .)
    SEMICOLON       reduce using rule 38 (mexp -> t .)
    COMMA           reduce using rule 38 (mexp -> t .)
    RPAREN          reduce using rule 38 (mexp -> t .)
    MULT            shift and go to state 113
    DIV             shift and go to state 114


state 86

    (41) t -> f .

    MULT            reduce using rule 41 (t -> f .)
    DIV             reduce using rule 41 (t -> f .)
    PLUS            reduce using rule 41 (t -> f .)
    MINUS           reduce using rule 41 (t -> f .)
    LT              reduce using rule 41 (t -> f .)
    GT              reduce using rule 41 (t -> f .)
    IFEQUAL         reduce using rule 41 (t -> f .)
    DIFF            reduce using rule 41 (t -> f .)
    AND             reduce using rule 41 (t -> f .)
    OR              reduce using rule 41 (t -> f .)
    SEMICOLON       reduce using rule 41 (t -> f .)
    COMMA           reduce using rule 41 (t -> f .)
    RPAREN          reduce using rule 41 (t -> f .)


state 87

    (44) f -> LPAREN . exp RPAREN
    (28) exp -> . texp
    (29) exp -> . texp OR exp
    (30) texp -> . gexp
    (31) texp -> . gexp AND texp
    (32) gexp -> . mexp
    (33) gexp -> . mexp gexpp mexp
    (38) mexp -> . t
    (39) mexp -> . mexp PLUS t
    (40) mexp -> . mexp MINUS t
    (41) t -> . f
    (42) t -> . t MULT f
    (43) t -> . t DIV f
    (44) f -> . LPAREN exp RPAREN
    (45) f -> . CTI
    (46) f -> . CTF
    (47) f -> . var
    (48) f -> . call
    (63) var -> . ID
    (64) call -> . ID LPAREN callp RPAREN

    LPAREN          shift and go to state 87
    CTI             shift and go to state 88
    CTF             shift and go to state 89
    ID              shift and go to state 91

    exp                            shift and go to state 115
    texp                           shift and go to state 82
    gexp                           shift and go to state 83
    mexp                           shift and go to state 84
    t                              shift and go to state 85
    f                              shift and go to state 86
    var                            shift and go to state 80
    call                           shift and go to state 90

state 88

    (45) f -> CTI .

    MULT            reduce using rule 45 (f -> CTI .)
    DIV             reduce using rule 45 (f -> CTI .)
    PLUS            reduce using rule 45 (f -> CTI .)
    MINUS           reduce using rule 45 (f -> CTI .)
    LT              reduce using rule 45 (f -> CTI .)
    GT              reduce using rule 45 (f -> CTI .)
    IFEQUAL         reduce using rule 45 (f -> CTI .)
    DIFF            reduce using rule 45 (f -> CTI .)
    AND             reduce using rule 45 (f -> CTI .)
    OR              reduce using rule 45 (f -> CTI .)
    SEMICOLON       reduce using rule 45 (f -> CTI .)
    COMMA           reduce using rule 45 (f -> CTI .)
    RPAREN          reduce using rule 45 (f -> CTI .)


state 89

    (46) f -> CTF .

    MULT            reduce using rule 46 (f -> CTF .)
    DIV             reduce using rule 46 (f -> CTF .)
    PLUS            reduce using rule 46 (f -> CTF .)
    MINUS           reduce using rule 46 (f -> CTF .)
    LT              reduce using rule 46 (f -> CTF .)
    GT              reduce using rule 46 (f -> CTF .)
    IFEQUAL         reduce using rule 46 (f -> CTF .)
    DIFF            reduce using rule 46 (f -> CTF .)
    AND             reduce using rule 46 (f -> CTF .)
    OR              reduce using rule 46 (f -> CTF .)
    SEMICOLON       reduce using rule 46 (f -> CTF .)
    COMMA           reduce using rule 46 (f -> CTF .)
    RPAREN          reduce using rule 46 (f -> CTF .)


state 90

    (48) f -> call .

    MULT            reduce using rule 48 (f -> call .)
    DIV             reduce using rule 48 (f -> call .)
    PLUS            reduce using rule 48 (f -> call .)
    MINUS           reduce using rule 48 (f -> call .)
    LT              reduce using rule 48 (f -> call .)
    GT              reduce using rule 48 (f -> call .)
    IFEQUAL         reduce using rule 48 (f -> call .)
    DIFF            reduce using rule 48 (f -> call .)
    AND             reduce using rule 48 (f -> call .)
    OR              reduce using rule 48 (f -> call .)
    SEMICOLON       reduce using rule 48 (f -> call .)
    COMMA           reduce using rule 48 (f -> call .)
    RPAREN          reduce using rule 48 (f -> call .)


state 91

    (63) var -> ID .
    (64) call -> ID . LPAREN callp RPAREN

    MULT            reduce using rule 63 (var -> ID .)
    DIV             reduce using rule 63 (var -> ID .)
    PLUS            reduce using rule 63 (var -> ID .)
    MINUS           reduce using rule 63 (var -> ID .)
    LT              reduce using rule 63 (var -> ID .)
    GT              reduce using rule 63 (var -> ID .)
    IFEQUAL         reduce using rule 63 (var -> ID .)
    DIFF            reduce using rule 63 (var -> ID .)
    AND             reduce using rule 63 (var -> ID .)
    OR              reduce using rule 63 (var -> ID .)
    SEMICOLON       reduce using rule 63 (var -> ID .)
    COMMA           reduce using rule 63 (var -> ID .)
    RPAREN          reduce using rule 63 (var -> ID .)
    LPAREN          shift and go to state 70


state 92

    (64) call -> ID LPAREN callp . RPAREN

    RPAREN          shift and go to state 116


state 93

    (65) callp -> exp . COMMA callp
    (66) callp -> exp .

    COMMA           shift and go to state 117
    RPAREN          reduce using rule 66 (callp -> exp .)


state 94

    (59) read -> READ LPAREN var . RPAREN SEMICOLON

    RPAREN          shift and go to state 118


state 95

    (63) var -> ID .

    RPAREN          reduce using rule 63 (var -> ID .)
    SEMICOLON       reduce using rule 63 (var -> ID .)


state 96

    (60) print -> PRINT LPAREN printp . SEMICOLON

    SEMICOLON       shift and go to state 119


state 97

    (61) printp -> exp . RPAREN
    (62) printp -> exp . COMMA printp

    RPAREN          shift and go to state 120
    COMMA           shift and go to state 121


state 98

    (68) if -> IF LPAREN exp . RPAREN quadsIf LBRACE statements RBRACE ifelse jumpsIf SEMICOLON

    RPAREN          shift and go to state 122


state 99

    (74) while -> WHILE LPAREN saveJumps . exp RPAREN quadsWhile statements jumpsWhile whilep
    (28) exp -> . texp
    (29) exp -> . texp OR exp
    (30) texp -> . gexp
    (31) texp -> . gexp AND texp
    (32) gexp -> . mexp
    (33) gexp -> . mexp gexpp mexp
    (38) mexp -> . t
    (39) mexp -> . mexp PLUS t
    (40) mexp -> . mexp MINUS t
    (41) t -> . f
    (42) t -> . t MULT f
    (43) t -> . t DIV f
    (44) f -> . LPAREN exp RPAREN
    (45) f -> . CTI
    (46) f -> . CTF
    (47) f -> . var
    (48) f -> . call
    (63) var -> . ID
    (64) call -> . ID LPAREN callp RPAREN

    LPAREN          shift and go to state 87
    CTI             shift and go to state 88
    CTF             shift and go to state 89
    ID              shift and go to state 91

    exp                            shift and go to state 123
    texp                           shift and go to state 82
    gexp                           shift and go to state 83
    mexp                           shift and go to state 84
    t                              shift and go to state 85
    f                              shift and go to state 86
    var                            shift and go to state 80
    call                           shift and go to state 90

state 100

    (80) for -> FOR LPAREN var . SEMICOLON exp SEMICOLON exp RPAREN LBRACKET statements forp

    SEMICOLON       shift and go to state 124


state 101

    (11) function -> FUNCTION decfunctype decfunc LPAREN param RPAREN LBRACE body RETURN . exp SEMICOLON RBRACE
    (28) exp -> . texp
    (29) exp -> . texp OR exp
    (30) texp -> . gexp
    (31) texp -> . gexp AND texp
    (32) gexp -> . mexp
    (33) gexp -> . mexp gexpp mexp
    (38) mexp -> . t
    (39) mexp -> . mexp PLUS t
    (40) mexp -> . mexp MINUS t
    (41) t -> . f
    (42) t -> . t MULT f
    (43) t -> . t DIV f
    (44) f -> . LPAREN exp RPAREN
    (45) f -> . CTI
    (46) f -> . CTF
    (47) f -> . var
    (48) f -> . call
    (63) var -> . ID
    (64) call -> . ID LPAREN callp RPAREN

    LPAREN          shift and go to state 87
    CTI             shift and go to state 88
    CTF             shift and go to state 89
    ID              shift and go to state 91

    exp                            shift and go to state 125
    texp                           shift and go to state 82
    gexp                           shift and go to state 83
    mexp                           shift and go to state 84
    t                              shift and go to state 85
    f                              shift and go to state 86
    var                            shift and go to state 80
    call                           shift and go to state 90

state 102

    (14) voidfunction -> FUNCTION VOID decfunc LPAREN param RPAREN LBRACE body RBRACE .

    FUNCTION        reduce using rule 14 (voidfunction -> FUNCTION VOID decfunc LPAREN param RPAREN LBRACE body RBRACE .)
    MAIN            reduce using rule 14 (voidfunction -> FUNCTION VOID decfunc LPAREN param RPAREN LBRACE body RBRACE .)
    VAR             reduce using rule 14 (voidfunction -> FUNCTION VOID decfunc LPAREN param RPAREN LBRACE body RBRACE .)
    ID              reduce using rule 14 (voidfunction -> FUNCTION VOID decfunc LPAREN param RPAREN LBRACE body RBRACE .)
    READ            reduce using rule 14 (voidfunction -> FUNCTION VOID decfunc LPAREN param RPAREN LBRACE body RBRACE .)
    PRINT           reduce using rule 14 (voidfunction -> FUNCTION VOID decfunc LPAREN param RPAREN LBRACE body RBRACE .)
    IF              reduce using rule 14 (voidfunction -> FUNCTION VOID decfunc LPAREN param RPAREN LBRACE body RBRACE .)
    WHILE           reduce using rule 14 (voidfunction -> FUNCTION VOID decfunc LPAREN param RPAREN LBRACE body RBRACE .)
    FOR             reduce using rule 14 (voidfunction -> FUNCTION VOID decfunc LPAREN param RPAREN LBRACE body RBRACE .)
    RBRACE          reduce using rule 14 (voidfunction -> FUNCTION VOID decfunc LPAREN param RPAREN LBRACE body RBRACE .)
    RETURN          reduce using rule 14 (voidfunction -> FUNCTION VOID decfunc LPAREN param RPAREN LBRACE body RBRACE .)
    SEMICOLON       reduce using rule 14 (voidfunction -> FUNCTION VOID decfunc LPAREN param RPAREN LBRACE body RBRACE .)
    RBRACKET        reduce using rule 14 (voidfunction -> FUNCTION VOID decfunc LPAREN param RPAREN LBRACE body RBRACE .)


state 103

    (58) assign -> var EQUAL exp SEMICOLON .

    VAR             reduce using rule 58 (assign -> var EQUAL exp SEMICOLON .)
    FUNCTION        reduce using rule 58 (assign -> var EQUAL exp SEMICOLON .)
    ID              reduce using rule 58 (assign -> var EQUAL exp SEMICOLON .)
    READ            reduce using rule 58 (assign -> var EQUAL exp SEMICOLON .)
    PRINT           reduce using rule 58 (assign -> var EQUAL exp SEMICOLON .)
    IF              reduce using rule 58 (assign -> var EQUAL exp SEMICOLON .)
    WHILE           reduce using rule 58 (assign -> var EQUAL exp SEMICOLON .)
    FOR             reduce using rule 58 (assign -> var EQUAL exp SEMICOLON .)
    RBRACE          reduce using rule 58 (assign -> var EQUAL exp SEMICOLON .)
    RETURN          reduce using rule 58 (assign -> var EQUAL exp SEMICOLON .)
    SEMICOLON       reduce using rule 58 (assign -> var EQUAL exp SEMICOLON .)
    RBRACKET        reduce using rule 58 (assign -> var EQUAL exp SEMICOLON .)


state 104

    (29) exp -> texp OR . exp
    (28) exp -> . texp
    (29) exp -> . texp OR exp
    (30) texp -> . gexp
    (31) texp -> . gexp AND texp
    (32) gexp -> . mexp
    (33) gexp -> . mexp gexpp mexp
    (38) mexp -> . t
    (39) mexp -> . mexp PLUS t
    (40) mexp -> . mexp MINUS t
    (41) t -> . f
    (42) t -> . t MULT f
    (43) t -> . t DIV f
    (44) f -> . LPAREN exp RPAREN
    (45) f -> . CTI
    (46) f -> . CTF
    (47) f -> . var
    (48) f -> . call
    (63) var -> . ID
    (64) call -> . ID LPAREN callp RPAREN

    LPAREN          shift and go to state 87
    CTI             shift and go to state 88
    CTF             shift and go to state 89
    ID              shift and go to state 91

    texp                           shift and go to state 82
    exp                            shift and go to state 126
    gexp                           shift and go to state 83
    mexp                           shift and go to state 84
    t                              shift and go to state 85
    f                              shift and go to state 86
    var                            shift and go to state 80
    call                           shift and go to state 90

state 105

    (31) texp -> gexp AND . texp
    (30) texp -> . gexp
    (31) texp -> . gexp AND texp
    (32) gexp -> . mexp
    (33) gexp -> . mexp gexpp mexp
    (38) mexp -> . t
    (39) mexp -> . mexp PLUS t
    (40) mexp -> . mexp MINUS t
    (41) t -> . f
    (42) t -> . t MULT f
    (43) t -> . t DIV f
    (44) f -> . LPAREN exp RPAREN
    (45) f -> . CTI
    (46) f -> . CTF
    (47) f -> . var
    (48) f -> . call
    (63) var -> . ID
    (64) call -> . ID LPAREN callp RPAREN

    LPAREN          shift and go to state 87
    CTI             shift and go to state 88
    CTF             shift and go to state 89
    ID              shift and go to state 91

    gexp                           shift and go to state 83
    texp                           shift and go to state 127
    mexp                           shift and go to state 84
    t                              shift and go to state 85
    f                              shift and go to state 86
    var                            shift and go to state 80
    call                           shift and go to state 90

state 106

    (33) gexp -> mexp gexpp . mexp
    (38) mexp -> . t
    (39) mexp -> . mexp PLUS t
    (40) mexp -> . mexp MINUS t
    (41) t -> . f
    (42) t -> . t MULT f
    (43) t -> . t DIV f
    (44) f -> . LPAREN exp RPAREN
    (45) f -> . CTI
    (46) f -> . CTF
    (47) f -> . var
    (48) f -> . call
    (63) var -> . ID
    (64) call -> . ID LPAREN callp RPAREN

    LPAREN          shift and go to state 87
    CTI             shift and go to state 88
    CTF             shift and go to state 89
    ID              shift and go to state 91

    mexp                           shift and go to state 128
    t                              shift and go to state 85
    f                              shift and go to state 86
    var                            shift and go to state 80
    call                           shift and go to state 90

state 107

    (39) mexp -> mexp PLUS . t
    (41) t -> . f
    (42) t -> . t MULT f
    (43) t -> . t DIV f
    (44) f -> . LPAREN exp RPAREN
    (45) f -> . CTI
    (46) f -> . CTF
    (47) f -> . var
    (48) f -> . call
    (63) var -> . ID
    (64) call -> . ID LPAREN callp RPAREN

    LPAREN          shift and go to state 87
    CTI             shift and go to state 88
    CTF             shift and go to state 89
    ID              shift and go to state 91

    t                              shift and go to state 129
    f                              shift and go to state 86
    var                            shift and go to state 80
    call                           shift and go to state 90

state 108

    (40) mexp -> mexp MINUS . t
    (41) t -> . f
    (42) t -> . t MULT f
    (43) t -> . t DIV f
    (44) f -> . LPAREN exp RPAREN
    (45) f -> . CTI
    (46) f -> . CTF
    (47) f -> . var
    (48) f -> . call
    (63) var -> . ID
    (64) call -> . ID LPAREN callp RPAREN

    LPAREN          shift and go to state 87
    CTI             shift and go to state 88
    CTF             shift and go to state 89
    ID              shift and go to state 91

    t                              shift and go to state 130
    f                              shift and go to state 86
    var                            shift and go to state 80
    call                           shift and go to state 90

state 109

    (34) gexpp -> LT .

    LPAREN          reduce using rule 34 (gexpp -> LT .)
    CTI             reduce using rule 34 (gexpp -> LT .)
    CTF             reduce using rule 34 (gexpp -> LT .)
    ID              reduce using rule 34 (gexpp -> LT .)


state 110

    (35) gexpp -> GT .

    LPAREN          reduce using rule 35 (gexpp -> GT .)
    CTI             reduce using rule 35 (gexpp -> GT .)
    CTF             reduce using rule 35 (gexpp -> GT .)
    ID              reduce using rule 35 (gexpp -> GT .)


state 111

    (36) gexpp -> IFEQUAL .

    LPAREN          reduce using rule 36 (gexpp -> IFEQUAL .)
    CTI             reduce using rule 36 (gexpp -> IFEQUAL .)
    CTF             reduce using rule 36 (gexpp -> IFEQUAL .)
    ID              reduce using rule 36 (gexpp -> IFEQUAL .)


state 112

    (37) gexpp -> DIFF .

    LPAREN          reduce using rule 37 (gexpp -> DIFF .)
    CTI             reduce using rule 37 (gexpp -> DIFF .)
    CTF             reduce using rule 37 (gexpp -> DIFF .)
    ID              reduce using rule 37 (gexpp -> DIFF .)


state 113

    (42) t -> t MULT . f
    (44) f -> . LPAREN exp RPAREN
    (45) f -> . CTI
    (46) f -> . CTF
    (47) f -> . var
    (48) f -> . call
    (63) var -> . ID
    (64) call -> . ID LPAREN callp RPAREN

    LPAREN          shift and go to state 87
    CTI             shift and go to state 88
    CTF             shift and go to state 89
    ID              shift and go to state 91

    f                              shift and go to state 131
    var                            shift and go to state 80
    call                           shift and go to state 90

state 114

    (43) t -> t DIV . f
    (44) f -> . LPAREN exp RPAREN
    (45) f -> . CTI
    (46) f -> . CTF
    (47) f -> . var
    (48) f -> . call
    (63) var -> . ID
    (64) call -> . ID LPAREN callp RPAREN

    LPAREN          shift and go to state 87
    CTI             shift and go to state 88
    CTF             shift and go to state 89
    ID              shift and go to state 91

    f                              shift and go to state 132
    var                            shift and go to state 80
    call                           shift and go to state 90

state 115

    (44) f -> LPAREN exp . RPAREN

    RPAREN          shift and go to state 133


state 116

    (64) call -> ID LPAREN callp RPAREN .

    VAR             reduce using rule 64 (call -> ID LPAREN callp RPAREN .)
    FUNCTION        reduce using rule 64 (call -> ID LPAREN callp RPAREN .)
    ID              reduce using rule 64 (call -> ID LPAREN callp RPAREN .)
    READ            reduce using rule 64 (call -> ID LPAREN callp RPAREN .)
    PRINT           reduce using rule 64 (call -> ID LPAREN callp RPAREN .)
    IF              reduce using rule 64 (call -> ID LPAREN callp RPAREN .)
    WHILE           reduce using rule 64 (call -> ID LPAREN callp RPAREN .)
    FOR             reduce using rule 64 (call -> ID LPAREN callp RPAREN .)
    RBRACE          reduce using rule 64 (call -> ID LPAREN callp RPAREN .)
    RETURN          reduce using rule 64 (call -> ID LPAREN callp RPAREN .)
    MULT            reduce using rule 64 (call -> ID LPAREN callp RPAREN .)
    DIV             reduce using rule 64 (call -> ID LPAREN callp RPAREN .)
    PLUS            reduce using rule 64 (call -> ID LPAREN callp RPAREN .)
    MINUS           reduce using rule 64 (call -> ID LPAREN callp RPAREN .)
    LT              reduce using rule 64 (call -> ID LPAREN callp RPAREN .)
    GT              reduce using rule 64 (call -> ID LPAREN callp RPAREN .)
    IFEQUAL         reduce using rule 64 (call -> ID LPAREN callp RPAREN .)
    DIFF            reduce using rule 64 (call -> ID LPAREN callp RPAREN .)
    AND             reduce using rule 64 (call -> ID LPAREN callp RPAREN .)
    OR              reduce using rule 64 (call -> ID LPAREN callp RPAREN .)
    SEMICOLON       reduce using rule 64 (call -> ID LPAREN callp RPAREN .)
    COMMA           reduce using rule 64 (call -> ID LPAREN callp RPAREN .)
    RPAREN          reduce using rule 64 (call -> ID LPAREN callp RPAREN .)
    RBRACKET        reduce using rule 64 (call -> ID LPAREN callp RPAREN .)


state 117

    (65) callp -> exp COMMA . callp
    (65) callp -> . exp COMMA callp
    (66) callp -> . exp
    (67) callp -> .
    (28) exp -> . texp
    (29) exp -> . texp OR exp
    (30) texp -> . gexp
    (31) texp -> . gexp AND texp
    (32) gexp -> . mexp
    (33) gexp -> . mexp gexpp mexp
    (38) mexp -> . t
    (39) mexp -> . mexp PLUS t
    (40) mexp -> . mexp MINUS t
    (41) t -> . f
    (42) t -> . t MULT f
    (43) t -> . t DIV f
    (44) f -> . LPAREN exp RPAREN
    (45) f -> . CTI
    (46) f -> . CTF
    (47) f -> . var
    (48) f -> . call
    (63) var -> . ID
    (64) call -> . ID LPAREN callp RPAREN

    RPAREN          reduce using rule 67 (callp -> .)
    LPAREN          shift and go to state 87
    CTI             shift and go to state 88
    CTF             shift and go to state 89
    ID              shift and go to state 91

    exp                            shift and go to state 93
    callp                          shift and go to state 134
    texp                           shift and go to state 82
    gexp                           shift and go to state 83
    mexp                           shift and go to state 84
    t                              shift and go to state 85
    f                              shift and go to state 86
    var                            shift and go to state 80
    call                           shift and go to state 90

state 118

    (59) read -> READ LPAREN var RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 135


state 119

    (60) print -> PRINT LPAREN printp SEMICOLON .

    VAR             reduce using rule 60 (print -> PRINT LPAREN printp SEMICOLON .)
    FUNCTION        reduce using rule 60 (print -> PRINT LPAREN printp SEMICOLON .)
    ID              reduce using rule 60 (print -> PRINT LPAREN printp SEMICOLON .)
    READ            reduce using rule 60 (print -> PRINT LPAREN printp SEMICOLON .)
    PRINT           reduce using rule 60 (print -> PRINT LPAREN printp SEMICOLON .)
    IF              reduce using rule 60 (print -> PRINT LPAREN printp SEMICOLON .)
    WHILE           reduce using rule 60 (print -> PRINT LPAREN printp SEMICOLON .)
    FOR             reduce using rule 60 (print -> PRINT LPAREN printp SEMICOLON .)
    RBRACE          reduce using rule 60 (print -> PRINT LPAREN printp SEMICOLON .)
    RETURN          reduce using rule 60 (print -> PRINT LPAREN printp SEMICOLON .)
    SEMICOLON       reduce using rule 60 (print -> PRINT LPAREN printp SEMICOLON .)
    RBRACKET        reduce using rule 60 (print -> PRINT LPAREN printp SEMICOLON .)


state 120

    (61) printp -> exp RPAREN .

    SEMICOLON       reduce using rule 61 (printp -> exp RPAREN .)


state 121

    (62) printp -> exp COMMA . printp
    (61) printp -> . exp RPAREN
    (62) printp -> . exp COMMA printp
    (28) exp -> . texp
    (29) exp -> . texp OR exp
    (30) texp -> . gexp
    (31) texp -> . gexp AND texp
    (32) gexp -> . mexp
    (33) gexp -> . mexp gexpp mexp
    (38) mexp -> . t
    (39) mexp -> . mexp PLUS t
    (40) mexp -> . mexp MINUS t
    (41) t -> . f
    (42) t -> . t MULT f
    (43) t -> . t DIV f
    (44) f -> . LPAREN exp RPAREN
    (45) f -> . CTI
    (46) f -> . CTF
    (47) f -> . var
    (48) f -> . call
    (63) var -> . ID
    (64) call -> . ID LPAREN callp RPAREN

    LPAREN          shift and go to state 87
    CTI             shift and go to state 88
    CTF             shift and go to state 89
    ID              shift and go to state 91

    exp                            shift and go to state 97
    printp                         shift and go to state 136
    texp                           shift and go to state 82
    gexp                           shift and go to state 83
    mexp                           shift and go to state 84
    t                              shift and go to state 85
    f                              shift and go to state 86
    var                            shift and go to state 80
    call                           shift and go to state 90

state 122

    (68) if -> IF LPAREN exp RPAREN . quadsIf LBRACE statements RBRACE ifelse jumpsIf SEMICOLON
    (71) quadsIf -> .

    LBRACE          reduce using rule 71 (quadsIf -> .)

    quadsIf                        shift and go to state 137

state 123

    (74) while -> WHILE LPAREN saveJumps exp . RPAREN quadsWhile statements jumpsWhile whilep

    RPAREN          shift and go to state 138


state 124

    (80) for -> FOR LPAREN var SEMICOLON . exp SEMICOLON exp RPAREN LBRACKET statements forp
    (28) exp -> . texp
    (29) exp -> . texp OR exp
    (30) texp -> . gexp
    (31) texp -> . gexp AND texp
    (32) gexp -> . mexp
    (33) gexp -> . mexp gexpp mexp
    (38) mexp -> . t
    (39) mexp -> . mexp PLUS t
    (40) mexp -> . mexp MINUS t
    (41) t -> . f
    (42) t -> . t MULT f
    (43) t -> . t DIV f
    (44) f -> . LPAREN exp RPAREN
    (45) f -> . CTI
    (46) f -> . CTF
    (47) f -> . var
    (48) f -> . call
    (63) var -> . ID
    (64) call -> . ID LPAREN callp RPAREN

    LPAREN          shift and go to state 87
    CTI             shift and go to state 88
    CTF             shift and go to state 89
    ID              shift and go to state 91

    var                            shift and go to state 80
    exp                            shift and go to state 139
    texp                           shift and go to state 82
    gexp                           shift and go to state 83
    mexp                           shift and go to state 84
    t                              shift and go to state 85
    f                              shift and go to state 86
    call                           shift and go to state 90

state 125

    (11) function -> FUNCTION decfunctype decfunc LPAREN param RPAREN LBRACE body RETURN exp . SEMICOLON RBRACE

    SEMICOLON       shift and go to state 140


state 126

    (29) exp -> texp OR exp .

    SEMICOLON       reduce using rule 29 (exp -> texp OR exp .)
    COMMA           reduce using rule 29 (exp -> texp OR exp .)
    RPAREN          reduce using rule 29 (exp -> texp OR exp .)


state 127

    (31) texp -> gexp AND texp .

    OR              reduce using rule 31 (texp -> gexp AND texp .)
    SEMICOLON       reduce using rule 31 (texp -> gexp AND texp .)
    COMMA           reduce using rule 31 (texp -> gexp AND texp .)
    RPAREN          reduce using rule 31 (texp -> gexp AND texp .)


state 128

    (33) gexp -> mexp gexpp mexp .
    (39) mexp -> mexp . PLUS t
    (40) mexp -> mexp . MINUS t

    AND             reduce using rule 33 (gexp -> mexp gexpp mexp .)
    OR              reduce using rule 33 (gexp -> mexp gexpp mexp .)
    SEMICOLON       reduce using rule 33 (gexp -> mexp gexpp mexp .)
    COMMA           reduce using rule 33 (gexp -> mexp gexpp mexp .)
    RPAREN          reduce using rule 33 (gexp -> mexp gexpp mexp .)
    PLUS            shift and go to state 107
    MINUS           shift and go to state 108


state 129

    (39) mexp -> mexp PLUS t .
    (42) t -> t . MULT f
    (43) t -> t . DIV f

    PLUS            reduce using rule 39 (mexp -> mexp PLUS t .)
    MINUS           reduce using rule 39 (mexp -> mexp PLUS t .)
    LT              reduce using rule 39 (mexp -> mexp PLUS t .)
    GT              reduce using rule 39 (mexp -> mexp PLUS t .)
    IFEQUAL         reduce using rule 39 (mexp -> mexp PLUS t .)
    DIFF            reduce using rule 39 (mexp -> mexp PLUS t .)
    AND             reduce using rule 39 (mexp -> mexp PLUS t .)
    OR              reduce using rule 39 (mexp -> mexp PLUS t .)
    SEMICOLON       reduce using rule 39 (mexp -> mexp PLUS t .)
    COMMA           reduce using rule 39 (mexp -> mexp PLUS t .)
    RPAREN          reduce using rule 39 (mexp -> mexp PLUS t .)
    MULT            shift and go to state 113
    DIV             shift and go to state 114


state 130

    (40) mexp -> mexp MINUS t .
    (42) t -> t . MULT f
    (43) t -> t . DIV f

    PLUS            reduce using rule 40 (mexp -> mexp MINUS t .)
    MINUS           reduce using rule 40 (mexp -> mexp MINUS t .)
    LT              reduce using rule 40 (mexp -> mexp MINUS t .)
    GT              reduce using rule 40 (mexp -> mexp MINUS t .)
    IFEQUAL         reduce using rule 40 (mexp -> mexp MINUS t .)
    DIFF            reduce using rule 40 (mexp -> mexp MINUS t .)
    AND             reduce using rule 40 (mexp -> mexp MINUS t .)
    OR              reduce using rule 40 (mexp -> mexp MINUS t .)
    SEMICOLON       reduce using rule 40 (mexp -> mexp MINUS t .)
    COMMA           reduce using rule 40 (mexp -> mexp MINUS t .)
    RPAREN          reduce using rule 40 (mexp -> mexp MINUS t .)
    MULT            shift and go to state 113
    DIV             shift and go to state 114


state 131

    (42) t -> t MULT f .

    MULT            reduce using rule 42 (t -> t MULT f .)
    DIV             reduce using rule 42 (t -> t MULT f .)
    PLUS            reduce using rule 42 (t -> t MULT f .)
    MINUS           reduce using rule 42 (t -> t MULT f .)
    LT              reduce using rule 42 (t -> t MULT f .)
    GT              reduce using rule 42 (t -> t MULT f .)
    IFEQUAL         reduce using rule 42 (t -> t MULT f .)
    DIFF            reduce using rule 42 (t -> t MULT f .)
    AND             reduce using rule 42 (t -> t MULT f .)
    OR              reduce using rule 42 (t -> t MULT f .)
    SEMICOLON       reduce using rule 42 (t -> t MULT f .)
    COMMA           reduce using rule 42 (t -> t MULT f .)
    RPAREN          reduce using rule 42 (t -> t MULT f .)


state 132

    (43) t -> t DIV f .

    MULT            reduce using rule 43 (t -> t DIV f .)
    DIV             reduce using rule 43 (t -> t DIV f .)
    PLUS            reduce using rule 43 (t -> t DIV f .)
    MINUS           reduce using rule 43 (t -> t DIV f .)
    LT              reduce using rule 43 (t -> t DIV f .)
    GT              reduce using rule 43 (t -> t DIV f .)
    IFEQUAL         reduce using rule 43 (t -> t DIV f .)
    DIFF            reduce using rule 43 (t -> t DIV f .)
    AND             reduce using rule 43 (t -> t DIV f .)
    OR              reduce using rule 43 (t -> t DIV f .)
    SEMICOLON       reduce using rule 43 (t -> t DIV f .)
    COMMA           reduce using rule 43 (t -> t DIV f .)
    RPAREN          reduce using rule 43 (t -> t DIV f .)


state 133

    (44) f -> LPAREN exp RPAREN .

    MULT            reduce using rule 44 (f -> LPAREN exp RPAREN .)
    DIV             reduce using rule 44 (f -> LPAREN exp RPAREN .)
    PLUS            reduce using rule 44 (f -> LPAREN exp RPAREN .)
    MINUS           reduce using rule 44 (f -> LPAREN exp RPAREN .)
    LT              reduce using rule 44 (f -> LPAREN exp RPAREN .)
    GT              reduce using rule 44 (f -> LPAREN exp RPAREN .)
    IFEQUAL         reduce using rule 44 (f -> LPAREN exp RPAREN .)
    DIFF            reduce using rule 44 (f -> LPAREN exp RPAREN .)
    AND             reduce using rule 44 (f -> LPAREN exp RPAREN .)
    OR              reduce using rule 44 (f -> LPAREN exp RPAREN .)
    SEMICOLON       reduce using rule 44 (f -> LPAREN exp RPAREN .)
    COMMA           reduce using rule 44 (f -> LPAREN exp RPAREN .)
    RPAREN          reduce using rule 44 (f -> LPAREN exp RPAREN .)


state 134

    (65) callp -> exp COMMA callp .

    RPAREN          reduce using rule 65 (callp -> exp COMMA callp .)


state 135

    (59) read -> READ LPAREN var RPAREN SEMICOLON .

    VAR             reduce using rule 59 (read -> READ LPAREN var RPAREN SEMICOLON .)
    FUNCTION        reduce using rule 59 (read -> READ LPAREN var RPAREN SEMICOLON .)
    ID              reduce using rule 59 (read -> READ LPAREN var RPAREN SEMICOLON .)
    READ            reduce using rule 59 (read -> READ LPAREN var RPAREN SEMICOLON .)
    PRINT           reduce using rule 59 (read -> READ LPAREN var RPAREN SEMICOLON .)
    IF              reduce using rule 59 (read -> READ LPAREN var RPAREN SEMICOLON .)
    WHILE           reduce using rule 59 (read -> READ LPAREN var RPAREN SEMICOLON .)
    FOR             reduce using rule 59 (read -> READ LPAREN var RPAREN SEMICOLON .)
    RBRACE          reduce using rule 59 (read -> READ LPAREN var RPAREN SEMICOLON .)
    RETURN          reduce using rule 59 (read -> READ LPAREN var RPAREN SEMICOLON .)
    SEMICOLON       reduce using rule 59 (read -> READ LPAREN var RPAREN SEMICOLON .)
    RBRACKET        reduce using rule 59 (read -> READ LPAREN var RPAREN SEMICOLON .)


state 136

    (62) printp -> exp COMMA printp .

    SEMICOLON       reduce using rule 62 (printp -> exp COMMA printp .)


state 137

    (68) if -> IF LPAREN exp RPAREN quadsIf . LBRACE statements RBRACE ifelse jumpsIf SEMICOLON

    LBRACE          shift and go to state 141


state 138

    (74) while -> WHILE LPAREN saveJumps exp RPAREN . quadsWhile statements jumpsWhile whilep
    (78) quadsWhile -> .

    FUNCTION        reduce using rule 78 (quadsWhile -> .)
    ID              reduce using rule 78 (quadsWhile -> .)
    READ            reduce using rule 78 (quadsWhile -> .)
    PRINT           reduce using rule 78 (quadsWhile -> .)
    IF              reduce using rule 78 (quadsWhile -> .)
    WHILE           reduce using rule 78 (quadsWhile -> .)
    FOR             reduce using rule 78 (quadsWhile -> .)

    quadsWhile                     shift and go to state 142

state 139

    (80) for -> FOR LPAREN var SEMICOLON exp . SEMICOLON exp RPAREN LBRACKET statements forp

    SEMICOLON       shift and go to state 143


state 140

    (11) function -> FUNCTION decfunctype decfunc LPAREN param RPAREN LBRACE body RETURN exp SEMICOLON . RBRACE

    RBRACE          shift and go to state 144


state 141

    (68) if -> IF LPAREN exp RPAREN quadsIf LBRACE . statements RBRACE ifelse jumpsIf SEMICOLON
    (49) statements -> . assign
    (50) statements -> . function
    (51) statements -> . voidfunction
    (52) statements -> . call
    (53) statements -> . read
    (54) statements -> . print
    (55) statements -> . if
    (56) statements -> . while
    (57) statements -> . for
    (58) assign -> . var EQUAL exp SEMICOLON
    (11) function -> . FUNCTION decfunctype decfunc LPAREN param RPAREN LBRACE body RETURN exp SEMICOLON RBRACE
    (14) voidfunction -> . FUNCTION VOID decfunc LPAREN param RPAREN LBRACE body RBRACE
    (64) call -> . ID LPAREN callp RPAREN
    (59) read -> . READ LPAREN var RPAREN SEMICOLON
    (60) print -> . PRINT LPAREN printp SEMICOLON
    (68) if -> . IF LPAREN exp RPAREN quadsIf LBRACE statements RBRACE ifelse jumpsIf SEMICOLON
    (74) while -> . WHILE LPAREN saveJumps exp RPAREN quadsWhile statements jumpsWhile whilep
    (80) for -> . FOR LPAREN var SEMICOLON exp SEMICOLON exp RPAREN LBRACKET statements forp
    (63) var -> . ID

    FUNCTION        shift and go to state 11
    ID              shift and go to state 57
    READ            shift and go to state 58
    PRINT           shift and go to state 59
    IF              shift and go to state 60
    WHILE           shift and go to state 61
    FOR             shift and go to state 62

    statements                     shift and go to state 145
    assign                         shift and go to state 47
    function                       shift and go to state 48
    voidfunction                   shift and go to state 49
    call                           shift and go to state 50
    read                           shift and go to state 51
    print                          shift and go to state 52
    if                             shift and go to state 53
    while                          shift and go to state 54
    for                            shift and go to state 55
    var                            shift and go to state 56

state 142

    (74) while -> WHILE LPAREN saveJumps exp RPAREN quadsWhile . statements jumpsWhile whilep
    (49) statements -> . assign
    (50) statements -> . function
    (51) statements -> . voidfunction
    (52) statements -> . call
    (53) statements -> . read
    (54) statements -> . print
    (55) statements -> . if
    (56) statements -> . while
    (57) statements -> . for
    (58) assign -> . var EQUAL exp SEMICOLON
    (11) function -> . FUNCTION decfunctype decfunc LPAREN param RPAREN LBRACE body RETURN exp SEMICOLON RBRACE
    (14) voidfunction -> . FUNCTION VOID decfunc LPAREN param RPAREN LBRACE body RBRACE
    (64) call -> . ID LPAREN callp RPAREN
    (59) read -> . READ LPAREN var RPAREN SEMICOLON
    (60) print -> . PRINT LPAREN printp SEMICOLON
    (68) if -> . IF LPAREN exp RPAREN quadsIf LBRACE statements RBRACE ifelse jumpsIf SEMICOLON
    (74) while -> . WHILE LPAREN saveJumps exp RPAREN quadsWhile statements jumpsWhile whilep
    (80) for -> . FOR LPAREN var SEMICOLON exp SEMICOLON exp RPAREN LBRACKET statements forp
    (63) var -> . ID

    FUNCTION        shift and go to state 11
    ID              shift and go to state 57
    READ            shift and go to state 58
    PRINT           shift and go to state 59
    IF              shift and go to state 60
    WHILE           shift and go to state 61
    FOR             shift and go to state 62

    statements                     shift and go to state 146
    assign                         shift and go to state 47
    function                       shift and go to state 48
    voidfunction                   shift and go to state 49
    call                           shift and go to state 50
    read                           shift and go to state 51
    print                          shift and go to state 52
    if                             shift and go to state 53
    while                          shift and go to state 54
    for                            shift and go to state 55
    var                            shift and go to state 56

state 143

    (80) for -> FOR LPAREN var SEMICOLON exp SEMICOLON . exp RPAREN LBRACKET statements forp
    (28) exp -> . texp
    (29) exp -> . texp OR exp
    (30) texp -> . gexp
    (31) texp -> . gexp AND texp
    (32) gexp -> . mexp
    (33) gexp -> . mexp gexpp mexp
    (38) mexp -> . t
    (39) mexp -> . mexp PLUS t
    (40) mexp -> . mexp MINUS t
    (41) t -> . f
    (42) t -> . t MULT f
    (43) t -> . t DIV f
    (44) f -> . LPAREN exp RPAREN
    (45) f -> . CTI
    (46) f -> . CTF
    (47) f -> . var
    (48) f -> . call
    (63) var -> . ID
    (64) call -> . ID LPAREN callp RPAREN

    LPAREN          shift and go to state 87
    CTI             shift and go to state 88
    CTF             shift and go to state 89
    ID              shift and go to state 91

    var                            shift and go to state 80
    exp                            shift and go to state 147
    texp                           shift and go to state 82
    gexp                           shift and go to state 83
    mexp                           shift and go to state 84
    t                              shift and go to state 85
    f                              shift and go to state 86
    call                           shift and go to state 90

state 144

    (11) function -> FUNCTION decfunctype decfunc LPAREN param RPAREN LBRACE body RETURN exp SEMICOLON RBRACE .

    FUNCTION        reduce using rule 11 (function -> FUNCTION decfunctype decfunc LPAREN param RPAREN LBRACE body RETURN exp SEMICOLON RBRACE .)
    MAIN            reduce using rule 11 (function -> FUNCTION decfunctype decfunc LPAREN param RPAREN LBRACE body RETURN exp SEMICOLON RBRACE .)
    VAR             reduce using rule 11 (function -> FUNCTION decfunctype decfunc LPAREN param RPAREN LBRACE body RETURN exp SEMICOLON RBRACE .)
    ID              reduce using rule 11 (function -> FUNCTION decfunctype decfunc LPAREN param RPAREN LBRACE body RETURN exp SEMICOLON RBRACE .)
    READ            reduce using rule 11 (function -> FUNCTION decfunctype decfunc LPAREN param RPAREN LBRACE body RETURN exp SEMICOLON RBRACE .)
    PRINT           reduce using rule 11 (function -> FUNCTION decfunctype decfunc LPAREN param RPAREN LBRACE body RETURN exp SEMICOLON RBRACE .)
    IF              reduce using rule 11 (function -> FUNCTION decfunctype decfunc LPAREN param RPAREN LBRACE body RETURN exp SEMICOLON RBRACE .)
    WHILE           reduce using rule 11 (function -> FUNCTION decfunctype decfunc LPAREN param RPAREN LBRACE body RETURN exp SEMICOLON RBRACE .)
    FOR             reduce using rule 11 (function -> FUNCTION decfunctype decfunc LPAREN param RPAREN LBRACE body RETURN exp SEMICOLON RBRACE .)
    RBRACE          reduce using rule 11 (function -> FUNCTION decfunctype decfunc LPAREN param RPAREN LBRACE body RETURN exp SEMICOLON RBRACE .)
    RETURN          reduce using rule 11 (function -> FUNCTION decfunctype decfunc LPAREN param RPAREN LBRACE body RETURN exp SEMICOLON RBRACE .)
    SEMICOLON       reduce using rule 11 (function -> FUNCTION decfunctype decfunc LPAREN param RPAREN LBRACE body RETURN exp SEMICOLON RBRACE .)
    RBRACKET        reduce using rule 11 (function -> FUNCTION decfunctype decfunc LPAREN param RPAREN LBRACE body RETURN exp SEMICOLON RBRACE .)


state 145

    (68) if -> IF LPAREN exp RPAREN quadsIf LBRACE statements . RBRACE ifelse jumpsIf SEMICOLON

    RBRACE          shift and go to state 148


state 146

    (74) while -> WHILE LPAREN saveJumps exp RPAREN quadsWhile statements . jumpsWhile whilep
    (79) jumpsWhile -> .

    SEMICOLON       reduce using rule 79 (jumpsWhile -> .)
    FUNCTION        reduce using rule 79 (jumpsWhile -> .)
    ID              reduce using rule 79 (jumpsWhile -> .)
    READ            reduce using rule 79 (jumpsWhile -> .)
    PRINT           reduce using rule 79 (jumpsWhile -> .)
    IF              reduce using rule 79 (jumpsWhile -> .)
    WHILE           reduce using rule 79 (jumpsWhile -> .)
    FOR             reduce using rule 79 (jumpsWhile -> .)

    jumpsWhile                     shift and go to state 149

state 147

    (80) for -> FOR LPAREN var SEMICOLON exp SEMICOLON exp . RPAREN LBRACKET statements forp

    RPAREN          shift and go to state 150


state 148

    (68) if -> IF LPAREN exp RPAREN quadsIf LBRACE statements RBRACE . ifelse jumpsIf SEMICOLON
    (69) ifelse -> .
    (70) ifelse -> . ELSE quadsElse LBRACE statements RBRACE

    SEMICOLON       reduce using rule 69 (ifelse -> .)
    ELSE            shift and go to state 152

    ifelse                         shift and go to state 151

state 149

    (74) while -> WHILE LPAREN saveJumps exp RPAREN quadsWhile statements jumpsWhile . whilep
    (75) whilep -> . SEMICOLON
    (76) whilep -> . statements whilep
    (49) statements -> . assign
    (50) statements -> . function
    (51) statements -> . voidfunction
    (52) statements -> . call
    (53) statements -> . read
    (54) statements -> . print
    (55) statements -> . if
    (56) statements -> . while
    (57) statements -> . for
    (58) assign -> . var EQUAL exp SEMICOLON
    (11) function -> . FUNCTION decfunctype decfunc LPAREN param RPAREN LBRACE body RETURN exp SEMICOLON RBRACE
    (14) voidfunction -> . FUNCTION VOID decfunc LPAREN param RPAREN LBRACE body RBRACE
    (64) call -> . ID LPAREN callp RPAREN
    (59) read -> . READ LPAREN var RPAREN SEMICOLON
    (60) print -> . PRINT LPAREN printp SEMICOLON
    (68) if -> . IF LPAREN exp RPAREN quadsIf LBRACE statements RBRACE ifelse jumpsIf SEMICOLON
    (74) while -> . WHILE LPAREN saveJumps exp RPAREN quadsWhile statements jumpsWhile whilep
    (80) for -> . FOR LPAREN var SEMICOLON exp SEMICOLON exp RPAREN LBRACKET statements forp
    (63) var -> . ID

    SEMICOLON       shift and go to state 155
    FUNCTION        shift and go to state 11
    ID              shift and go to state 57
    READ            shift and go to state 58
    PRINT           shift and go to state 59
    IF              shift and go to state 60
    WHILE           shift and go to state 61
    FOR             shift and go to state 62

    statements                     shift and go to state 153
    whilep                         shift and go to state 154
    assign                         shift and go to state 47
    function                       shift and go to state 48
    voidfunction                   shift and go to state 49
    call                           shift and go to state 50
    read                           shift and go to state 51
    print                          shift and go to state 52
    if                             shift and go to state 53
    while                          shift and go to state 54
    for                            shift and go to state 55
    var                            shift and go to state 56

state 150

    (80) for -> FOR LPAREN var SEMICOLON exp SEMICOLON exp RPAREN . LBRACKET statements forp

    LBRACKET        shift and go to state 156


state 151

    (68) if -> IF LPAREN exp RPAREN quadsIf LBRACE statements RBRACE ifelse . jumpsIf SEMICOLON
    (72) jumpsIf -> .

    SEMICOLON       reduce using rule 72 (jumpsIf -> .)

    jumpsIf                        shift and go to state 157

state 152

    (70) ifelse -> ELSE . quadsElse LBRACE statements RBRACE
    (73) quadsElse -> .

    LBRACE          reduce using rule 73 (quadsElse -> .)

    quadsElse                      shift and go to state 158

state 153

    (76) whilep -> statements . whilep
    (75) whilep -> . SEMICOLON
    (76) whilep -> . statements whilep
    (49) statements -> . assign
    (50) statements -> . function
    (51) statements -> . voidfunction
    (52) statements -> . call
    (53) statements -> . read
    (54) statements -> . print
    (55) statements -> . if
    (56) statements -> . while
    (57) statements -> . for
    (58) assign -> . var EQUAL exp SEMICOLON
    (11) function -> . FUNCTION decfunctype decfunc LPAREN param RPAREN LBRACE body RETURN exp SEMICOLON RBRACE
    (14) voidfunction -> . FUNCTION VOID decfunc LPAREN param RPAREN LBRACE body RBRACE
    (64) call -> . ID LPAREN callp RPAREN
    (59) read -> . READ LPAREN var RPAREN SEMICOLON
    (60) print -> . PRINT LPAREN printp SEMICOLON
    (68) if -> . IF LPAREN exp RPAREN quadsIf LBRACE statements RBRACE ifelse jumpsIf SEMICOLON
    (74) while -> . WHILE LPAREN saveJumps exp RPAREN quadsWhile statements jumpsWhile whilep
    (80) for -> . FOR LPAREN var SEMICOLON exp SEMICOLON exp RPAREN LBRACKET statements forp
    (63) var -> . ID

    SEMICOLON       shift and go to state 155
    FUNCTION        shift and go to state 11
    ID              shift and go to state 57
    READ            shift and go to state 58
    PRINT           shift and go to state 59
    IF              shift and go to state 60
    WHILE           shift and go to state 61
    FOR             shift and go to state 62

    statements                     shift and go to state 153
    whilep                         shift and go to state 159
    assign                         shift and go to state 47
    function                       shift and go to state 48
    voidfunction                   shift and go to state 49
    call                           shift and go to state 50
    read                           shift and go to state 51
    print                          shift and go to state 52
    if                             shift and go to state 53
    while                          shift and go to state 54
    for                            shift and go to state 55
    var                            shift and go to state 56

state 154

    (74) while -> WHILE LPAREN saveJumps exp RPAREN quadsWhile statements jumpsWhile whilep .

    VAR             reduce using rule 74 (while -> WHILE LPAREN saveJumps exp RPAREN quadsWhile statements jumpsWhile whilep .)
    FUNCTION        reduce using rule 74 (while -> WHILE LPAREN saveJumps exp RPAREN quadsWhile statements jumpsWhile whilep .)
    ID              reduce using rule 74 (while -> WHILE LPAREN saveJumps exp RPAREN quadsWhile statements jumpsWhile whilep .)
    READ            reduce using rule 74 (while -> WHILE LPAREN saveJumps exp RPAREN quadsWhile statements jumpsWhile whilep .)
    PRINT           reduce using rule 74 (while -> WHILE LPAREN saveJumps exp RPAREN quadsWhile statements jumpsWhile whilep .)
    IF              reduce using rule 74 (while -> WHILE LPAREN saveJumps exp RPAREN quadsWhile statements jumpsWhile whilep .)
    WHILE           reduce using rule 74 (while -> WHILE LPAREN saveJumps exp RPAREN quadsWhile statements jumpsWhile whilep .)
    FOR             reduce using rule 74 (while -> WHILE LPAREN saveJumps exp RPAREN quadsWhile statements jumpsWhile whilep .)
    RBRACE          reduce using rule 74 (while -> WHILE LPAREN saveJumps exp RPAREN quadsWhile statements jumpsWhile whilep .)
    RETURN          reduce using rule 74 (while -> WHILE LPAREN saveJumps exp RPAREN quadsWhile statements jumpsWhile whilep .)
    SEMICOLON       reduce using rule 74 (while -> WHILE LPAREN saveJumps exp RPAREN quadsWhile statements jumpsWhile whilep .)
    RBRACKET        reduce using rule 74 (while -> WHILE LPAREN saveJumps exp RPAREN quadsWhile statements jumpsWhile whilep .)


state 155

    (75) whilep -> SEMICOLON .

    VAR             reduce using rule 75 (whilep -> SEMICOLON .)
    FUNCTION        reduce using rule 75 (whilep -> SEMICOLON .)
    ID              reduce using rule 75 (whilep -> SEMICOLON .)
    READ            reduce using rule 75 (whilep -> SEMICOLON .)
    PRINT           reduce using rule 75 (whilep -> SEMICOLON .)
    IF              reduce using rule 75 (whilep -> SEMICOLON .)
    WHILE           reduce using rule 75 (whilep -> SEMICOLON .)
    FOR             reduce using rule 75 (whilep -> SEMICOLON .)
    RBRACE          reduce using rule 75 (whilep -> SEMICOLON .)
    RETURN          reduce using rule 75 (whilep -> SEMICOLON .)
    SEMICOLON       reduce using rule 75 (whilep -> SEMICOLON .)
    RBRACKET        reduce using rule 75 (whilep -> SEMICOLON .)


state 156

    (80) for -> FOR LPAREN var SEMICOLON exp SEMICOLON exp RPAREN LBRACKET . statements forp
    (49) statements -> . assign
    (50) statements -> . function
    (51) statements -> . voidfunction
    (52) statements -> . call
    (53) statements -> . read
    (54) statements -> . print
    (55) statements -> . if
    (56) statements -> . while
    (57) statements -> . for
    (58) assign -> . var EQUAL exp SEMICOLON
    (11) function -> . FUNCTION decfunctype decfunc LPAREN param RPAREN LBRACE body RETURN exp SEMICOLON RBRACE
    (14) voidfunction -> . FUNCTION VOID decfunc LPAREN param RPAREN LBRACE body RBRACE
    (64) call -> . ID LPAREN callp RPAREN
    (59) read -> . READ LPAREN var RPAREN SEMICOLON
    (60) print -> . PRINT LPAREN printp SEMICOLON
    (68) if -> . IF LPAREN exp RPAREN quadsIf LBRACE statements RBRACE ifelse jumpsIf SEMICOLON
    (74) while -> . WHILE LPAREN saveJumps exp RPAREN quadsWhile statements jumpsWhile whilep
    (80) for -> . FOR LPAREN var SEMICOLON exp SEMICOLON exp RPAREN LBRACKET statements forp
    (63) var -> . ID

    FUNCTION        shift and go to state 11
    ID              shift and go to state 57
    READ            shift and go to state 58
    PRINT           shift and go to state 59
    IF              shift and go to state 60
    WHILE           shift and go to state 61
    FOR             shift and go to state 62

    var                            shift and go to state 56
    statements                     shift and go to state 160
    assign                         shift and go to state 47
    function                       shift and go to state 48
    voidfunction                   shift and go to state 49
    call                           shift and go to state 50
    read                           shift and go to state 51
    print                          shift and go to state 52
    if                             shift and go to state 53
    while                          shift and go to state 54
    for                            shift and go to state 55

state 157

    (68) if -> IF LPAREN exp RPAREN quadsIf LBRACE statements RBRACE ifelse jumpsIf . SEMICOLON

    SEMICOLON       shift and go to state 161


state 158

    (70) ifelse -> ELSE quadsElse . LBRACE statements RBRACE

    LBRACE          shift and go to state 162


state 159

    (76) whilep -> statements whilep .

    VAR             reduce using rule 76 (whilep -> statements whilep .)
    FUNCTION        reduce using rule 76 (whilep -> statements whilep .)
    ID              reduce using rule 76 (whilep -> statements whilep .)
    READ            reduce using rule 76 (whilep -> statements whilep .)
    PRINT           reduce using rule 76 (whilep -> statements whilep .)
    IF              reduce using rule 76 (whilep -> statements whilep .)
    WHILE           reduce using rule 76 (whilep -> statements whilep .)
    FOR             reduce using rule 76 (whilep -> statements whilep .)
    RBRACE          reduce using rule 76 (whilep -> statements whilep .)
    RETURN          reduce using rule 76 (whilep -> statements whilep .)
    SEMICOLON       reduce using rule 76 (whilep -> statements whilep .)
    RBRACKET        reduce using rule 76 (whilep -> statements whilep .)


state 160

    (80) for -> FOR LPAREN var SEMICOLON exp SEMICOLON exp RPAREN LBRACKET statements . forp
    (81) forp -> . RBRACKET
    (82) forp -> . statements forp
    (49) statements -> . assign
    (50) statements -> . function
    (51) statements -> . voidfunction
    (52) statements -> . call
    (53) statements -> . read
    (54) statements -> . print
    (55) statements -> . if
    (56) statements -> . while
    (57) statements -> . for
    (58) assign -> . var EQUAL exp SEMICOLON
    (11) function -> . FUNCTION decfunctype decfunc LPAREN param RPAREN LBRACE body RETURN exp SEMICOLON RBRACE
    (14) voidfunction -> . FUNCTION VOID decfunc LPAREN param RPAREN LBRACE body RBRACE
    (64) call -> . ID LPAREN callp RPAREN
    (59) read -> . READ LPAREN var RPAREN SEMICOLON
    (60) print -> . PRINT LPAREN printp SEMICOLON
    (68) if -> . IF LPAREN exp RPAREN quadsIf LBRACE statements RBRACE ifelse jumpsIf SEMICOLON
    (74) while -> . WHILE LPAREN saveJumps exp RPAREN quadsWhile statements jumpsWhile whilep
    (80) for -> . FOR LPAREN var SEMICOLON exp SEMICOLON exp RPAREN LBRACKET statements forp
    (63) var -> . ID

    RBRACKET        shift and go to state 165
    FUNCTION        shift and go to state 11
    ID              shift and go to state 57
    READ            shift and go to state 58
    PRINT           shift and go to state 59
    IF              shift and go to state 60
    WHILE           shift and go to state 61
    FOR             shift and go to state 62

    var                            shift and go to state 56
    statements                     shift and go to state 163
    forp                           shift and go to state 164
    assign                         shift and go to state 47
    function                       shift and go to state 48
    voidfunction                   shift and go to state 49
    call                           shift and go to state 50
    read                           shift and go to state 51
    print                          shift and go to state 52
    if                             shift and go to state 53
    while                          shift and go to state 54
    for                            shift and go to state 55

state 161

    (68) if -> IF LPAREN exp RPAREN quadsIf LBRACE statements RBRACE ifelse jumpsIf SEMICOLON .

    VAR             reduce using rule 68 (if -> IF LPAREN exp RPAREN quadsIf LBRACE statements RBRACE ifelse jumpsIf SEMICOLON .)
    FUNCTION        reduce using rule 68 (if -> IF LPAREN exp RPAREN quadsIf LBRACE statements RBRACE ifelse jumpsIf SEMICOLON .)
    ID              reduce using rule 68 (if -> IF LPAREN exp RPAREN quadsIf LBRACE statements RBRACE ifelse jumpsIf SEMICOLON .)
    READ            reduce using rule 68 (if -> IF LPAREN exp RPAREN quadsIf LBRACE statements RBRACE ifelse jumpsIf SEMICOLON .)
    PRINT           reduce using rule 68 (if -> IF LPAREN exp RPAREN quadsIf LBRACE statements RBRACE ifelse jumpsIf SEMICOLON .)
    IF              reduce using rule 68 (if -> IF LPAREN exp RPAREN quadsIf LBRACE statements RBRACE ifelse jumpsIf SEMICOLON .)
    WHILE           reduce using rule 68 (if -> IF LPAREN exp RPAREN quadsIf LBRACE statements RBRACE ifelse jumpsIf SEMICOLON .)
    FOR             reduce using rule 68 (if -> IF LPAREN exp RPAREN quadsIf LBRACE statements RBRACE ifelse jumpsIf SEMICOLON .)
    RBRACE          reduce using rule 68 (if -> IF LPAREN exp RPAREN quadsIf LBRACE statements RBRACE ifelse jumpsIf SEMICOLON .)
    RETURN          reduce using rule 68 (if -> IF LPAREN exp RPAREN quadsIf LBRACE statements RBRACE ifelse jumpsIf SEMICOLON .)
    SEMICOLON       reduce using rule 68 (if -> IF LPAREN exp RPAREN quadsIf LBRACE statements RBRACE ifelse jumpsIf SEMICOLON .)
    RBRACKET        reduce using rule 68 (if -> IF LPAREN exp RPAREN quadsIf LBRACE statements RBRACE ifelse jumpsIf SEMICOLON .)


state 162

    (70) ifelse -> ELSE quadsElse LBRACE . statements RBRACE
    (49) statements -> . assign
    (50) statements -> . function
    (51) statements -> . voidfunction
    (52) statements -> . call
    (53) statements -> . read
    (54) statements -> . print
    (55) statements -> . if
    (56) statements -> . while
    (57) statements -> . for
    (58) assign -> . var EQUAL exp SEMICOLON
    (11) function -> . FUNCTION decfunctype decfunc LPAREN param RPAREN LBRACE body RETURN exp SEMICOLON RBRACE
    (14) voidfunction -> . FUNCTION VOID decfunc LPAREN param RPAREN LBRACE body RBRACE
    (64) call -> . ID LPAREN callp RPAREN
    (59) read -> . READ LPAREN var RPAREN SEMICOLON
    (60) print -> . PRINT LPAREN printp SEMICOLON
    (68) if -> . IF LPAREN exp RPAREN quadsIf LBRACE statements RBRACE ifelse jumpsIf SEMICOLON
    (74) while -> . WHILE LPAREN saveJumps exp RPAREN quadsWhile statements jumpsWhile whilep
    (80) for -> . FOR LPAREN var SEMICOLON exp SEMICOLON exp RPAREN LBRACKET statements forp
    (63) var -> . ID

    FUNCTION        shift and go to state 11
    ID              shift and go to state 57
    READ            shift and go to state 58
    PRINT           shift and go to state 59
    IF              shift and go to state 60
    WHILE           shift and go to state 61
    FOR             shift and go to state 62

    statements                     shift and go to state 166
    assign                         shift and go to state 47
    function                       shift and go to state 48
    voidfunction                   shift and go to state 49
    call                           shift and go to state 50
    read                           shift and go to state 51
    print                          shift and go to state 52
    if                             shift and go to state 53
    while                          shift and go to state 54
    for                            shift and go to state 55
    var                            shift and go to state 56

state 163

    (82) forp -> statements . forp
    (81) forp -> . RBRACKET
    (82) forp -> . statements forp
    (49) statements -> . assign
    (50) statements -> . function
    (51) statements -> . voidfunction
    (52) statements -> . call
    (53) statements -> . read
    (54) statements -> . print
    (55) statements -> . if
    (56) statements -> . while
    (57) statements -> . for
    (58) assign -> . var EQUAL exp SEMICOLON
    (11) function -> . FUNCTION decfunctype decfunc LPAREN param RPAREN LBRACE body RETURN exp SEMICOLON RBRACE
    (14) voidfunction -> . FUNCTION VOID decfunc LPAREN param RPAREN LBRACE body RBRACE
    (64) call -> . ID LPAREN callp RPAREN
    (59) read -> . READ LPAREN var RPAREN SEMICOLON
    (60) print -> . PRINT LPAREN printp SEMICOLON
    (68) if -> . IF LPAREN exp RPAREN quadsIf LBRACE statements RBRACE ifelse jumpsIf SEMICOLON
    (74) while -> . WHILE LPAREN saveJumps exp RPAREN quadsWhile statements jumpsWhile whilep
    (80) for -> . FOR LPAREN var SEMICOLON exp SEMICOLON exp RPAREN LBRACKET statements forp
    (63) var -> . ID

    RBRACKET        shift and go to state 165
    FUNCTION        shift and go to state 11
    ID              shift and go to state 57
    READ            shift and go to state 58
    PRINT           shift and go to state 59
    IF              shift and go to state 60
    WHILE           shift and go to state 61
    FOR             shift and go to state 62

    statements                     shift and go to state 163
    forp                           shift and go to state 167
    assign                         shift and go to state 47
    function                       shift and go to state 48
    voidfunction                   shift and go to state 49
    call                           shift and go to state 50
    read                           shift and go to state 51
    print                          shift and go to state 52
    if                             shift and go to state 53
    while                          shift and go to state 54
    for                            shift and go to state 55
    var                            shift and go to state 56

state 164

    (80) for -> FOR LPAREN var SEMICOLON exp SEMICOLON exp RPAREN LBRACKET statements forp .

    VAR             reduce using rule 80 (for -> FOR LPAREN var SEMICOLON exp SEMICOLON exp RPAREN LBRACKET statements forp .)
    FUNCTION        reduce using rule 80 (for -> FOR LPAREN var SEMICOLON exp SEMICOLON exp RPAREN LBRACKET statements forp .)
    ID              reduce using rule 80 (for -> FOR LPAREN var SEMICOLON exp SEMICOLON exp RPAREN LBRACKET statements forp .)
    READ            reduce using rule 80 (for -> FOR LPAREN var SEMICOLON exp SEMICOLON exp RPAREN LBRACKET statements forp .)
    PRINT           reduce using rule 80 (for -> FOR LPAREN var SEMICOLON exp SEMICOLON exp RPAREN LBRACKET statements forp .)
    IF              reduce using rule 80 (for -> FOR LPAREN var SEMICOLON exp SEMICOLON exp RPAREN LBRACKET statements forp .)
    WHILE           reduce using rule 80 (for -> FOR LPAREN var SEMICOLON exp SEMICOLON exp RPAREN LBRACKET statements forp .)
    FOR             reduce using rule 80 (for -> FOR LPAREN var SEMICOLON exp SEMICOLON exp RPAREN LBRACKET statements forp .)
    RBRACE          reduce using rule 80 (for -> FOR LPAREN var SEMICOLON exp SEMICOLON exp RPAREN LBRACKET statements forp .)
    RETURN          reduce using rule 80 (for -> FOR LPAREN var SEMICOLON exp SEMICOLON exp RPAREN LBRACKET statements forp .)
    SEMICOLON       reduce using rule 80 (for -> FOR LPAREN var SEMICOLON exp SEMICOLON exp RPAREN LBRACKET statements forp .)
    RBRACKET        reduce using rule 80 (for -> FOR LPAREN var SEMICOLON exp SEMICOLON exp RPAREN LBRACKET statements forp .)


state 165

    (81) forp -> RBRACKET .

    VAR             reduce using rule 81 (forp -> RBRACKET .)
    FUNCTION        reduce using rule 81 (forp -> RBRACKET .)
    ID              reduce using rule 81 (forp -> RBRACKET .)
    READ            reduce using rule 81 (forp -> RBRACKET .)
    PRINT           reduce using rule 81 (forp -> RBRACKET .)
    IF              reduce using rule 81 (forp -> RBRACKET .)
    WHILE           reduce using rule 81 (forp -> RBRACKET .)
    FOR             reduce using rule 81 (forp -> RBRACKET .)
    RBRACE          reduce using rule 81 (forp -> RBRACKET .)
    RETURN          reduce using rule 81 (forp -> RBRACKET .)
    SEMICOLON       reduce using rule 81 (forp -> RBRACKET .)
    RBRACKET        reduce using rule 81 (forp -> RBRACKET .)


state 166

    (70) ifelse -> ELSE quadsElse LBRACE statements . RBRACE

    RBRACE          shift and go to state 168


state 167

    (82) forp -> statements forp .

    VAR             reduce using rule 82 (forp -> statements forp .)
    FUNCTION        reduce using rule 82 (forp -> statements forp .)
    ID              reduce using rule 82 (forp -> statements forp .)
    READ            reduce using rule 82 (forp -> statements forp .)
    PRINT           reduce using rule 82 (forp -> statements forp .)
    IF              reduce using rule 82 (forp -> statements forp .)
    WHILE           reduce using rule 82 (forp -> statements forp .)
    FOR             reduce using rule 82 (forp -> statements forp .)
    RBRACE          reduce using rule 82 (forp -> statements forp .)
    RETURN          reduce using rule 82 (forp -> statements forp .)
    SEMICOLON       reduce using rule 82 (forp -> statements forp .)
    RBRACKET        reduce using rule 82 (forp -> statements forp .)


state 168

    (70) ifelse -> ELSE quadsElse LBRACE statements RBRACE .

    SEMICOLON       reduce using rule 70 (ifelse -> ELSE quadsElse LBRACE statements RBRACE .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for FUNCTION in state 40 resolved as shift
WARNING: shift/reduce conflict for ID in state 40 resolved as shift
WARNING: shift/reduce conflict for READ in state 40 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 40 resolved as shift
WARNING: shift/reduce conflict for IF in state 40 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 40 resolved as shift
WARNING: shift/reduce conflict for FOR in state 40 resolved as shift
WARNING: shift/reduce conflict for FUNCTION in state 46 resolved as shift
WARNING: shift/reduce conflict for ID in state 46 resolved as shift
WARNING: shift/reduce conflict for READ in state 46 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 46 resolved as shift
WARNING: shift/reduce conflict for IF in state 46 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 46 resolved as shift
WARNING: shift/reduce conflict for FOR in state 46 resolved as shift
WARNING: shift/reduce conflict for FUNCTION in state 63 resolved as shift
WARNING: shift/reduce conflict for ID in state 63 resolved as shift
WARNING: shift/reduce conflict for READ in state 63 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 63 resolved as shift
WARNING: shift/reduce conflict for IF in state 63 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 63 resolved as shift
WARNING: shift/reduce conflict for FOR in state 63 resolved as shift
WARNING: shift/reduce conflict for FUNCTION in state 65 resolved as shift
WARNING: shift/reduce conflict for ID in state 65 resolved as shift
WARNING: shift/reduce conflict for READ in state 65 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 65 resolved as shift
WARNING: shift/reduce conflict for IF in state 65 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 65 resolved as shift
WARNING: shift/reduce conflict for FOR in state 65 resolved as shift
WARNING: shift/reduce conflict for FUNCTION in state 67 resolved as shift
WARNING: shift/reduce conflict for ID in state 67 resolved as shift
WARNING: shift/reduce conflict for READ in state 67 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 67 resolved as shift
WARNING: shift/reduce conflict for IF in state 67 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 67 resolved as shift
WARNING: shift/reduce conflict for FOR in state 67 resolved as shift
WARNING: reduce/reduce conflict in state 12 resolved using rule (decvar -> VAR decvarp)
WARNING: rejected rule (decvar -> <empty>) in state 12
WARNING: reduce/reduce conflict in state 40 resolved using rule (decvar -> <empty>)
WARNING: rejected rule (body -> <empty>) in state 40
WARNING: reduce/reduce conflict in state 46 resolved using rule (decvar -> <empty>)
WARNING: rejected rule (body -> <empty>) in state 46
WARNING: reduce/reduce conflict in state 63 resolved using rule (decvar -> <empty>)
WARNING: rejected rule (body -> <empty>) in state 63
WARNING: reduce/reduce conflict in state 65 resolved using rule (decvar -> <empty>)
WARNING: rejected rule (body -> <empty>) in state 65
WARNING: reduce/reduce conflict in state 67 resolved using rule (decvar -> <empty>)
WARNING: rejected rule (body -> <empty>) in state 67
WARNING: Rule (body -> <empty>) is never reduced
