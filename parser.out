Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    ASSIGN
    CHAR
    COLON
    CTF
    FUNCESP
    GTE
    LTE
    NUMPY
    QUOTE
    STRING

Grammar

Rule 0     S' -> program
Rule 1     program -> PROGRAM ID SEMICOLON if
Rule 2     decvar -> VAR decvarp
Rule 3     decvar -> VAR decvarp decvar
Rule 4     decvarp -> type decvarpp SEMICOLON
Rule 5     decvarpp -> ID COMMA decvarpp
Rule 6     decvarpp -> ID
Rule 7     type -> INT
Rule 8     type -> FLOAT
Rule 9     function -> FUNCTION type ID LPAREN param RPAREN body
Rule 10    voidfunction -> FUNCTION VOID ID LPAREN param RPAREN body
Rule 11    body -> LBRACE bodyp RBRACE
Rule 12    bodyp -> decvar statements bodyp
Rule 13    bodyp -> statements bodyp
Rule 14    bodyp -> decvar
Rule 15    bodyp -> <empty>
Rule 16    param -> <empty>
Rule 17    param -> type paramp
Rule 18    paramp -> ID
Rule 19    paramp -> ID COMMA param
Rule 20    exp -> texp
Rule 21    exp -> texp OR exp
Rule 22    texp -> gexp
Rule 23    texp -> gexp AND texp
Rule 24    gexp -> mexp
Rule 25    gexp -> mexp gexpp mexp
Rule 26    gexpp -> LT
Rule 27    gexpp -> GT
Rule 28    gexpp -> EQUAL
Rule 29    gexpp -> DIFF
Rule 30    mexp -> t
Rule 31    mexp -> t PLUS mexp
Rule 32    mexp -> t MINUS mexp
Rule 33    t -> f
Rule 34    t -> f MULT t
Rule 35    t -> f DIV t
Rule 36    f -> LPAREN exp RPAREN
Rule 37    f -> INT
Rule 38    f -> FLOAT
Rule 39    f -> var
Rule 40    f -> call
Rule 41    statements -> assign
Rule 42    statements -> function
Rule 43    statements -> voidfunction
Rule 44    statements -> call
Rule 45    statements -> read
Rule 46    statements -> print
Rule 47    statements -> if
Rule 48    statements -> while
Rule 49    statements -> for
Rule 50    statements -> funcesp
Rule 51    assign -> var EQUAL exp
Rule 52    read -> READ var
Rule 53    print -> PRINT LPAREN printp
Rule 54    printp -> exp RPAREN
Rule 55    printp -> exp COMMA printp
Rule 56    var -> ID
Rule 57    var -> ID LBRACKET exp RBRACKET
Rule 58    var -> ID LBRACKET exp RBRACKET LBRACKET exp RBRACKET
Rule 59    call -> ID LPAREN callp RPAREN
Rule 60    callp -> exp SEMICOLON callp
Rule 61    callp -> exp
Rule 62    if -> IF LPAREN INT EQUAL EQUAL CTI RPAREN quadsIf ifp jumpsIf
Rule 63    ifp -> <empty>
Rule 64    ifp -> ELSE quadsElse statements
Rule 65    quadsIf -> <empty>
Rule 66    jumpsIf -> <empty>
Rule 67    quadsElse -> <empty>
Rule 68    while -> WHILE LPAREN exp RPAREN statements whilep
Rule 69    whilep -> SEMICOLON
Rule 70    whilep -> statements whilep
Rule 71    for -> FOR LPAREN var SEMICOLON exp SEMICOLON exp RPAREN LBRACKET statements forp
Rule 72    forp -> RBRACKET
Rule 73    forp -> statements forp
Rule 74    funcesp -> array
Rule 75    funcesp -> matrix
Rule 76    funcesp -> mean
Rule 77    funcesp -> layers
Rule 78    funcesp -> sequential
Rule 79    funcesp -> compile
Rule 80    funcesp -> fit
Rule 81    funcesp -> predict
Rule 82    funcesp -> getweights
Rule 83    array -> ID EQUAL ARRAY LPAREN var arrayp
Rule 84    arrayp -> RPAREN
Rule 85    arrayp -> COMMA var RPAREN
Rule 86    matrix -> ID EQUAL MATRIX LPAREN array matrixp
Rule 87    matrixp -> RPAREN
Rule 88    matrixp -> COMMA array RPAREN
Rule 89    mean -> MEAN LPAREN array RPAREN
Rule 90    layers -> ID EQUAL LAYERS LPAREN UNITS EQUAL INT RPAREN
Rule 91    sequential -> ID EQUAL SEQUENTIAL LPAREN LBRACKET layers sequentialp
Rule 92    sequentialp -> RBRACKET RPAREN
Rule 93    sequentialp -> COMMA layers sequentialp
Rule 94    compile -> sequential DOT COMPILE LPAREN RPAREN
Rule 95    fit -> ID EQUAL sequential DOT FIT LPAREN array COMMA array COMMA EPOCHS EQUAL INT COMMA VERBOSE EQUAL fitp
Rule 96    fitp -> TRUE RPAREN
Rule 97    fitp -> FALSE RPAREN
Rule 98    predict -> ID EQUAL sequential DOT PREDICT LPAREN LBRACKET predictp
Rule 99    predictp -> INT RBRACKET RPAREN
Rule 100   predictp -> FLOAT RBRACKET RPAREN
Rule 101   getweights -> layers DOT GETWEIGHTS LPAREN RPAREN
Rule 102   empty -> <empty>

Terminals, with rules where they appear

AND                  : 23
ARRAY                : 83
ASSIGN               : 
CHAR                 : 
COLON                : 
COMMA                : 5 19 55 85 88 93 95 95 95
COMPILE              : 94
CTF                  : 
CTI                  : 62
DIFF                 : 29
DIV                  : 35
DOT                  : 94 95 98 101
ELSE                 : 64
EPOCHS               : 95
EQUAL                : 28 51 62 62 83 86 90 90 91 95 95 95 98
FALSE                : 97
FIT                  : 95
FLOAT                : 8 38 100
FOR                  : 71
FUNCESP              : 
FUNCTION             : 9 10
GETWEIGHTS           : 101
GT                   : 27
GTE                  : 
ID                   : 1 5 6 9 10 18 19 56 57 58 59 83 86 90 91 95 98
IF                   : 62
INT                  : 7 37 62 90 95 99
LAYERS               : 90
LBRACE               : 11
LBRACKET             : 57 58 58 71 91 98
LPAREN               : 9 10 36 53 59 62 68 71 83 86 89 90 91 94 95 98 101
LT                   : 26
LTE                  : 
MATRIX               : 86
MEAN                 : 89
MINUS                : 32
MULT                 : 34
NUMPY                : 
OR                   : 21
PLUS                 : 31
PREDICT              : 98
PRINT                : 53
PROGRAM              : 1
QUOTE                : 
RBRACE               : 11
RBRACKET             : 57 58 58 72 92 99 100
READ                 : 52
RPAREN               : 9 10 36 54 59 62 68 71 84 85 87 88 89 90 92 94 96 97 99 100 101
SEMICOLON            : 1 4 60 69 71 71
SEQUENTIAL           : 91
STRING               : 
TRUE                 : 96
UNITS                : 90
VAR                  : 2 3
VERBOSE              : 95
VOID                 : 10
WHILE                : 68
error                : 

Nonterminals, with rules where they appear

array                : 74 86 88 89 95 95
arrayp               : 83
assign               : 41
body                 : 9 10
bodyp                : 11 12 13
call                 : 40 44
callp                : 59 60
compile              : 79
decvar               : 3 12 14
decvarp              : 2 3
decvarpp             : 4 5
empty                : 
exp                  : 21 36 51 54 55 57 58 58 60 61 68 71 71
f                    : 33 34 35
fit                  : 80
fitp                 : 95
for                  : 49
forp                 : 71 73
funcesp              : 50
function             : 42
getweights           : 82
gexp                 : 22 23
gexpp                : 25
if                   : 1 47
ifp                  : 62
jumpsIf              : 62
layers               : 77 91 93 101
matrix               : 75
matrixp              : 86
mean                 : 76
mexp                 : 24 25 25 31 32
param                : 9 10 19
paramp               : 17
predict              : 81
predictp             : 98
print                : 46
printp               : 53 55
program              : 0
quadsElse            : 64
quadsIf              : 62
read                 : 45
sequential           : 78 94 95 98
sequentialp          : 91 93
statements           : 12 13 64 68 70 71 73
t                    : 30 31 32 34 35
texp                 : 20 21 23
type                 : 4 9 17
var                  : 39 51 52 71 83 85
voidfunction         : 43
while                : 48
whilep               : 68 70

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . PROGRAM ID SEMICOLON if

    PROGRAM         shift and go to state 2

    program                        shift and go to state 1

state 1

    (0) S' -> program .



state 2

    (1) program -> PROGRAM . ID SEMICOLON if

    ID              shift and go to state 3


state 3

    (1) program -> PROGRAM ID . SEMICOLON if

    SEMICOLON       shift and go to state 4


state 4

    (1) program -> PROGRAM ID SEMICOLON . if
    (62) if -> . IF LPAREN INT EQUAL EQUAL CTI RPAREN quadsIf ifp jumpsIf

    IF              shift and go to state 6

    if                             shift and go to state 5

state 5

    (1) program -> PROGRAM ID SEMICOLON if .

    $end            reduce using rule 1 (program -> PROGRAM ID SEMICOLON if .)


state 6

    (62) if -> IF . LPAREN INT EQUAL EQUAL CTI RPAREN quadsIf ifp jumpsIf

    LPAREN          shift and go to state 7


state 7

    (62) if -> IF LPAREN . INT EQUAL EQUAL CTI RPAREN quadsIf ifp jumpsIf

    INT             shift and go to state 8


state 8

    (62) if -> IF LPAREN INT . EQUAL EQUAL CTI RPAREN quadsIf ifp jumpsIf

    EQUAL           shift and go to state 9


state 9

    (62) if -> IF LPAREN INT EQUAL . EQUAL CTI RPAREN quadsIf ifp jumpsIf

    EQUAL           shift and go to state 10


state 10

    (62) if -> IF LPAREN INT EQUAL EQUAL . CTI RPAREN quadsIf ifp jumpsIf

    CTI             shift and go to state 11


state 11

    (62) if -> IF LPAREN INT EQUAL EQUAL CTI . RPAREN quadsIf ifp jumpsIf

    RPAREN          shift and go to state 12


state 12

    (62) if -> IF LPAREN INT EQUAL EQUAL CTI RPAREN . quadsIf ifp jumpsIf
    (65) quadsIf -> .

    ELSE            reduce using rule 65 (quadsIf -> .)
    $end            reduce using rule 65 (quadsIf -> .)
    SEMICOLON       reduce using rule 65 (quadsIf -> .)
    FUNCTION        reduce using rule 65 (quadsIf -> .)
    ID              reduce using rule 65 (quadsIf -> .)
    READ            reduce using rule 65 (quadsIf -> .)
    PRINT           reduce using rule 65 (quadsIf -> .)
    IF              reduce using rule 65 (quadsIf -> .)
    WHILE           reduce using rule 65 (quadsIf -> .)
    FOR             reduce using rule 65 (quadsIf -> .)
    MEAN            reduce using rule 65 (quadsIf -> .)
    VAR             reduce using rule 65 (quadsIf -> .)
    RBRACE          reduce using rule 65 (quadsIf -> .)
    RBRACKET        reduce using rule 65 (quadsIf -> .)

    quadsIf                        shift and go to state 13

state 13

    (62) if -> IF LPAREN INT EQUAL EQUAL CTI RPAREN quadsIf . ifp jumpsIf
    (63) ifp -> .
    (64) ifp -> . ELSE quadsElse statements

    $end            reduce using rule 63 (ifp -> .)
    SEMICOLON       reduce using rule 63 (ifp -> .)
    FUNCTION        reduce using rule 63 (ifp -> .)
    ID              reduce using rule 63 (ifp -> .)
    READ            reduce using rule 63 (ifp -> .)
    PRINT           reduce using rule 63 (ifp -> .)
    IF              reduce using rule 63 (ifp -> .)
    WHILE           reduce using rule 63 (ifp -> .)
    FOR             reduce using rule 63 (ifp -> .)
    MEAN            reduce using rule 63 (ifp -> .)
    VAR             reduce using rule 63 (ifp -> .)
    RBRACE          reduce using rule 63 (ifp -> .)
    RBRACKET        reduce using rule 63 (ifp -> .)
    ELSE            shift and go to state 15

    ifp                            shift and go to state 14

state 14

    (62) if -> IF LPAREN INT EQUAL EQUAL CTI RPAREN quadsIf ifp . jumpsIf
    (66) jumpsIf -> .

    $end            reduce using rule 66 (jumpsIf -> .)
    SEMICOLON       reduce using rule 66 (jumpsIf -> .)
    FUNCTION        reduce using rule 66 (jumpsIf -> .)
    ID              reduce using rule 66 (jumpsIf -> .)
    READ            reduce using rule 66 (jumpsIf -> .)
    PRINT           reduce using rule 66 (jumpsIf -> .)
    IF              reduce using rule 66 (jumpsIf -> .)
    WHILE           reduce using rule 66 (jumpsIf -> .)
    FOR             reduce using rule 66 (jumpsIf -> .)
    MEAN            reduce using rule 66 (jumpsIf -> .)
    VAR             reduce using rule 66 (jumpsIf -> .)
    RBRACE          reduce using rule 66 (jumpsIf -> .)
    RBRACKET        reduce using rule 66 (jumpsIf -> .)

    jumpsIf                        shift and go to state 16

state 15

    (64) ifp -> ELSE . quadsElse statements
    (67) quadsElse -> .

    FUNCTION        reduce using rule 67 (quadsElse -> .)
    ID              reduce using rule 67 (quadsElse -> .)
    READ            reduce using rule 67 (quadsElse -> .)
    PRINT           reduce using rule 67 (quadsElse -> .)
    IF              reduce using rule 67 (quadsElse -> .)
    WHILE           reduce using rule 67 (quadsElse -> .)
    FOR             reduce using rule 67 (quadsElse -> .)
    MEAN            reduce using rule 67 (quadsElse -> .)

    quadsElse                      shift and go to state 17

state 16

    (62) if -> IF LPAREN INT EQUAL EQUAL CTI RPAREN quadsIf ifp jumpsIf .

    $end            reduce using rule 62 (if -> IF LPAREN INT EQUAL EQUAL CTI RPAREN quadsIf ifp jumpsIf .)
    SEMICOLON       reduce using rule 62 (if -> IF LPAREN INT EQUAL EQUAL CTI RPAREN quadsIf ifp jumpsIf .)
    FUNCTION        reduce using rule 62 (if -> IF LPAREN INT EQUAL EQUAL CTI RPAREN quadsIf ifp jumpsIf .)
    ID              reduce using rule 62 (if -> IF LPAREN INT EQUAL EQUAL CTI RPAREN quadsIf ifp jumpsIf .)
    READ            reduce using rule 62 (if -> IF LPAREN INT EQUAL EQUAL CTI RPAREN quadsIf ifp jumpsIf .)
    PRINT           reduce using rule 62 (if -> IF LPAREN INT EQUAL EQUAL CTI RPAREN quadsIf ifp jumpsIf .)
    IF              reduce using rule 62 (if -> IF LPAREN INT EQUAL EQUAL CTI RPAREN quadsIf ifp jumpsIf .)
    WHILE           reduce using rule 62 (if -> IF LPAREN INT EQUAL EQUAL CTI RPAREN quadsIf ifp jumpsIf .)
    FOR             reduce using rule 62 (if -> IF LPAREN INT EQUAL EQUAL CTI RPAREN quadsIf ifp jumpsIf .)
    MEAN            reduce using rule 62 (if -> IF LPAREN INT EQUAL EQUAL CTI RPAREN quadsIf ifp jumpsIf .)
    VAR             reduce using rule 62 (if -> IF LPAREN INT EQUAL EQUAL CTI RPAREN quadsIf ifp jumpsIf .)
    RBRACE          reduce using rule 62 (if -> IF LPAREN INT EQUAL EQUAL CTI RPAREN quadsIf ifp jumpsIf .)
    RBRACKET        reduce using rule 62 (if -> IF LPAREN INT EQUAL EQUAL CTI RPAREN quadsIf ifp jumpsIf .)


state 17

    (64) ifp -> ELSE quadsElse . statements
    (41) statements -> . assign
    (42) statements -> . function
    (43) statements -> . voidfunction
    (44) statements -> . call
    (45) statements -> . read
    (46) statements -> . print
    (47) statements -> . if
    (48) statements -> . while
    (49) statements -> . for
    (50) statements -> . funcesp
    (51) assign -> . var EQUAL exp
    (9) function -> . FUNCTION type ID LPAREN param RPAREN body
    (10) voidfunction -> . FUNCTION VOID ID LPAREN param RPAREN body
    (59) call -> . ID LPAREN callp RPAREN
    (52) read -> . READ var
    (53) print -> . PRINT LPAREN printp
    (62) if -> . IF LPAREN INT EQUAL EQUAL CTI RPAREN quadsIf ifp jumpsIf
    (68) while -> . WHILE LPAREN exp RPAREN statements whilep
    (71) for -> . FOR LPAREN var SEMICOLON exp SEMICOLON exp RPAREN LBRACKET statements forp
    (74) funcesp -> . array
    (75) funcesp -> . matrix
    (76) funcesp -> . mean
    (77) funcesp -> . layers
    (78) funcesp -> . sequential
    (79) funcesp -> . compile
    (80) funcesp -> . fit
    (81) funcesp -> . predict
    (82) funcesp -> . getweights
    (56) var -> . ID
    (57) var -> . ID LBRACKET exp RBRACKET
    (58) var -> . ID LBRACKET exp RBRACKET LBRACKET exp RBRACKET
    (83) array -> . ID EQUAL ARRAY LPAREN var arrayp
    (86) matrix -> . ID EQUAL MATRIX LPAREN array matrixp
    (89) mean -> . MEAN LPAREN array RPAREN
    (90) layers -> . ID EQUAL LAYERS LPAREN UNITS EQUAL INT RPAREN
    (91) sequential -> . ID EQUAL SEQUENTIAL LPAREN LBRACKET layers sequentialp
    (94) compile -> . sequential DOT COMPILE LPAREN RPAREN
    (95) fit -> . ID EQUAL sequential DOT FIT LPAREN array COMMA array COMMA EPOCHS EQUAL INT COMMA VERBOSE EQUAL fitp
    (98) predict -> . ID EQUAL sequential DOT PREDICT LPAREN LBRACKET predictp
    (101) getweights -> . layers DOT GETWEIGHTS LPAREN RPAREN

    FUNCTION        shift and go to state 30
    ID              shift and go to state 31
    READ            shift and go to state 32
    PRINT           shift and go to state 33
    IF              shift and go to state 6
    WHILE           shift and go to state 34
    FOR             shift and go to state 35
    MEAN            shift and go to state 45

    statements                     shift and go to state 18
    assign                         shift and go to state 19
    function                       shift and go to state 20
    voidfunction                   shift and go to state 21
    call                           shift and go to state 22
    read                           shift and go to state 23
    print                          shift and go to state 24
    if                             shift and go to state 25
    while                          shift and go to state 26
    for                            shift and go to state 27
    funcesp                        shift and go to state 28
    var                            shift and go to state 29
    array                          shift and go to state 36
    matrix                         shift and go to state 37
    mean                           shift and go to state 38
    layers                         shift and go to state 39
    sequential                     shift and go to state 40
    compile                        shift and go to state 41
    fit                            shift and go to state 42
    predict                        shift and go to state 43
    getweights                     shift and go to state 44

state 18

    (64) ifp -> ELSE quadsElse statements .

    $end            reduce using rule 64 (ifp -> ELSE quadsElse statements .)
    SEMICOLON       reduce using rule 64 (ifp -> ELSE quadsElse statements .)
    FUNCTION        reduce using rule 64 (ifp -> ELSE quadsElse statements .)
    ID              reduce using rule 64 (ifp -> ELSE quadsElse statements .)
    READ            reduce using rule 64 (ifp -> ELSE quadsElse statements .)
    PRINT           reduce using rule 64 (ifp -> ELSE quadsElse statements .)
    IF              reduce using rule 64 (ifp -> ELSE quadsElse statements .)
    WHILE           reduce using rule 64 (ifp -> ELSE quadsElse statements .)
    FOR             reduce using rule 64 (ifp -> ELSE quadsElse statements .)
    MEAN            reduce using rule 64 (ifp -> ELSE quadsElse statements .)
    VAR             reduce using rule 64 (ifp -> ELSE quadsElse statements .)
    RBRACE          reduce using rule 64 (ifp -> ELSE quadsElse statements .)
    RBRACKET        reduce using rule 64 (ifp -> ELSE quadsElse statements .)


state 19

    (41) statements -> assign .

    $end            reduce using rule 41 (statements -> assign .)
    SEMICOLON       reduce using rule 41 (statements -> assign .)
    FUNCTION        reduce using rule 41 (statements -> assign .)
    ID              reduce using rule 41 (statements -> assign .)
    READ            reduce using rule 41 (statements -> assign .)
    PRINT           reduce using rule 41 (statements -> assign .)
    IF              reduce using rule 41 (statements -> assign .)
    WHILE           reduce using rule 41 (statements -> assign .)
    FOR             reduce using rule 41 (statements -> assign .)
    MEAN            reduce using rule 41 (statements -> assign .)
    VAR             reduce using rule 41 (statements -> assign .)
    RBRACE          reduce using rule 41 (statements -> assign .)
    RBRACKET        reduce using rule 41 (statements -> assign .)


state 20

    (42) statements -> function .

    $end            reduce using rule 42 (statements -> function .)
    SEMICOLON       reduce using rule 42 (statements -> function .)
    FUNCTION        reduce using rule 42 (statements -> function .)
    ID              reduce using rule 42 (statements -> function .)
    READ            reduce using rule 42 (statements -> function .)
    PRINT           reduce using rule 42 (statements -> function .)
    IF              reduce using rule 42 (statements -> function .)
    WHILE           reduce using rule 42 (statements -> function .)
    FOR             reduce using rule 42 (statements -> function .)
    MEAN            reduce using rule 42 (statements -> function .)
    VAR             reduce using rule 42 (statements -> function .)
    RBRACE          reduce using rule 42 (statements -> function .)
    RBRACKET        reduce using rule 42 (statements -> function .)


state 21

    (43) statements -> voidfunction .

    $end            reduce using rule 43 (statements -> voidfunction .)
    SEMICOLON       reduce using rule 43 (statements -> voidfunction .)
    FUNCTION        reduce using rule 43 (statements -> voidfunction .)
    ID              reduce using rule 43 (statements -> voidfunction .)
    READ            reduce using rule 43 (statements -> voidfunction .)
    PRINT           reduce using rule 43 (statements -> voidfunction .)
    IF              reduce using rule 43 (statements -> voidfunction .)
    WHILE           reduce using rule 43 (statements -> voidfunction .)
    FOR             reduce using rule 43 (statements -> voidfunction .)
    MEAN            reduce using rule 43 (statements -> voidfunction .)
    VAR             reduce using rule 43 (statements -> voidfunction .)
    RBRACE          reduce using rule 43 (statements -> voidfunction .)
    RBRACKET        reduce using rule 43 (statements -> voidfunction .)


state 22

    (44) statements -> call .

    $end            reduce using rule 44 (statements -> call .)
    SEMICOLON       reduce using rule 44 (statements -> call .)
    FUNCTION        reduce using rule 44 (statements -> call .)
    ID              reduce using rule 44 (statements -> call .)
    READ            reduce using rule 44 (statements -> call .)
    PRINT           reduce using rule 44 (statements -> call .)
    IF              reduce using rule 44 (statements -> call .)
    WHILE           reduce using rule 44 (statements -> call .)
    FOR             reduce using rule 44 (statements -> call .)
    MEAN            reduce using rule 44 (statements -> call .)
    VAR             reduce using rule 44 (statements -> call .)
    RBRACE          reduce using rule 44 (statements -> call .)
    RBRACKET        reduce using rule 44 (statements -> call .)


state 23

    (45) statements -> read .

    $end            reduce using rule 45 (statements -> read .)
    SEMICOLON       reduce using rule 45 (statements -> read .)
    FUNCTION        reduce using rule 45 (statements -> read .)
    ID              reduce using rule 45 (statements -> read .)
    READ            reduce using rule 45 (statements -> read .)
    PRINT           reduce using rule 45 (statements -> read .)
    IF              reduce using rule 45 (statements -> read .)
    WHILE           reduce using rule 45 (statements -> read .)
    FOR             reduce using rule 45 (statements -> read .)
    MEAN            reduce using rule 45 (statements -> read .)
    VAR             reduce using rule 45 (statements -> read .)
    RBRACE          reduce using rule 45 (statements -> read .)
    RBRACKET        reduce using rule 45 (statements -> read .)


state 24

    (46) statements -> print .

    $end            reduce using rule 46 (statements -> print .)
    SEMICOLON       reduce using rule 46 (statements -> print .)
    FUNCTION        reduce using rule 46 (statements -> print .)
    ID              reduce using rule 46 (statements -> print .)
    READ            reduce using rule 46 (statements -> print .)
    PRINT           reduce using rule 46 (statements -> print .)
    IF              reduce using rule 46 (statements -> print .)
    WHILE           reduce using rule 46 (statements -> print .)
    FOR             reduce using rule 46 (statements -> print .)
    MEAN            reduce using rule 46 (statements -> print .)
    VAR             reduce using rule 46 (statements -> print .)
    RBRACE          reduce using rule 46 (statements -> print .)
    RBRACKET        reduce using rule 46 (statements -> print .)


state 25

    (47) statements -> if .

    $end            reduce using rule 47 (statements -> if .)
    SEMICOLON       reduce using rule 47 (statements -> if .)
    FUNCTION        reduce using rule 47 (statements -> if .)
    ID              reduce using rule 47 (statements -> if .)
    READ            reduce using rule 47 (statements -> if .)
    PRINT           reduce using rule 47 (statements -> if .)
    IF              reduce using rule 47 (statements -> if .)
    WHILE           reduce using rule 47 (statements -> if .)
    FOR             reduce using rule 47 (statements -> if .)
    MEAN            reduce using rule 47 (statements -> if .)
    VAR             reduce using rule 47 (statements -> if .)
    RBRACE          reduce using rule 47 (statements -> if .)
    RBRACKET        reduce using rule 47 (statements -> if .)


state 26

    (48) statements -> while .

    $end            reduce using rule 48 (statements -> while .)
    SEMICOLON       reduce using rule 48 (statements -> while .)
    FUNCTION        reduce using rule 48 (statements -> while .)
    ID              reduce using rule 48 (statements -> while .)
    READ            reduce using rule 48 (statements -> while .)
    PRINT           reduce using rule 48 (statements -> while .)
    IF              reduce using rule 48 (statements -> while .)
    WHILE           reduce using rule 48 (statements -> while .)
    FOR             reduce using rule 48 (statements -> while .)
    MEAN            reduce using rule 48 (statements -> while .)
    VAR             reduce using rule 48 (statements -> while .)
    RBRACE          reduce using rule 48 (statements -> while .)
    RBRACKET        reduce using rule 48 (statements -> while .)


state 27

    (49) statements -> for .

    $end            reduce using rule 49 (statements -> for .)
    SEMICOLON       reduce using rule 49 (statements -> for .)
    FUNCTION        reduce using rule 49 (statements -> for .)
    ID              reduce using rule 49 (statements -> for .)
    READ            reduce using rule 49 (statements -> for .)
    PRINT           reduce using rule 49 (statements -> for .)
    IF              reduce using rule 49 (statements -> for .)
    WHILE           reduce using rule 49 (statements -> for .)
    FOR             reduce using rule 49 (statements -> for .)
    MEAN            reduce using rule 49 (statements -> for .)
    VAR             reduce using rule 49 (statements -> for .)
    RBRACE          reduce using rule 49 (statements -> for .)
    RBRACKET        reduce using rule 49 (statements -> for .)


state 28

    (50) statements -> funcesp .

    $end            reduce using rule 50 (statements -> funcesp .)
    SEMICOLON       reduce using rule 50 (statements -> funcesp .)
    FUNCTION        reduce using rule 50 (statements -> funcesp .)
    ID              reduce using rule 50 (statements -> funcesp .)
    READ            reduce using rule 50 (statements -> funcesp .)
    PRINT           reduce using rule 50 (statements -> funcesp .)
    IF              reduce using rule 50 (statements -> funcesp .)
    WHILE           reduce using rule 50 (statements -> funcesp .)
    FOR             reduce using rule 50 (statements -> funcesp .)
    MEAN            reduce using rule 50 (statements -> funcesp .)
    VAR             reduce using rule 50 (statements -> funcesp .)
    RBRACE          reduce using rule 50 (statements -> funcesp .)
    RBRACKET        reduce using rule 50 (statements -> funcesp .)


state 29

    (51) assign -> var . EQUAL exp

    EQUAL           shift and go to state 46


state 30

    (9) function -> FUNCTION . type ID LPAREN param RPAREN body
    (10) voidfunction -> FUNCTION . VOID ID LPAREN param RPAREN body
    (7) type -> . INT
    (8) type -> . FLOAT

    VOID            shift and go to state 48
    INT             shift and go to state 49
    FLOAT           shift and go to state 50

    type                           shift and go to state 47

state 31

    (59) call -> ID . LPAREN callp RPAREN
    (56) var -> ID .
    (57) var -> ID . LBRACKET exp RBRACKET
    (58) var -> ID . LBRACKET exp RBRACKET LBRACKET exp RBRACKET
    (83) array -> ID . EQUAL ARRAY LPAREN var arrayp
    (86) matrix -> ID . EQUAL MATRIX LPAREN array matrixp
    (90) layers -> ID . EQUAL LAYERS LPAREN UNITS EQUAL INT RPAREN
    (91) sequential -> ID . EQUAL SEQUENTIAL LPAREN LBRACKET layers sequentialp
    (95) fit -> ID . EQUAL sequential DOT FIT LPAREN array COMMA array COMMA EPOCHS EQUAL INT COMMA VERBOSE EQUAL fitp
    (98) predict -> ID . EQUAL sequential DOT PREDICT LPAREN LBRACKET predictp

  ! shift/reduce conflict for EQUAL resolved as shift
    LPAREN          shift and go to state 51
    LBRACKET        shift and go to state 52
    EQUAL           shift and go to state 53

  ! EQUAL           [ reduce using rule 56 (var -> ID .) ]


state 32

    (52) read -> READ . var
    (56) var -> . ID
    (57) var -> . ID LBRACKET exp RBRACKET
    (58) var -> . ID LBRACKET exp RBRACKET LBRACKET exp RBRACKET

    ID              shift and go to state 55

    var                            shift and go to state 54

state 33

    (53) print -> PRINT . LPAREN printp

    LPAREN          shift and go to state 56


state 34

    (68) while -> WHILE . LPAREN exp RPAREN statements whilep

    LPAREN          shift and go to state 57


state 35

    (71) for -> FOR . LPAREN var SEMICOLON exp SEMICOLON exp RPAREN LBRACKET statements forp

    LPAREN          shift and go to state 58


state 36

    (74) funcesp -> array .

    $end            reduce using rule 74 (funcesp -> array .)
    SEMICOLON       reduce using rule 74 (funcesp -> array .)
    FUNCTION        reduce using rule 74 (funcesp -> array .)
    ID              reduce using rule 74 (funcesp -> array .)
    READ            reduce using rule 74 (funcesp -> array .)
    PRINT           reduce using rule 74 (funcesp -> array .)
    IF              reduce using rule 74 (funcesp -> array .)
    WHILE           reduce using rule 74 (funcesp -> array .)
    FOR             reduce using rule 74 (funcesp -> array .)
    MEAN            reduce using rule 74 (funcesp -> array .)
    VAR             reduce using rule 74 (funcesp -> array .)
    RBRACE          reduce using rule 74 (funcesp -> array .)
    RBRACKET        reduce using rule 74 (funcesp -> array .)


state 37

    (75) funcesp -> matrix .

    $end            reduce using rule 75 (funcesp -> matrix .)
    SEMICOLON       reduce using rule 75 (funcesp -> matrix .)
    FUNCTION        reduce using rule 75 (funcesp -> matrix .)
    ID              reduce using rule 75 (funcesp -> matrix .)
    READ            reduce using rule 75 (funcesp -> matrix .)
    PRINT           reduce using rule 75 (funcesp -> matrix .)
    IF              reduce using rule 75 (funcesp -> matrix .)
    WHILE           reduce using rule 75 (funcesp -> matrix .)
    FOR             reduce using rule 75 (funcesp -> matrix .)
    MEAN            reduce using rule 75 (funcesp -> matrix .)
    VAR             reduce using rule 75 (funcesp -> matrix .)
    RBRACE          reduce using rule 75 (funcesp -> matrix .)
    RBRACKET        reduce using rule 75 (funcesp -> matrix .)


state 38

    (76) funcesp -> mean .

    $end            reduce using rule 76 (funcesp -> mean .)
    SEMICOLON       reduce using rule 76 (funcesp -> mean .)
    FUNCTION        reduce using rule 76 (funcesp -> mean .)
    ID              reduce using rule 76 (funcesp -> mean .)
    READ            reduce using rule 76 (funcesp -> mean .)
    PRINT           reduce using rule 76 (funcesp -> mean .)
    IF              reduce using rule 76 (funcesp -> mean .)
    WHILE           reduce using rule 76 (funcesp -> mean .)
    FOR             reduce using rule 76 (funcesp -> mean .)
    MEAN            reduce using rule 76 (funcesp -> mean .)
    VAR             reduce using rule 76 (funcesp -> mean .)
    RBRACE          reduce using rule 76 (funcesp -> mean .)
    RBRACKET        reduce using rule 76 (funcesp -> mean .)


state 39

    (77) funcesp -> layers .
    (101) getweights -> layers . DOT GETWEIGHTS LPAREN RPAREN

    $end            reduce using rule 77 (funcesp -> layers .)
    SEMICOLON       reduce using rule 77 (funcesp -> layers .)
    FUNCTION        reduce using rule 77 (funcesp -> layers .)
    ID              reduce using rule 77 (funcesp -> layers .)
    READ            reduce using rule 77 (funcesp -> layers .)
    PRINT           reduce using rule 77 (funcesp -> layers .)
    IF              reduce using rule 77 (funcesp -> layers .)
    WHILE           reduce using rule 77 (funcesp -> layers .)
    FOR             reduce using rule 77 (funcesp -> layers .)
    MEAN            reduce using rule 77 (funcesp -> layers .)
    VAR             reduce using rule 77 (funcesp -> layers .)
    RBRACE          reduce using rule 77 (funcesp -> layers .)
    RBRACKET        reduce using rule 77 (funcesp -> layers .)
    DOT             shift and go to state 59


state 40

    (78) funcesp -> sequential .
    (94) compile -> sequential . DOT COMPILE LPAREN RPAREN

    $end            reduce using rule 78 (funcesp -> sequential .)
    SEMICOLON       reduce using rule 78 (funcesp -> sequential .)
    FUNCTION        reduce using rule 78 (funcesp -> sequential .)
    ID              reduce using rule 78 (funcesp -> sequential .)
    READ            reduce using rule 78 (funcesp -> sequential .)
    PRINT           reduce using rule 78 (funcesp -> sequential .)
    IF              reduce using rule 78 (funcesp -> sequential .)
    WHILE           reduce using rule 78 (funcesp -> sequential .)
    FOR             reduce using rule 78 (funcesp -> sequential .)
    MEAN            reduce using rule 78 (funcesp -> sequential .)
    VAR             reduce using rule 78 (funcesp -> sequential .)
    RBRACE          reduce using rule 78 (funcesp -> sequential .)
    RBRACKET        reduce using rule 78 (funcesp -> sequential .)
    DOT             shift and go to state 60


state 41

    (79) funcesp -> compile .

    $end            reduce using rule 79 (funcesp -> compile .)
    SEMICOLON       reduce using rule 79 (funcesp -> compile .)
    FUNCTION        reduce using rule 79 (funcesp -> compile .)
    ID              reduce using rule 79 (funcesp -> compile .)
    READ            reduce using rule 79 (funcesp -> compile .)
    PRINT           reduce using rule 79 (funcesp -> compile .)
    IF              reduce using rule 79 (funcesp -> compile .)
    WHILE           reduce using rule 79 (funcesp -> compile .)
    FOR             reduce using rule 79 (funcesp -> compile .)
    MEAN            reduce using rule 79 (funcesp -> compile .)
    VAR             reduce using rule 79 (funcesp -> compile .)
    RBRACE          reduce using rule 79 (funcesp -> compile .)
    RBRACKET        reduce using rule 79 (funcesp -> compile .)


state 42

    (80) funcesp -> fit .

    $end            reduce using rule 80 (funcesp -> fit .)
    SEMICOLON       reduce using rule 80 (funcesp -> fit .)
    FUNCTION        reduce using rule 80 (funcesp -> fit .)
    ID              reduce using rule 80 (funcesp -> fit .)
    READ            reduce using rule 80 (funcesp -> fit .)
    PRINT           reduce using rule 80 (funcesp -> fit .)
    IF              reduce using rule 80 (funcesp -> fit .)
    WHILE           reduce using rule 80 (funcesp -> fit .)
    FOR             reduce using rule 80 (funcesp -> fit .)
    MEAN            reduce using rule 80 (funcesp -> fit .)
    VAR             reduce using rule 80 (funcesp -> fit .)
    RBRACE          reduce using rule 80 (funcesp -> fit .)
    RBRACKET        reduce using rule 80 (funcesp -> fit .)


state 43

    (81) funcesp -> predict .

    $end            reduce using rule 81 (funcesp -> predict .)
    SEMICOLON       reduce using rule 81 (funcesp -> predict .)
    FUNCTION        reduce using rule 81 (funcesp -> predict .)
    ID              reduce using rule 81 (funcesp -> predict .)
    READ            reduce using rule 81 (funcesp -> predict .)
    PRINT           reduce using rule 81 (funcesp -> predict .)
    IF              reduce using rule 81 (funcesp -> predict .)
    WHILE           reduce using rule 81 (funcesp -> predict .)
    FOR             reduce using rule 81 (funcesp -> predict .)
    MEAN            reduce using rule 81 (funcesp -> predict .)
    VAR             reduce using rule 81 (funcesp -> predict .)
    RBRACE          reduce using rule 81 (funcesp -> predict .)
    RBRACKET        reduce using rule 81 (funcesp -> predict .)


state 44

    (82) funcesp -> getweights .

    $end            reduce using rule 82 (funcesp -> getweights .)
    SEMICOLON       reduce using rule 82 (funcesp -> getweights .)
    FUNCTION        reduce using rule 82 (funcesp -> getweights .)
    ID              reduce using rule 82 (funcesp -> getweights .)
    READ            reduce using rule 82 (funcesp -> getweights .)
    PRINT           reduce using rule 82 (funcesp -> getweights .)
    IF              reduce using rule 82 (funcesp -> getweights .)
    WHILE           reduce using rule 82 (funcesp -> getweights .)
    FOR             reduce using rule 82 (funcesp -> getweights .)
    MEAN            reduce using rule 82 (funcesp -> getweights .)
    VAR             reduce using rule 82 (funcesp -> getweights .)
    RBRACE          reduce using rule 82 (funcesp -> getweights .)
    RBRACKET        reduce using rule 82 (funcesp -> getweights .)


state 45

    (89) mean -> MEAN . LPAREN array RPAREN

    LPAREN          shift and go to state 61


state 46

    (51) assign -> var EQUAL . exp
    (20) exp -> . texp
    (21) exp -> . texp OR exp
    (22) texp -> . gexp
    (23) texp -> . gexp AND texp
    (24) gexp -> . mexp
    (25) gexp -> . mexp gexpp mexp
    (30) mexp -> . t
    (31) mexp -> . t PLUS mexp
    (32) mexp -> . t MINUS mexp
    (33) t -> . f
    (34) t -> . f MULT t
    (35) t -> . f DIV t
    (36) f -> . LPAREN exp RPAREN
    (37) f -> . INT
    (38) f -> . FLOAT
    (39) f -> . var
    (40) f -> . call
    (56) var -> . ID
    (57) var -> . ID LBRACKET exp RBRACKET
    (58) var -> . ID LBRACKET exp RBRACKET LBRACKET exp RBRACKET
    (59) call -> . ID LPAREN callp RPAREN

    LPAREN          shift and go to state 69
    INT             shift and go to state 70
    FLOAT           shift and go to state 71
    ID              shift and go to state 73

    var                            shift and go to state 62
    exp                            shift and go to state 63
    texp                           shift and go to state 64
    gexp                           shift and go to state 65
    mexp                           shift and go to state 66
    t                              shift and go to state 67
    f                              shift and go to state 68
    call                           shift and go to state 72

state 47

    (9) function -> FUNCTION type . ID LPAREN param RPAREN body

    ID              shift and go to state 74


state 48

    (10) voidfunction -> FUNCTION VOID . ID LPAREN param RPAREN body

    ID              shift and go to state 75


state 49

    (7) type -> INT .

    ID              reduce using rule 7 (type -> INT .)


state 50

    (8) type -> FLOAT .

    ID              reduce using rule 8 (type -> FLOAT .)


state 51

    (59) call -> ID LPAREN . callp RPAREN
    (60) callp -> . exp SEMICOLON callp
    (61) callp -> . exp
    (20) exp -> . texp
    (21) exp -> . texp OR exp
    (22) texp -> . gexp
    (23) texp -> . gexp AND texp
    (24) gexp -> . mexp
    (25) gexp -> . mexp gexpp mexp
    (30) mexp -> . t
    (31) mexp -> . t PLUS mexp
    (32) mexp -> . t MINUS mexp
    (33) t -> . f
    (34) t -> . f MULT t
    (35) t -> . f DIV t
    (36) f -> . LPAREN exp RPAREN
    (37) f -> . INT
    (38) f -> . FLOAT
    (39) f -> . var
    (40) f -> . call
    (56) var -> . ID
    (57) var -> . ID LBRACKET exp RBRACKET
    (58) var -> . ID LBRACKET exp RBRACKET LBRACKET exp RBRACKET
    (59) call -> . ID LPAREN callp RPAREN

    LPAREN          shift and go to state 69
    INT             shift and go to state 70
    FLOAT           shift and go to state 71
    ID              shift and go to state 73

    callp                          shift and go to state 76
    exp                            shift and go to state 77
    texp                           shift and go to state 64
    gexp                           shift and go to state 65
    mexp                           shift and go to state 66
    t                              shift and go to state 67
    f                              shift and go to state 68
    var                            shift and go to state 62
    call                           shift and go to state 72

state 52

    (57) var -> ID LBRACKET . exp RBRACKET
    (58) var -> ID LBRACKET . exp RBRACKET LBRACKET exp RBRACKET
    (20) exp -> . texp
    (21) exp -> . texp OR exp
    (22) texp -> . gexp
    (23) texp -> . gexp AND texp
    (24) gexp -> . mexp
    (25) gexp -> . mexp gexpp mexp
    (30) mexp -> . t
    (31) mexp -> . t PLUS mexp
    (32) mexp -> . t MINUS mexp
    (33) t -> . f
    (34) t -> . f MULT t
    (35) t -> . f DIV t
    (36) f -> . LPAREN exp RPAREN
    (37) f -> . INT
    (38) f -> . FLOAT
    (39) f -> . var
    (40) f -> . call
    (56) var -> . ID
    (57) var -> . ID LBRACKET exp RBRACKET
    (58) var -> . ID LBRACKET exp RBRACKET LBRACKET exp RBRACKET
    (59) call -> . ID LPAREN callp RPAREN

    LPAREN          shift and go to state 69
    INT             shift and go to state 70
    FLOAT           shift and go to state 71
    ID              shift and go to state 73

    exp                            shift and go to state 78
    texp                           shift and go to state 64
    gexp                           shift and go to state 65
    mexp                           shift and go to state 66
    t                              shift and go to state 67
    f                              shift and go to state 68
    var                            shift and go to state 62
    call                           shift and go to state 72

state 53

    (83) array -> ID EQUAL . ARRAY LPAREN var arrayp
    (86) matrix -> ID EQUAL . MATRIX LPAREN array matrixp
    (90) layers -> ID EQUAL . LAYERS LPAREN UNITS EQUAL INT RPAREN
    (91) sequential -> ID EQUAL . SEQUENTIAL LPAREN LBRACKET layers sequentialp
    (95) fit -> ID EQUAL . sequential DOT FIT LPAREN array COMMA array COMMA EPOCHS EQUAL INT COMMA VERBOSE EQUAL fitp
    (98) predict -> ID EQUAL . sequential DOT PREDICT LPAREN LBRACKET predictp
    (91) sequential -> . ID EQUAL SEQUENTIAL LPAREN LBRACKET layers sequentialp

    ARRAY           shift and go to state 80
    MATRIX          shift and go to state 81
    LAYERS          shift and go to state 82
    SEQUENTIAL      shift and go to state 83
    ID              shift and go to state 79

    sequential                     shift and go to state 84

state 54

    (52) read -> READ var .

    $end            reduce using rule 52 (read -> READ var .)
    SEMICOLON       reduce using rule 52 (read -> READ var .)
    FUNCTION        reduce using rule 52 (read -> READ var .)
    ID              reduce using rule 52 (read -> READ var .)
    READ            reduce using rule 52 (read -> READ var .)
    PRINT           reduce using rule 52 (read -> READ var .)
    IF              reduce using rule 52 (read -> READ var .)
    WHILE           reduce using rule 52 (read -> READ var .)
    FOR             reduce using rule 52 (read -> READ var .)
    MEAN            reduce using rule 52 (read -> READ var .)
    VAR             reduce using rule 52 (read -> READ var .)
    RBRACE          reduce using rule 52 (read -> READ var .)
    RBRACKET        reduce using rule 52 (read -> READ var .)


state 55

    (56) var -> ID .
    (57) var -> ID . LBRACKET exp RBRACKET
    (58) var -> ID . LBRACKET exp RBRACKET LBRACKET exp RBRACKET

    $end            reduce using rule 56 (var -> ID .)
    SEMICOLON       reduce using rule 56 (var -> ID .)
    FUNCTION        reduce using rule 56 (var -> ID .)
    ID              reduce using rule 56 (var -> ID .)
    READ            reduce using rule 56 (var -> ID .)
    PRINT           reduce using rule 56 (var -> ID .)
    IF              reduce using rule 56 (var -> ID .)
    WHILE           reduce using rule 56 (var -> ID .)
    FOR             reduce using rule 56 (var -> ID .)
    MEAN            reduce using rule 56 (var -> ID .)
    VAR             reduce using rule 56 (var -> ID .)
    RBRACE          reduce using rule 56 (var -> ID .)
    RBRACKET        reduce using rule 56 (var -> ID .)
    RPAREN          reduce using rule 56 (var -> ID .)
    COMMA           reduce using rule 56 (var -> ID .)
    LBRACKET        shift and go to state 52


state 56

    (53) print -> PRINT LPAREN . printp
    (54) printp -> . exp RPAREN
    (55) printp -> . exp COMMA printp
    (20) exp -> . texp
    (21) exp -> . texp OR exp
    (22) texp -> . gexp
    (23) texp -> . gexp AND texp
    (24) gexp -> . mexp
    (25) gexp -> . mexp gexpp mexp
    (30) mexp -> . t
    (31) mexp -> . t PLUS mexp
    (32) mexp -> . t MINUS mexp
    (33) t -> . f
    (34) t -> . f MULT t
    (35) t -> . f DIV t
    (36) f -> . LPAREN exp RPAREN
    (37) f -> . INT
    (38) f -> . FLOAT
    (39) f -> . var
    (40) f -> . call
    (56) var -> . ID
    (57) var -> . ID LBRACKET exp RBRACKET
    (58) var -> . ID LBRACKET exp RBRACKET LBRACKET exp RBRACKET
    (59) call -> . ID LPAREN callp RPAREN

    LPAREN          shift and go to state 69
    INT             shift and go to state 70
    FLOAT           shift and go to state 71
    ID              shift and go to state 73

    printp                         shift and go to state 85
    exp                            shift and go to state 86
    texp                           shift and go to state 64
    gexp                           shift and go to state 65
    mexp                           shift and go to state 66
    t                              shift and go to state 67
    f                              shift and go to state 68
    var                            shift and go to state 62
    call                           shift and go to state 72

state 57

    (68) while -> WHILE LPAREN . exp RPAREN statements whilep
    (20) exp -> . texp
    (21) exp -> . texp OR exp
    (22) texp -> . gexp
    (23) texp -> . gexp AND texp
    (24) gexp -> . mexp
    (25) gexp -> . mexp gexpp mexp
    (30) mexp -> . t
    (31) mexp -> . t PLUS mexp
    (32) mexp -> . t MINUS mexp
    (33) t -> . f
    (34) t -> . f MULT t
    (35) t -> . f DIV t
    (36) f -> . LPAREN exp RPAREN
    (37) f -> . INT
    (38) f -> . FLOAT
    (39) f -> . var
    (40) f -> . call
    (56) var -> . ID
    (57) var -> . ID LBRACKET exp RBRACKET
    (58) var -> . ID LBRACKET exp RBRACKET LBRACKET exp RBRACKET
    (59) call -> . ID LPAREN callp RPAREN

    LPAREN          shift and go to state 69
    INT             shift and go to state 70
    FLOAT           shift and go to state 71
    ID              shift and go to state 73

    exp                            shift and go to state 87
    texp                           shift and go to state 64
    gexp                           shift and go to state 65
    mexp                           shift and go to state 66
    t                              shift and go to state 67
    f                              shift and go to state 68
    var                            shift and go to state 62
    call                           shift and go to state 72

state 58

    (71) for -> FOR LPAREN . var SEMICOLON exp SEMICOLON exp RPAREN LBRACKET statements forp
    (56) var -> . ID
    (57) var -> . ID LBRACKET exp RBRACKET
    (58) var -> . ID LBRACKET exp RBRACKET LBRACKET exp RBRACKET

    ID              shift and go to state 55

    var                            shift and go to state 88

state 59

    (101) getweights -> layers DOT . GETWEIGHTS LPAREN RPAREN

    GETWEIGHTS      shift and go to state 89


state 60

    (94) compile -> sequential DOT . COMPILE LPAREN RPAREN

    COMPILE         shift and go to state 90


state 61

    (89) mean -> MEAN LPAREN . array RPAREN
    (83) array -> . ID EQUAL ARRAY LPAREN var arrayp

    ID              shift and go to state 92

    array                          shift and go to state 91

state 62

    (39) f -> var .

    MULT            reduce using rule 39 (f -> var .)
    DIV             reduce using rule 39 (f -> var .)
    PLUS            reduce using rule 39 (f -> var .)
    MINUS           reduce using rule 39 (f -> var .)
    LT              reduce using rule 39 (f -> var .)
    GT              reduce using rule 39 (f -> var .)
    EQUAL           reduce using rule 39 (f -> var .)
    DIFF            reduce using rule 39 (f -> var .)
    AND             reduce using rule 39 (f -> var .)
    OR              reduce using rule 39 (f -> var .)
    $end            reduce using rule 39 (f -> var .)
    SEMICOLON       reduce using rule 39 (f -> var .)
    FUNCTION        reduce using rule 39 (f -> var .)
    ID              reduce using rule 39 (f -> var .)
    READ            reduce using rule 39 (f -> var .)
    PRINT           reduce using rule 39 (f -> var .)
    IF              reduce using rule 39 (f -> var .)
    WHILE           reduce using rule 39 (f -> var .)
    FOR             reduce using rule 39 (f -> var .)
    MEAN            reduce using rule 39 (f -> var .)
    VAR             reduce using rule 39 (f -> var .)
    RBRACE          reduce using rule 39 (f -> var .)
    RBRACKET        reduce using rule 39 (f -> var .)
    RPAREN          reduce using rule 39 (f -> var .)
    COMMA           reduce using rule 39 (f -> var .)


state 63

    (51) assign -> var EQUAL exp .

    $end            reduce using rule 51 (assign -> var EQUAL exp .)
    SEMICOLON       reduce using rule 51 (assign -> var EQUAL exp .)
    FUNCTION        reduce using rule 51 (assign -> var EQUAL exp .)
    ID              reduce using rule 51 (assign -> var EQUAL exp .)
    READ            reduce using rule 51 (assign -> var EQUAL exp .)
    PRINT           reduce using rule 51 (assign -> var EQUAL exp .)
    IF              reduce using rule 51 (assign -> var EQUAL exp .)
    WHILE           reduce using rule 51 (assign -> var EQUAL exp .)
    FOR             reduce using rule 51 (assign -> var EQUAL exp .)
    MEAN            reduce using rule 51 (assign -> var EQUAL exp .)
    VAR             reduce using rule 51 (assign -> var EQUAL exp .)
    RBRACE          reduce using rule 51 (assign -> var EQUAL exp .)
    RBRACKET        reduce using rule 51 (assign -> var EQUAL exp .)


state 64

    (20) exp -> texp .
    (21) exp -> texp . OR exp

    $end            reduce using rule 20 (exp -> texp .)
    SEMICOLON       reduce using rule 20 (exp -> texp .)
    FUNCTION        reduce using rule 20 (exp -> texp .)
    ID              reduce using rule 20 (exp -> texp .)
    READ            reduce using rule 20 (exp -> texp .)
    PRINT           reduce using rule 20 (exp -> texp .)
    IF              reduce using rule 20 (exp -> texp .)
    WHILE           reduce using rule 20 (exp -> texp .)
    FOR             reduce using rule 20 (exp -> texp .)
    MEAN            reduce using rule 20 (exp -> texp .)
    VAR             reduce using rule 20 (exp -> texp .)
    RBRACE          reduce using rule 20 (exp -> texp .)
    RBRACKET        reduce using rule 20 (exp -> texp .)
    RPAREN          reduce using rule 20 (exp -> texp .)
    COMMA           reduce using rule 20 (exp -> texp .)
    OR              shift and go to state 93


state 65

    (22) texp -> gexp .
    (23) texp -> gexp . AND texp

    OR              reduce using rule 22 (texp -> gexp .)
    $end            reduce using rule 22 (texp -> gexp .)
    SEMICOLON       reduce using rule 22 (texp -> gexp .)
    FUNCTION        reduce using rule 22 (texp -> gexp .)
    ID              reduce using rule 22 (texp -> gexp .)
    READ            reduce using rule 22 (texp -> gexp .)
    PRINT           reduce using rule 22 (texp -> gexp .)
    IF              reduce using rule 22 (texp -> gexp .)
    WHILE           reduce using rule 22 (texp -> gexp .)
    FOR             reduce using rule 22 (texp -> gexp .)
    MEAN            reduce using rule 22 (texp -> gexp .)
    VAR             reduce using rule 22 (texp -> gexp .)
    RBRACE          reduce using rule 22 (texp -> gexp .)
    RBRACKET        reduce using rule 22 (texp -> gexp .)
    RPAREN          reduce using rule 22 (texp -> gexp .)
    COMMA           reduce using rule 22 (texp -> gexp .)
    AND             shift and go to state 94


state 66

    (24) gexp -> mexp .
    (25) gexp -> mexp . gexpp mexp
    (26) gexpp -> . LT
    (27) gexpp -> . GT
    (28) gexpp -> . EQUAL
    (29) gexpp -> . DIFF

    AND             reduce using rule 24 (gexp -> mexp .)
    OR              reduce using rule 24 (gexp -> mexp .)
    $end            reduce using rule 24 (gexp -> mexp .)
    SEMICOLON       reduce using rule 24 (gexp -> mexp .)
    FUNCTION        reduce using rule 24 (gexp -> mexp .)
    ID              reduce using rule 24 (gexp -> mexp .)
    READ            reduce using rule 24 (gexp -> mexp .)
    PRINT           reduce using rule 24 (gexp -> mexp .)
    IF              reduce using rule 24 (gexp -> mexp .)
    WHILE           reduce using rule 24 (gexp -> mexp .)
    FOR             reduce using rule 24 (gexp -> mexp .)
    MEAN            reduce using rule 24 (gexp -> mexp .)
    VAR             reduce using rule 24 (gexp -> mexp .)
    RBRACE          reduce using rule 24 (gexp -> mexp .)
    RBRACKET        reduce using rule 24 (gexp -> mexp .)
    RPAREN          reduce using rule 24 (gexp -> mexp .)
    COMMA           reduce using rule 24 (gexp -> mexp .)
    LT              shift and go to state 96
    GT              shift and go to state 97
    EQUAL           shift and go to state 98
    DIFF            shift and go to state 99

    gexpp                          shift and go to state 95

state 67

    (30) mexp -> t .
    (31) mexp -> t . PLUS mexp
    (32) mexp -> t . MINUS mexp

    LT              reduce using rule 30 (mexp -> t .)
    GT              reduce using rule 30 (mexp -> t .)
    EQUAL           reduce using rule 30 (mexp -> t .)
    DIFF            reduce using rule 30 (mexp -> t .)
    AND             reduce using rule 30 (mexp -> t .)
    OR              reduce using rule 30 (mexp -> t .)
    $end            reduce using rule 30 (mexp -> t .)
    SEMICOLON       reduce using rule 30 (mexp -> t .)
    FUNCTION        reduce using rule 30 (mexp -> t .)
    ID              reduce using rule 30 (mexp -> t .)
    READ            reduce using rule 30 (mexp -> t .)
    PRINT           reduce using rule 30 (mexp -> t .)
    IF              reduce using rule 30 (mexp -> t .)
    WHILE           reduce using rule 30 (mexp -> t .)
    FOR             reduce using rule 30 (mexp -> t .)
    MEAN            reduce using rule 30 (mexp -> t .)
    VAR             reduce using rule 30 (mexp -> t .)
    RBRACE          reduce using rule 30 (mexp -> t .)
    RBRACKET        reduce using rule 30 (mexp -> t .)
    RPAREN          reduce using rule 30 (mexp -> t .)
    COMMA           reduce using rule 30 (mexp -> t .)
    PLUS            shift and go to state 100
    MINUS           shift and go to state 101


state 68

    (33) t -> f .
    (34) t -> f . MULT t
    (35) t -> f . DIV t

    PLUS            reduce using rule 33 (t -> f .)
    MINUS           reduce using rule 33 (t -> f .)
    LT              reduce using rule 33 (t -> f .)
    GT              reduce using rule 33 (t -> f .)
    EQUAL           reduce using rule 33 (t -> f .)
    DIFF            reduce using rule 33 (t -> f .)
    AND             reduce using rule 33 (t -> f .)
    OR              reduce using rule 33 (t -> f .)
    $end            reduce using rule 33 (t -> f .)
    SEMICOLON       reduce using rule 33 (t -> f .)
    FUNCTION        reduce using rule 33 (t -> f .)
    ID              reduce using rule 33 (t -> f .)
    READ            reduce using rule 33 (t -> f .)
    PRINT           reduce using rule 33 (t -> f .)
    IF              reduce using rule 33 (t -> f .)
    WHILE           reduce using rule 33 (t -> f .)
    FOR             reduce using rule 33 (t -> f .)
    MEAN            reduce using rule 33 (t -> f .)
    VAR             reduce using rule 33 (t -> f .)
    RBRACE          reduce using rule 33 (t -> f .)
    RBRACKET        reduce using rule 33 (t -> f .)
    RPAREN          reduce using rule 33 (t -> f .)
    COMMA           reduce using rule 33 (t -> f .)
    MULT            shift and go to state 102
    DIV             shift and go to state 103


state 69

    (36) f -> LPAREN . exp RPAREN
    (20) exp -> . texp
    (21) exp -> . texp OR exp
    (22) texp -> . gexp
    (23) texp -> . gexp AND texp
    (24) gexp -> . mexp
    (25) gexp -> . mexp gexpp mexp
    (30) mexp -> . t
    (31) mexp -> . t PLUS mexp
    (32) mexp -> . t MINUS mexp
    (33) t -> . f
    (34) t -> . f MULT t
    (35) t -> . f DIV t
    (36) f -> . LPAREN exp RPAREN
    (37) f -> . INT
    (38) f -> . FLOAT
    (39) f -> . var
    (40) f -> . call
    (56) var -> . ID
    (57) var -> . ID LBRACKET exp RBRACKET
    (58) var -> . ID LBRACKET exp RBRACKET LBRACKET exp RBRACKET
    (59) call -> . ID LPAREN callp RPAREN

    LPAREN          shift and go to state 69
    INT             shift and go to state 70
    FLOAT           shift and go to state 71
    ID              shift and go to state 73

    exp                            shift and go to state 104
    texp                           shift and go to state 64
    gexp                           shift and go to state 65
    mexp                           shift and go to state 66
    t                              shift and go to state 67
    f                              shift and go to state 68
    var                            shift and go to state 62
    call                           shift and go to state 72

state 70

    (37) f -> INT .

    MULT            reduce using rule 37 (f -> INT .)
    DIV             reduce using rule 37 (f -> INT .)
    PLUS            reduce using rule 37 (f -> INT .)
    MINUS           reduce using rule 37 (f -> INT .)
    LT              reduce using rule 37 (f -> INT .)
    GT              reduce using rule 37 (f -> INT .)
    EQUAL           reduce using rule 37 (f -> INT .)
    DIFF            reduce using rule 37 (f -> INT .)
    AND             reduce using rule 37 (f -> INT .)
    OR              reduce using rule 37 (f -> INT .)
    $end            reduce using rule 37 (f -> INT .)
    SEMICOLON       reduce using rule 37 (f -> INT .)
    FUNCTION        reduce using rule 37 (f -> INT .)
    ID              reduce using rule 37 (f -> INT .)
    READ            reduce using rule 37 (f -> INT .)
    PRINT           reduce using rule 37 (f -> INT .)
    IF              reduce using rule 37 (f -> INT .)
    WHILE           reduce using rule 37 (f -> INT .)
    FOR             reduce using rule 37 (f -> INT .)
    MEAN            reduce using rule 37 (f -> INT .)
    VAR             reduce using rule 37 (f -> INT .)
    RBRACE          reduce using rule 37 (f -> INT .)
    RBRACKET        reduce using rule 37 (f -> INT .)
    RPAREN          reduce using rule 37 (f -> INT .)
    COMMA           reduce using rule 37 (f -> INT .)


state 71

    (38) f -> FLOAT .

    MULT            reduce using rule 38 (f -> FLOAT .)
    DIV             reduce using rule 38 (f -> FLOAT .)
    PLUS            reduce using rule 38 (f -> FLOAT .)
    MINUS           reduce using rule 38 (f -> FLOAT .)
    LT              reduce using rule 38 (f -> FLOAT .)
    GT              reduce using rule 38 (f -> FLOAT .)
    EQUAL           reduce using rule 38 (f -> FLOAT .)
    DIFF            reduce using rule 38 (f -> FLOAT .)
    AND             reduce using rule 38 (f -> FLOAT .)
    OR              reduce using rule 38 (f -> FLOAT .)
    $end            reduce using rule 38 (f -> FLOAT .)
    SEMICOLON       reduce using rule 38 (f -> FLOAT .)
    FUNCTION        reduce using rule 38 (f -> FLOAT .)
    ID              reduce using rule 38 (f -> FLOAT .)
    READ            reduce using rule 38 (f -> FLOAT .)
    PRINT           reduce using rule 38 (f -> FLOAT .)
    IF              reduce using rule 38 (f -> FLOAT .)
    WHILE           reduce using rule 38 (f -> FLOAT .)
    FOR             reduce using rule 38 (f -> FLOAT .)
    MEAN            reduce using rule 38 (f -> FLOAT .)
    VAR             reduce using rule 38 (f -> FLOAT .)
    RBRACE          reduce using rule 38 (f -> FLOAT .)
    RBRACKET        reduce using rule 38 (f -> FLOAT .)
    RPAREN          reduce using rule 38 (f -> FLOAT .)
    COMMA           reduce using rule 38 (f -> FLOAT .)


state 72

    (40) f -> call .

    MULT            reduce using rule 40 (f -> call .)
    DIV             reduce using rule 40 (f -> call .)
    PLUS            reduce using rule 40 (f -> call .)
    MINUS           reduce using rule 40 (f -> call .)
    LT              reduce using rule 40 (f -> call .)
    GT              reduce using rule 40 (f -> call .)
    EQUAL           reduce using rule 40 (f -> call .)
    DIFF            reduce using rule 40 (f -> call .)
    AND             reduce using rule 40 (f -> call .)
    OR              reduce using rule 40 (f -> call .)
    $end            reduce using rule 40 (f -> call .)
    SEMICOLON       reduce using rule 40 (f -> call .)
    FUNCTION        reduce using rule 40 (f -> call .)
    ID              reduce using rule 40 (f -> call .)
    READ            reduce using rule 40 (f -> call .)
    PRINT           reduce using rule 40 (f -> call .)
    IF              reduce using rule 40 (f -> call .)
    WHILE           reduce using rule 40 (f -> call .)
    FOR             reduce using rule 40 (f -> call .)
    MEAN            reduce using rule 40 (f -> call .)
    VAR             reduce using rule 40 (f -> call .)
    RBRACE          reduce using rule 40 (f -> call .)
    RBRACKET        reduce using rule 40 (f -> call .)
    RPAREN          reduce using rule 40 (f -> call .)
    COMMA           reduce using rule 40 (f -> call .)


state 73

    (56) var -> ID .
    (57) var -> ID . LBRACKET exp RBRACKET
    (58) var -> ID . LBRACKET exp RBRACKET LBRACKET exp RBRACKET
    (59) call -> ID . LPAREN callp RPAREN

    MULT            reduce using rule 56 (var -> ID .)
    DIV             reduce using rule 56 (var -> ID .)
    PLUS            reduce using rule 56 (var -> ID .)
    MINUS           reduce using rule 56 (var -> ID .)
    LT              reduce using rule 56 (var -> ID .)
    GT              reduce using rule 56 (var -> ID .)
    EQUAL           reduce using rule 56 (var -> ID .)
    DIFF            reduce using rule 56 (var -> ID .)
    AND             reduce using rule 56 (var -> ID .)
    OR              reduce using rule 56 (var -> ID .)
    $end            reduce using rule 56 (var -> ID .)
    SEMICOLON       reduce using rule 56 (var -> ID .)
    FUNCTION        reduce using rule 56 (var -> ID .)
    ID              reduce using rule 56 (var -> ID .)
    READ            reduce using rule 56 (var -> ID .)
    PRINT           reduce using rule 56 (var -> ID .)
    IF              reduce using rule 56 (var -> ID .)
    WHILE           reduce using rule 56 (var -> ID .)
    FOR             reduce using rule 56 (var -> ID .)
    MEAN            reduce using rule 56 (var -> ID .)
    VAR             reduce using rule 56 (var -> ID .)
    RBRACE          reduce using rule 56 (var -> ID .)
    RBRACKET        reduce using rule 56 (var -> ID .)
    RPAREN          reduce using rule 56 (var -> ID .)
    COMMA           reduce using rule 56 (var -> ID .)
    LBRACKET        shift and go to state 52
    LPAREN          shift and go to state 51


state 74

    (9) function -> FUNCTION type ID . LPAREN param RPAREN body

    LPAREN          shift and go to state 105


state 75

    (10) voidfunction -> FUNCTION VOID ID . LPAREN param RPAREN body

    LPAREN          shift and go to state 106


state 76

    (59) call -> ID LPAREN callp . RPAREN

    RPAREN          shift and go to state 107


state 77

    (60) callp -> exp . SEMICOLON callp
    (61) callp -> exp .

    SEMICOLON       shift and go to state 108
    RPAREN          reduce using rule 61 (callp -> exp .)


state 78

    (57) var -> ID LBRACKET exp . RBRACKET
    (58) var -> ID LBRACKET exp . RBRACKET LBRACKET exp RBRACKET

    RBRACKET        shift and go to state 109


state 79

    (91) sequential -> ID . EQUAL SEQUENTIAL LPAREN LBRACKET layers sequentialp

    EQUAL           shift and go to state 110


state 80

    (83) array -> ID EQUAL ARRAY . LPAREN var arrayp

    LPAREN          shift and go to state 111


state 81

    (86) matrix -> ID EQUAL MATRIX . LPAREN array matrixp

    LPAREN          shift and go to state 112


state 82

    (90) layers -> ID EQUAL LAYERS . LPAREN UNITS EQUAL INT RPAREN

    LPAREN          shift and go to state 113


state 83

    (91) sequential -> ID EQUAL SEQUENTIAL . LPAREN LBRACKET layers sequentialp

    LPAREN          shift and go to state 114


state 84

    (95) fit -> ID EQUAL sequential . DOT FIT LPAREN array COMMA array COMMA EPOCHS EQUAL INT COMMA VERBOSE EQUAL fitp
    (98) predict -> ID EQUAL sequential . DOT PREDICT LPAREN LBRACKET predictp

    DOT             shift and go to state 115


state 85

    (53) print -> PRINT LPAREN printp .

    $end            reduce using rule 53 (print -> PRINT LPAREN printp .)
    SEMICOLON       reduce using rule 53 (print -> PRINT LPAREN printp .)
    FUNCTION        reduce using rule 53 (print -> PRINT LPAREN printp .)
    ID              reduce using rule 53 (print -> PRINT LPAREN printp .)
    READ            reduce using rule 53 (print -> PRINT LPAREN printp .)
    PRINT           reduce using rule 53 (print -> PRINT LPAREN printp .)
    IF              reduce using rule 53 (print -> PRINT LPAREN printp .)
    WHILE           reduce using rule 53 (print -> PRINT LPAREN printp .)
    FOR             reduce using rule 53 (print -> PRINT LPAREN printp .)
    MEAN            reduce using rule 53 (print -> PRINT LPAREN printp .)
    VAR             reduce using rule 53 (print -> PRINT LPAREN printp .)
    RBRACE          reduce using rule 53 (print -> PRINT LPAREN printp .)
    RBRACKET        reduce using rule 53 (print -> PRINT LPAREN printp .)


state 86

    (54) printp -> exp . RPAREN
    (55) printp -> exp . COMMA printp

    RPAREN          shift and go to state 116
    COMMA           shift and go to state 117


state 87

    (68) while -> WHILE LPAREN exp . RPAREN statements whilep

    RPAREN          shift and go to state 118


state 88

    (71) for -> FOR LPAREN var . SEMICOLON exp SEMICOLON exp RPAREN LBRACKET statements forp

    SEMICOLON       shift and go to state 119


state 89

    (101) getweights -> layers DOT GETWEIGHTS . LPAREN RPAREN

    LPAREN          shift and go to state 120


state 90

    (94) compile -> sequential DOT COMPILE . LPAREN RPAREN

    LPAREN          shift and go to state 121


state 91

    (89) mean -> MEAN LPAREN array . RPAREN

    RPAREN          shift and go to state 122


state 92

    (83) array -> ID . EQUAL ARRAY LPAREN var arrayp

    EQUAL           shift and go to state 123


state 93

    (21) exp -> texp OR . exp
    (20) exp -> . texp
    (21) exp -> . texp OR exp
    (22) texp -> . gexp
    (23) texp -> . gexp AND texp
    (24) gexp -> . mexp
    (25) gexp -> . mexp gexpp mexp
    (30) mexp -> . t
    (31) mexp -> . t PLUS mexp
    (32) mexp -> . t MINUS mexp
    (33) t -> . f
    (34) t -> . f MULT t
    (35) t -> . f DIV t
    (36) f -> . LPAREN exp RPAREN
    (37) f -> . INT
    (38) f -> . FLOAT
    (39) f -> . var
    (40) f -> . call
    (56) var -> . ID
    (57) var -> . ID LBRACKET exp RBRACKET
    (58) var -> . ID LBRACKET exp RBRACKET LBRACKET exp RBRACKET
    (59) call -> . ID LPAREN callp RPAREN

    LPAREN          shift and go to state 69
    INT             shift and go to state 70
    FLOAT           shift and go to state 71
    ID              shift and go to state 73

    texp                           shift and go to state 64
    exp                            shift and go to state 124
    gexp                           shift and go to state 65
    mexp                           shift and go to state 66
    t                              shift and go to state 67
    f                              shift and go to state 68
    var                            shift and go to state 62
    call                           shift and go to state 72

state 94

    (23) texp -> gexp AND . texp
    (22) texp -> . gexp
    (23) texp -> . gexp AND texp
    (24) gexp -> . mexp
    (25) gexp -> . mexp gexpp mexp
    (30) mexp -> . t
    (31) mexp -> . t PLUS mexp
    (32) mexp -> . t MINUS mexp
    (33) t -> . f
    (34) t -> . f MULT t
    (35) t -> . f DIV t
    (36) f -> . LPAREN exp RPAREN
    (37) f -> . INT
    (38) f -> . FLOAT
    (39) f -> . var
    (40) f -> . call
    (56) var -> . ID
    (57) var -> . ID LBRACKET exp RBRACKET
    (58) var -> . ID LBRACKET exp RBRACKET LBRACKET exp RBRACKET
    (59) call -> . ID LPAREN callp RPAREN

    LPAREN          shift and go to state 69
    INT             shift and go to state 70
    FLOAT           shift and go to state 71
    ID              shift and go to state 73

    gexp                           shift and go to state 65
    texp                           shift and go to state 125
    mexp                           shift and go to state 66
    t                              shift and go to state 67
    f                              shift and go to state 68
    var                            shift and go to state 62
    call                           shift and go to state 72

state 95

    (25) gexp -> mexp gexpp . mexp
    (30) mexp -> . t
    (31) mexp -> . t PLUS mexp
    (32) mexp -> . t MINUS mexp
    (33) t -> . f
    (34) t -> . f MULT t
    (35) t -> . f DIV t
    (36) f -> . LPAREN exp RPAREN
    (37) f -> . INT
    (38) f -> . FLOAT
    (39) f -> . var
    (40) f -> . call
    (56) var -> . ID
    (57) var -> . ID LBRACKET exp RBRACKET
    (58) var -> . ID LBRACKET exp RBRACKET LBRACKET exp RBRACKET
    (59) call -> . ID LPAREN callp RPAREN

    LPAREN          shift and go to state 69
    INT             shift and go to state 70
    FLOAT           shift and go to state 71
    ID              shift and go to state 73

    mexp                           shift and go to state 126
    t                              shift and go to state 67
    f                              shift and go to state 68
    var                            shift and go to state 62
    call                           shift and go to state 72

state 96

    (26) gexpp -> LT .

    LPAREN          reduce using rule 26 (gexpp -> LT .)
    INT             reduce using rule 26 (gexpp -> LT .)
    FLOAT           reduce using rule 26 (gexpp -> LT .)
    ID              reduce using rule 26 (gexpp -> LT .)


state 97

    (27) gexpp -> GT .

    LPAREN          reduce using rule 27 (gexpp -> GT .)
    INT             reduce using rule 27 (gexpp -> GT .)
    FLOAT           reduce using rule 27 (gexpp -> GT .)
    ID              reduce using rule 27 (gexpp -> GT .)


state 98

    (28) gexpp -> EQUAL .

    LPAREN          reduce using rule 28 (gexpp -> EQUAL .)
    INT             reduce using rule 28 (gexpp -> EQUAL .)
    FLOAT           reduce using rule 28 (gexpp -> EQUAL .)
    ID              reduce using rule 28 (gexpp -> EQUAL .)


state 99

    (29) gexpp -> DIFF .

    LPAREN          reduce using rule 29 (gexpp -> DIFF .)
    INT             reduce using rule 29 (gexpp -> DIFF .)
    FLOAT           reduce using rule 29 (gexpp -> DIFF .)
    ID              reduce using rule 29 (gexpp -> DIFF .)


state 100

    (31) mexp -> t PLUS . mexp
    (30) mexp -> . t
    (31) mexp -> . t PLUS mexp
    (32) mexp -> . t MINUS mexp
    (33) t -> . f
    (34) t -> . f MULT t
    (35) t -> . f DIV t
    (36) f -> . LPAREN exp RPAREN
    (37) f -> . INT
    (38) f -> . FLOAT
    (39) f -> . var
    (40) f -> . call
    (56) var -> . ID
    (57) var -> . ID LBRACKET exp RBRACKET
    (58) var -> . ID LBRACKET exp RBRACKET LBRACKET exp RBRACKET
    (59) call -> . ID LPAREN callp RPAREN

    LPAREN          shift and go to state 69
    INT             shift and go to state 70
    FLOAT           shift and go to state 71
    ID              shift and go to state 73

    t                              shift and go to state 67
    mexp                           shift and go to state 127
    f                              shift and go to state 68
    var                            shift and go to state 62
    call                           shift and go to state 72

state 101

    (32) mexp -> t MINUS . mexp
    (30) mexp -> . t
    (31) mexp -> . t PLUS mexp
    (32) mexp -> . t MINUS mexp
    (33) t -> . f
    (34) t -> . f MULT t
    (35) t -> . f DIV t
    (36) f -> . LPAREN exp RPAREN
    (37) f -> . INT
    (38) f -> . FLOAT
    (39) f -> . var
    (40) f -> . call
    (56) var -> . ID
    (57) var -> . ID LBRACKET exp RBRACKET
    (58) var -> . ID LBRACKET exp RBRACKET LBRACKET exp RBRACKET
    (59) call -> . ID LPAREN callp RPAREN

    LPAREN          shift and go to state 69
    INT             shift and go to state 70
    FLOAT           shift and go to state 71
    ID              shift and go to state 73

    t                              shift and go to state 67
    mexp                           shift and go to state 128
    f                              shift and go to state 68
    var                            shift and go to state 62
    call                           shift and go to state 72

state 102

    (34) t -> f MULT . t
    (33) t -> . f
    (34) t -> . f MULT t
    (35) t -> . f DIV t
    (36) f -> . LPAREN exp RPAREN
    (37) f -> . INT
    (38) f -> . FLOAT
    (39) f -> . var
    (40) f -> . call
    (56) var -> . ID
    (57) var -> . ID LBRACKET exp RBRACKET
    (58) var -> . ID LBRACKET exp RBRACKET LBRACKET exp RBRACKET
    (59) call -> . ID LPAREN callp RPAREN

    LPAREN          shift and go to state 69
    INT             shift and go to state 70
    FLOAT           shift and go to state 71
    ID              shift and go to state 73

    f                              shift and go to state 68
    t                              shift and go to state 129
    var                            shift and go to state 62
    call                           shift and go to state 72

state 103

    (35) t -> f DIV . t
    (33) t -> . f
    (34) t -> . f MULT t
    (35) t -> . f DIV t
    (36) f -> . LPAREN exp RPAREN
    (37) f -> . INT
    (38) f -> . FLOAT
    (39) f -> . var
    (40) f -> . call
    (56) var -> . ID
    (57) var -> . ID LBRACKET exp RBRACKET
    (58) var -> . ID LBRACKET exp RBRACKET LBRACKET exp RBRACKET
    (59) call -> . ID LPAREN callp RPAREN

    LPAREN          shift and go to state 69
    INT             shift and go to state 70
    FLOAT           shift and go to state 71
    ID              shift and go to state 73

    f                              shift and go to state 68
    t                              shift and go to state 130
    var                            shift and go to state 62
    call                           shift and go to state 72

state 104

    (36) f -> LPAREN exp . RPAREN

    RPAREN          shift and go to state 131


state 105

    (9) function -> FUNCTION type ID LPAREN . param RPAREN body
    (16) param -> .
    (17) param -> . type paramp
    (7) type -> . INT
    (8) type -> . FLOAT

    RPAREN          reduce using rule 16 (param -> .)
    INT             shift and go to state 49
    FLOAT           shift and go to state 50

    type                           shift and go to state 132
    param                          shift and go to state 133

state 106

    (10) voidfunction -> FUNCTION VOID ID LPAREN . param RPAREN body
    (16) param -> .
    (17) param -> . type paramp
    (7) type -> . INT
    (8) type -> . FLOAT

    RPAREN          reduce using rule 16 (param -> .)
    INT             shift and go to state 49
    FLOAT           shift and go to state 50

    param                          shift and go to state 134
    type                           shift and go to state 132

state 107

    (59) call -> ID LPAREN callp RPAREN .

    $end            reduce using rule 59 (call -> ID LPAREN callp RPAREN .)
    SEMICOLON       reduce using rule 59 (call -> ID LPAREN callp RPAREN .)
    FUNCTION        reduce using rule 59 (call -> ID LPAREN callp RPAREN .)
    ID              reduce using rule 59 (call -> ID LPAREN callp RPAREN .)
    READ            reduce using rule 59 (call -> ID LPAREN callp RPAREN .)
    PRINT           reduce using rule 59 (call -> ID LPAREN callp RPAREN .)
    IF              reduce using rule 59 (call -> ID LPAREN callp RPAREN .)
    WHILE           reduce using rule 59 (call -> ID LPAREN callp RPAREN .)
    FOR             reduce using rule 59 (call -> ID LPAREN callp RPAREN .)
    MEAN            reduce using rule 59 (call -> ID LPAREN callp RPAREN .)
    VAR             reduce using rule 59 (call -> ID LPAREN callp RPAREN .)
    RBRACE          reduce using rule 59 (call -> ID LPAREN callp RPAREN .)
    RBRACKET        reduce using rule 59 (call -> ID LPAREN callp RPAREN .)
    MULT            reduce using rule 59 (call -> ID LPAREN callp RPAREN .)
    DIV             reduce using rule 59 (call -> ID LPAREN callp RPAREN .)
    PLUS            reduce using rule 59 (call -> ID LPAREN callp RPAREN .)
    MINUS           reduce using rule 59 (call -> ID LPAREN callp RPAREN .)
    LT              reduce using rule 59 (call -> ID LPAREN callp RPAREN .)
    GT              reduce using rule 59 (call -> ID LPAREN callp RPAREN .)
    EQUAL           reduce using rule 59 (call -> ID LPAREN callp RPAREN .)
    DIFF            reduce using rule 59 (call -> ID LPAREN callp RPAREN .)
    AND             reduce using rule 59 (call -> ID LPAREN callp RPAREN .)
    OR              reduce using rule 59 (call -> ID LPAREN callp RPAREN .)
    RPAREN          reduce using rule 59 (call -> ID LPAREN callp RPAREN .)
    COMMA           reduce using rule 59 (call -> ID LPAREN callp RPAREN .)


state 108

    (60) callp -> exp SEMICOLON . callp
    (60) callp -> . exp SEMICOLON callp
    (61) callp -> . exp
    (20) exp -> . texp
    (21) exp -> . texp OR exp
    (22) texp -> . gexp
    (23) texp -> . gexp AND texp
    (24) gexp -> . mexp
    (25) gexp -> . mexp gexpp mexp
    (30) mexp -> . t
    (31) mexp -> . t PLUS mexp
    (32) mexp -> . t MINUS mexp
    (33) t -> . f
    (34) t -> . f MULT t
    (35) t -> . f DIV t
    (36) f -> . LPAREN exp RPAREN
    (37) f -> . INT
    (38) f -> . FLOAT
    (39) f -> . var
    (40) f -> . call
    (56) var -> . ID
    (57) var -> . ID LBRACKET exp RBRACKET
    (58) var -> . ID LBRACKET exp RBRACKET LBRACKET exp RBRACKET
    (59) call -> . ID LPAREN callp RPAREN

    LPAREN          shift and go to state 69
    INT             shift and go to state 70
    FLOAT           shift and go to state 71
    ID              shift and go to state 73

    exp                            shift and go to state 77
    callp                          shift and go to state 135
    texp                           shift and go to state 64
    gexp                           shift and go to state 65
    mexp                           shift and go to state 66
    t                              shift and go to state 67
    f                              shift and go to state 68
    var                            shift and go to state 62
    call                           shift and go to state 72

state 109

    (57) var -> ID LBRACKET exp RBRACKET .
    (58) var -> ID LBRACKET exp RBRACKET . LBRACKET exp RBRACKET

    EQUAL           reduce using rule 57 (var -> ID LBRACKET exp RBRACKET .)
    $end            reduce using rule 57 (var -> ID LBRACKET exp RBRACKET .)
    SEMICOLON       reduce using rule 57 (var -> ID LBRACKET exp RBRACKET .)
    FUNCTION        reduce using rule 57 (var -> ID LBRACKET exp RBRACKET .)
    ID              reduce using rule 57 (var -> ID LBRACKET exp RBRACKET .)
    READ            reduce using rule 57 (var -> ID LBRACKET exp RBRACKET .)
    PRINT           reduce using rule 57 (var -> ID LBRACKET exp RBRACKET .)
    IF              reduce using rule 57 (var -> ID LBRACKET exp RBRACKET .)
    WHILE           reduce using rule 57 (var -> ID LBRACKET exp RBRACKET .)
    FOR             reduce using rule 57 (var -> ID LBRACKET exp RBRACKET .)
    MEAN            reduce using rule 57 (var -> ID LBRACKET exp RBRACKET .)
    VAR             reduce using rule 57 (var -> ID LBRACKET exp RBRACKET .)
    RBRACE          reduce using rule 57 (var -> ID LBRACKET exp RBRACKET .)
    RBRACKET        reduce using rule 57 (var -> ID LBRACKET exp RBRACKET .)
    MULT            reduce using rule 57 (var -> ID LBRACKET exp RBRACKET .)
    DIV             reduce using rule 57 (var -> ID LBRACKET exp RBRACKET .)
    PLUS            reduce using rule 57 (var -> ID LBRACKET exp RBRACKET .)
    MINUS           reduce using rule 57 (var -> ID LBRACKET exp RBRACKET .)
    LT              reduce using rule 57 (var -> ID LBRACKET exp RBRACKET .)
    GT              reduce using rule 57 (var -> ID LBRACKET exp RBRACKET .)
    DIFF            reduce using rule 57 (var -> ID LBRACKET exp RBRACKET .)
    AND             reduce using rule 57 (var -> ID LBRACKET exp RBRACKET .)
    OR              reduce using rule 57 (var -> ID LBRACKET exp RBRACKET .)
    RPAREN          reduce using rule 57 (var -> ID LBRACKET exp RBRACKET .)
    COMMA           reduce using rule 57 (var -> ID LBRACKET exp RBRACKET .)
    LBRACKET        shift and go to state 136


state 110

    (91) sequential -> ID EQUAL . SEQUENTIAL LPAREN LBRACKET layers sequentialp

    SEQUENTIAL      shift and go to state 83


state 111

    (83) array -> ID EQUAL ARRAY LPAREN . var arrayp
    (56) var -> . ID
    (57) var -> . ID LBRACKET exp RBRACKET
    (58) var -> . ID LBRACKET exp RBRACKET LBRACKET exp RBRACKET

    ID              shift and go to state 55

    var                            shift and go to state 137

state 112

    (86) matrix -> ID EQUAL MATRIX LPAREN . array matrixp
    (83) array -> . ID EQUAL ARRAY LPAREN var arrayp

    ID              shift and go to state 92

    array                          shift and go to state 138

state 113

    (90) layers -> ID EQUAL LAYERS LPAREN . UNITS EQUAL INT RPAREN

    UNITS           shift and go to state 139


state 114

    (91) sequential -> ID EQUAL SEQUENTIAL LPAREN . LBRACKET layers sequentialp

    LBRACKET        shift and go to state 140


state 115

    (95) fit -> ID EQUAL sequential DOT . FIT LPAREN array COMMA array COMMA EPOCHS EQUAL INT COMMA VERBOSE EQUAL fitp
    (98) predict -> ID EQUAL sequential DOT . PREDICT LPAREN LBRACKET predictp

    FIT             shift and go to state 141
    PREDICT         shift and go to state 142


state 116

    (54) printp -> exp RPAREN .

    $end            reduce using rule 54 (printp -> exp RPAREN .)
    SEMICOLON       reduce using rule 54 (printp -> exp RPAREN .)
    FUNCTION        reduce using rule 54 (printp -> exp RPAREN .)
    ID              reduce using rule 54 (printp -> exp RPAREN .)
    READ            reduce using rule 54 (printp -> exp RPAREN .)
    PRINT           reduce using rule 54 (printp -> exp RPAREN .)
    IF              reduce using rule 54 (printp -> exp RPAREN .)
    WHILE           reduce using rule 54 (printp -> exp RPAREN .)
    FOR             reduce using rule 54 (printp -> exp RPAREN .)
    MEAN            reduce using rule 54 (printp -> exp RPAREN .)
    VAR             reduce using rule 54 (printp -> exp RPAREN .)
    RBRACE          reduce using rule 54 (printp -> exp RPAREN .)
    RBRACKET        reduce using rule 54 (printp -> exp RPAREN .)


state 117

    (55) printp -> exp COMMA . printp
    (54) printp -> . exp RPAREN
    (55) printp -> . exp COMMA printp
    (20) exp -> . texp
    (21) exp -> . texp OR exp
    (22) texp -> . gexp
    (23) texp -> . gexp AND texp
    (24) gexp -> . mexp
    (25) gexp -> . mexp gexpp mexp
    (30) mexp -> . t
    (31) mexp -> . t PLUS mexp
    (32) mexp -> . t MINUS mexp
    (33) t -> . f
    (34) t -> . f MULT t
    (35) t -> . f DIV t
    (36) f -> . LPAREN exp RPAREN
    (37) f -> . INT
    (38) f -> . FLOAT
    (39) f -> . var
    (40) f -> . call
    (56) var -> . ID
    (57) var -> . ID LBRACKET exp RBRACKET
    (58) var -> . ID LBRACKET exp RBRACKET LBRACKET exp RBRACKET
    (59) call -> . ID LPAREN callp RPAREN

    LPAREN          shift and go to state 69
    INT             shift and go to state 70
    FLOAT           shift and go to state 71
    ID              shift and go to state 73

    exp                            shift and go to state 86
    printp                         shift and go to state 143
    texp                           shift and go to state 64
    gexp                           shift and go to state 65
    mexp                           shift and go to state 66
    t                              shift and go to state 67
    f                              shift and go to state 68
    var                            shift and go to state 62
    call                           shift and go to state 72

state 118

    (68) while -> WHILE LPAREN exp RPAREN . statements whilep
    (41) statements -> . assign
    (42) statements -> . function
    (43) statements -> . voidfunction
    (44) statements -> . call
    (45) statements -> . read
    (46) statements -> . print
    (47) statements -> . if
    (48) statements -> . while
    (49) statements -> . for
    (50) statements -> . funcesp
    (51) assign -> . var EQUAL exp
    (9) function -> . FUNCTION type ID LPAREN param RPAREN body
    (10) voidfunction -> . FUNCTION VOID ID LPAREN param RPAREN body
    (59) call -> . ID LPAREN callp RPAREN
    (52) read -> . READ var
    (53) print -> . PRINT LPAREN printp
    (62) if -> . IF LPAREN INT EQUAL EQUAL CTI RPAREN quadsIf ifp jumpsIf
    (68) while -> . WHILE LPAREN exp RPAREN statements whilep
    (71) for -> . FOR LPAREN var SEMICOLON exp SEMICOLON exp RPAREN LBRACKET statements forp
    (74) funcesp -> . array
    (75) funcesp -> . matrix
    (76) funcesp -> . mean
    (77) funcesp -> . layers
    (78) funcesp -> . sequential
    (79) funcesp -> . compile
    (80) funcesp -> . fit
    (81) funcesp -> . predict
    (82) funcesp -> . getweights
    (56) var -> . ID
    (57) var -> . ID LBRACKET exp RBRACKET
    (58) var -> . ID LBRACKET exp RBRACKET LBRACKET exp RBRACKET
    (83) array -> . ID EQUAL ARRAY LPAREN var arrayp
    (86) matrix -> . ID EQUAL MATRIX LPAREN array matrixp
    (89) mean -> . MEAN LPAREN array RPAREN
    (90) layers -> . ID EQUAL LAYERS LPAREN UNITS EQUAL INT RPAREN
    (91) sequential -> . ID EQUAL SEQUENTIAL LPAREN LBRACKET layers sequentialp
    (94) compile -> . sequential DOT COMPILE LPAREN RPAREN
    (95) fit -> . ID EQUAL sequential DOT FIT LPAREN array COMMA array COMMA EPOCHS EQUAL INT COMMA VERBOSE EQUAL fitp
    (98) predict -> . ID EQUAL sequential DOT PREDICT LPAREN LBRACKET predictp
    (101) getweights -> . layers DOT GETWEIGHTS LPAREN RPAREN

    FUNCTION        shift and go to state 30
    ID              shift and go to state 31
    READ            shift and go to state 32
    PRINT           shift and go to state 33
    IF              shift and go to state 6
    WHILE           shift and go to state 34
    FOR             shift and go to state 35
    MEAN            shift and go to state 45

    statements                     shift and go to state 144
    assign                         shift and go to state 19
    function                       shift and go to state 20
    voidfunction                   shift and go to state 21
    call                           shift and go to state 22
    read                           shift and go to state 23
    print                          shift and go to state 24
    if                             shift and go to state 25
    while                          shift and go to state 26
    for                            shift and go to state 27
    funcesp                        shift and go to state 28
    var                            shift and go to state 29
    array                          shift and go to state 36
    matrix                         shift and go to state 37
    mean                           shift and go to state 38
    layers                         shift and go to state 39
    sequential                     shift and go to state 40
    compile                        shift and go to state 41
    fit                            shift and go to state 42
    predict                        shift and go to state 43
    getweights                     shift and go to state 44

state 119

    (71) for -> FOR LPAREN var SEMICOLON . exp SEMICOLON exp RPAREN LBRACKET statements forp
    (20) exp -> . texp
    (21) exp -> . texp OR exp
    (22) texp -> . gexp
    (23) texp -> . gexp AND texp
    (24) gexp -> . mexp
    (25) gexp -> . mexp gexpp mexp
    (30) mexp -> . t
    (31) mexp -> . t PLUS mexp
    (32) mexp -> . t MINUS mexp
    (33) t -> . f
    (34) t -> . f MULT t
    (35) t -> . f DIV t
    (36) f -> . LPAREN exp RPAREN
    (37) f -> . INT
    (38) f -> . FLOAT
    (39) f -> . var
    (40) f -> . call
    (56) var -> . ID
    (57) var -> . ID LBRACKET exp RBRACKET
    (58) var -> . ID LBRACKET exp RBRACKET LBRACKET exp RBRACKET
    (59) call -> . ID LPAREN callp RPAREN

    LPAREN          shift and go to state 69
    INT             shift and go to state 70
    FLOAT           shift and go to state 71
    ID              shift and go to state 73

    var                            shift and go to state 62
    exp                            shift and go to state 145
    texp                           shift and go to state 64
    gexp                           shift and go to state 65
    mexp                           shift and go to state 66
    t                              shift and go to state 67
    f                              shift and go to state 68
    call                           shift and go to state 72

state 120

    (101) getweights -> layers DOT GETWEIGHTS LPAREN . RPAREN

    RPAREN          shift and go to state 146


state 121

    (94) compile -> sequential DOT COMPILE LPAREN . RPAREN

    RPAREN          shift and go to state 147


state 122

    (89) mean -> MEAN LPAREN array RPAREN .

    $end            reduce using rule 89 (mean -> MEAN LPAREN array RPAREN .)
    SEMICOLON       reduce using rule 89 (mean -> MEAN LPAREN array RPAREN .)
    FUNCTION        reduce using rule 89 (mean -> MEAN LPAREN array RPAREN .)
    ID              reduce using rule 89 (mean -> MEAN LPAREN array RPAREN .)
    READ            reduce using rule 89 (mean -> MEAN LPAREN array RPAREN .)
    PRINT           reduce using rule 89 (mean -> MEAN LPAREN array RPAREN .)
    IF              reduce using rule 89 (mean -> MEAN LPAREN array RPAREN .)
    WHILE           reduce using rule 89 (mean -> MEAN LPAREN array RPAREN .)
    FOR             reduce using rule 89 (mean -> MEAN LPAREN array RPAREN .)
    MEAN            reduce using rule 89 (mean -> MEAN LPAREN array RPAREN .)
    VAR             reduce using rule 89 (mean -> MEAN LPAREN array RPAREN .)
    RBRACE          reduce using rule 89 (mean -> MEAN LPAREN array RPAREN .)
    RBRACKET        reduce using rule 89 (mean -> MEAN LPAREN array RPAREN .)


state 123

    (83) array -> ID EQUAL . ARRAY LPAREN var arrayp

    ARRAY           shift and go to state 80


state 124

    (21) exp -> texp OR exp .

    $end            reduce using rule 21 (exp -> texp OR exp .)
    SEMICOLON       reduce using rule 21 (exp -> texp OR exp .)
    FUNCTION        reduce using rule 21 (exp -> texp OR exp .)
    ID              reduce using rule 21 (exp -> texp OR exp .)
    READ            reduce using rule 21 (exp -> texp OR exp .)
    PRINT           reduce using rule 21 (exp -> texp OR exp .)
    IF              reduce using rule 21 (exp -> texp OR exp .)
    WHILE           reduce using rule 21 (exp -> texp OR exp .)
    FOR             reduce using rule 21 (exp -> texp OR exp .)
    MEAN            reduce using rule 21 (exp -> texp OR exp .)
    VAR             reduce using rule 21 (exp -> texp OR exp .)
    RBRACE          reduce using rule 21 (exp -> texp OR exp .)
    RBRACKET        reduce using rule 21 (exp -> texp OR exp .)
    RPAREN          reduce using rule 21 (exp -> texp OR exp .)
    COMMA           reduce using rule 21 (exp -> texp OR exp .)


state 125

    (23) texp -> gexp AND texp .

    OR              reduce using rule 23 (texp -> gexp AND texp .)
    $end            reduce using rule 23 (texp -> gexp AND texp .)
    SEMICOLON       reduce using rule 23 (texp -> gexp AND texp .)
    FUNCTION        reduce using rule 23 (texp -> gexp AND texp .)
    ID              reduce using rule 23 (texp -> gexp AND texp .)
    READ            reduce using rule 23 (texp -> gexp AND texp .)
    PRINT           reduce using rule 23 (texp -> gexp AND texp .)
    IF              reduce using rule 23 (texp -> gexp AND texp .)
    WHILE           reduce using rule 23 (texp -> gexp AND texp .)
    FOR             reduce using rule 23 (texp -> gexp AND texp .)
    MEAN            reduce using rule 23 (texp -> gexp AND texp .)
    VAR             reduce using rule 23 (texp -> gexp AND texp .)
    RBRACE          reduce using rule 23 (texp -> gexp AND texp .)
    RBRACKET        reduce using rule 23 (texp -> gexp AND texp .)
    RPAREN          reduce using rule 23 (texp -> gexp AND texp .)
    COMMA           reduce using rule 23 (texp -> gexp AND texp .)


state 126

    (25) gexp -> mexp gexpp mexp .

    AND             reduce using rule 25 (gexp -> mexp gexpp mexp .)
    OR              reduce using rule 25 (gexp -> mexp gexpp mexp .)
    $end            reduce using rule 25 (gexp -> mexp gexpp mexp .)
    SEMICOLON       reduce using rule 25 (gexp -> mexp gexpp mexp .)
    FUNCTION        reduce using rule 25 (gexp -> mexp gexpp mexp .)
    ID              reduce using rule 25 (gexp -> mexp gexpp mexp .)
    READ            reduce using rule 25 (gexp -> mexp gexpp mexp .)
    PRINT           reduce using rule 25 (gexp -> mexp gexpp mexp .)
    IF              reduce using rule 25 (gexp -> mexp gexpp mexp .)
    WHILE           reduce using rule 25 (gexp -> mexp gexpp mexp .)
    FOR             reduce using rule 25 (gexp -> mexp gexpp mexp .)
    MEAN            reduce using rule 25 (gexp -> mexp gexpp mexp .)
    VAR             reduce using rule 25 (gexp -> mexp gexpp mexp .)
    RBRACE          reduce using rule 25 (gexp -> mexp gexpp mexp .)
    RBRACKET        reduce using rule 25 (gexp -> mexp gexpp mexp .)
    RPAREN          reduce using rule 25 (gexp -> mexp gexpp mexp .)
    COMMA           reduce using rule 25 (gexp -> mexp gexpp mexp .)


state 127

    (31) mexp -> t PLUS mexp .

    LT              reduce using rule 31 (mexp -> t PLUS mexp .)
    GT              reduce using rule 31 (mexp -> t PLUS mexp .)
    EQUAL           reduce using rule 31 (mexp -> t PLUS mexp .)
    DIFF            reduce using rule 31 (mexp -> t PLUS mexp .)
    AND             reduce using rule 31 (mexp -> t PLUS mexp .)
    OR              reduce using rule 31 (mexp -> t PLUS mexp .)
    $end            reduce using rule 31 (mexp -> t PLUS mexp .)
    SEMICOLON       reduce using rule 31 (mexp -> t PLUS mexp .)
    FUNCTION        reduce using rule 31 (mexp -> t PLUS mexp .)
    ID              reduce using rule 31 (mexp -> t PLUS mexp .)
    READ            reduce using rule 31 (mexp -> t PLUS mexp .)
    PRINT           reduce using rule 31 (mexp -> t PLUS mexp .)
    IF              reduce using rule 31 (mexp -> t PLUS mexp .)
    WHILE           reduce using rule 31 (mexp -> t PLUS mexp .)
    FOR             reduce using rule 31 (mexp -> t PLUS mexp .)
    MEAN            reduce using rule 31 (mexp -> t PLUS mexp .)
    VAR             reduce using rule 31 (mexp -> t PLUS mexp .)
    RBRACE          reduce using rule 31 (mexp -> t PLUS mexp .)
    RBRACKET        reduce using rule 31 (mexp -> t PLUS mexp .)
    RPAREN          reduce using rule 31 (mexp -> t PLUS mexp .)
    COMMA           reduce using rule 31 (mexp -> t PLUS mexp .)


state 128

    (32) mexp -> t MINUS mexp .

    LT              reduce using rule 32 (mexp -> t MINUS mexp .)
    GT              reduce using rule 32 (mexp -> t MINUS mexp .)
    EQUAL           reduce using rule 32 (mexp -> t MINUS mexp .)
    DIFF            reduce using rule 32 (mexp -> t MINUS mexp .)
    AND             reduce using rule 32 (mexp -> t MINUS mexp .)
    OR              reduce using rule 32 (mexp -> t MINUS mexp .)
    $end            reduce using rule 32 (mexp -> t MINUS mexp .)
    SEMICOLON       reduce using rule 32 (mexp -> t MINUS mexp .)
    FUNCTION        reduce using rule 32 (mexp -> t MINUS mexp .)
    ID              reduce using rule 32 (mexp -> t MINUS mexp .)
    READ            reduce using rule 32 (mexp -> t MINUS mexp .)
    PRINT           reduce using rule 32 (mexp -> t MINUS mexp .)
    IF              reduce using rule 32 (mexp -> t MINUS mexp .)
    WHILE           reduce using rule 32 (mexp -> t MINUS mexp .)
    FOR             reduce using rule 32 (mexp -> t MINUS mexp .)
    MEAN            reduce using rule 32 (mexp -> t MINUS mexp .)
    VAR             reduce using rule 32 (mexp -> t MINUS mexp .)
    RBRACE          reduce using rule 32 (mexp -> t MINUS mexp .)
    RBRACKET        reduce using rule 32 (mexp -> t MINUS mexp .)
    RPAREN          reduce using rule 32 (mexp -> t MINUS mexp .)
    COMMA           reduce using rule 32 (mexp -> t MINUS mexp .)


state 129

    (34) t -> f MULT t .

    PLUS            reduce using rule 34 (t -> f MULT t .)
    MINUS           reduce using rule 34 (t -> f MULT t .)
    LT              reduce using rule 34 (t -> f MULT t .)
    GT              reduce using rule 34 (t -> f MULT t .)
    EQUAL           reduce using rule 34 (t -> f MULT t .)
    DIFF            reduce using rule 34 (t -> f MULT t .)
    AND             reduce using rule 34 (t -> f MULT t .)
    OR              reduce using rule 34 (t -> f MULT t .)
    $end            reduce using rule 34 (t -> f MULT t .)
    SEMICOLON       reduce using rule 34 (t -> f MULT t .)
    FUNCTION        reduce using rule 34 (t -> f MULT t .)
    ID              reduce using rule 34 (t -> f MULT t .)
    READ            reduce using rule 34 (t -> f MULT t .)
    PRINT           reduce using rule 34 (t -> f MULT t .)
    IF              reduce using rule 34 (t -> f MULT t .)
    WHILE           reduce using rule 34 (t -> f MULT t .)
    FOR             reduce using rule 34 (t -> f MULT t .)
    MEAN            reduce using rule 34 (t -> f MULT t .)
    VAR             reduce using rule 34 (t -> f MULT t .)
    RBRACE          reduce using rule 34 (t -> f MULT t .)
    RBRACKET        reduce using rule 34 (t -> f MULT t .)
    RPAREN          reduce using rule 34 (t -> f MULT t .)
    COMMA           reduce using rule 34 (t -> f MULT t .)


state 130

    (35) t -> f DIV t .

    PLUS            reduce using rule 35 (t -> f DIV t .)
    MINUS           reduce using rule 35 (t -> f DIV t .)
    LT              reduce using rule 35 (t -> f DIV t .)
    GT              reduce using rule 35 (t -> f DIV t .)
    EQUAL           reduce using rule 35 (t -> f DIV t .)
    DIFF            reduce using rule 35 (t -> f DIV t .)
    AND             reduce using rule 35 (t -> f DIV t .)
    OR              reduce using rule 35 (t -> f DIV t .)
    $end            reduce using rule 35 (t -> f DIV t .)
    SEMICOLON       reduce using rule 35 (t -> f DIV t .)
    FUNCTION        reduce using rule 35 (t -> f DIV t .)
    ID              reduce using rule 35 (t -> f DIV t .)
    READ            reduce using rule 35 (t -> f DIV t .)
    PRINT           reduce using rule 35 (t -> f DIV t .)
    IF              reduce using rule 35 (t -> f DIV t .)
    WHILE           reduce using rule 35 (t -> f DIV t .)
    FOR             reduce using rule 35 (t -> f DIV t .)
    MEAN            reduce using rule 35 (t -> f DIV t .)
    VAR             reduce using rule 35 (t -> f DIV t .)
    RBRACE          reduce using rule 35 (t -> f DIV t .)
    RBRACKET        reduce using rule 35 (t -> f DIV t .)
    RPAREN          reduce using rule 35 (t -> f DIV t .)
    COMMA           reduce using rule 35 (t -> f DIV t .)


state 131

    (36) f -> LPAREN exp RPAREN .

    MULT            reduce using rule 36 (f -> LPAREN exp RPAREN .)
    DIV             reduce using rule 36 (f -> LPAREN exp RPAREN .)
    PLUS            reduce using rule 36 (f -> LPAREN exp RPAREN .)
    MINUS           reduce using rule 36 (f -> LPAREN exp RPAREN .)
    LT              reduce using rule 36 (f -> LPAREN exp RPAREN .)
    GT              reduce using rule 36 (f -> LPAREN exp RPAREN .)
    EQUAL           reduce using rule 36 (f -> LPAREN exp RPAREN .)
    DIFF            reduce using rule 36 (f -> LPAREN exp RPAREN .)
    AND             reduce using rule 36 (f -> LPAREN exp RPAREN .)
    OR              reduce using rule 36 (f -> LPAREN exp RPAREN .)
    $end            reduce using rule 36 (f -> LPAREN exp RPAREN .)
    SEMICOLON       reduce using rule 36 (f -> LPAREN exp RPAREN .)
    FUNCTION        reduce using rule 36 (f -> LPAREN exp RPAREN .)
    ID              reduce using rule 36 (f -> LPAREN exp RPAREN .)
    READ            reduce using rule 36 (f -> LPAREN exp RPAREN .)
    PRINT           reduce using rule 36 (f -> LPAREN exp RPAREN .)
    IF              reduce using rule 36 (f -> LPAREN exp RPAREN .)
    WHILE           reduce using rule 36 (f -> LPAREN exp RPAREN .)
    FOR             reduce using rule 36 (f -> LPAREN exp RPAREN .)
    MEAN            reduce using rule 36 (f -> LPAREN exp RPAREN .)
    VAR             reduce using rule 36 (f -> LPAREN exp RPAREN .)
    RBRACE          reduce using rule 36 (f -> LPAREN exp RPAREN .)
    RBRACKET        reduce using rule 36 (f -> LPAREN exp RPAREN .)
    RPAREN          reduce using rule 36 (f -> LPAREN exp RPAREN .)
    COMMA           reduce using rule 36 (f -> LPAREN exp RPAREN .)


state 132

    (17) param -> type . paramp
    (18) paramp -> . ID
    (19) paramp -> . ID COMMA param

    ID              shift and go to state 149

    paramp                         shift and go to state 148

state 133

    (9) function -> FUNCTION type ID LPAREN param . RPAREN body

    RPAREN          shift and go to state 150


state 134

    (10) voidfunction -> FUNCTION VOID ID LPAREN param . RPAREN body

    RPAREN          shift and go to state 151


state 135

    (60) callp -> exp SEMICOLON callp .

    RPAREN          reduce using rule 60 (callp -> exp SEMICOLON callp .)


state 136

    (58) var -> ID LBRACKET exp RBRACKET LBRACKET . exp RBRACKET
    (20) exp -> . texp
    (21) exp -> . texp OR exp
    (22) texp -> . gexp
    (23) texp -> . gexp AND texp
    (24) gexp -> . mexp
    (25) gexp -> . mexp gexpp mexp
    (30) mexp -> . t
    (31) mexp -> . t PLUS mexp
    (32) mexp -> . t MINUS mexp
    (33) t -> . f
    (34) t -> . f MULT t
    (35) t -> . f DIV t
    (36) f -> . LPAREN exp RPAREN
    (37) f -> . INT
    (38) f -> . FLOAT
    (39) f -> . var
    (40) f -> . call
    (56) var -> . ID
    (57) var -> . ID LBRACKET exp RBRACKET
    (58) var -> . ID LBRACKET exp RBRACKET LBRACKET exp RBRACKET
    (59) call -> . ID LPAREN callp RPAREN

    LPAREN          shift and go to state 69
    INT             shift and go to state 70
    FLOAT           shift and go to state 71
    ID              shift and go to state 73

    exp                            shift and go to state 152
    texp                           shift and go to state 64
    gexp                           shift and go to state 65
    mexp                           shift and go to state 66
    t                              shift and go to state 67
    f                              shift and go to state 68
    var                            shift and go to state 62
    call                           shift and go to state 72

state 137

    (83) array -> ID EQUAL ARRAY LPAREN var . arrayp
    (84) arrayp -> . RPAREN
    (85) arrayp -> . COMMA var RPAREN

    RPAREN          shift and go to state 154
    COMMA           shift and go to state 155

    arrayp                         shift and go to state 153

state 138

    (86) matrix -> ID EQUAL MATRIX LPAREN array . matrixp
    (87) matrixp -> . RPAREN
    (88) matrixp -> . COMMA array RPAREN

    RPAREN          shift and go to state 157
    COMMA           shift and go to state 158

    matrixp                        shift and go to state 156

state 139

    (90) layers -> ID EQUAL LAYERS LPAREN UNITS . EQUAL INT RPAREN

    EQUAL           shift and go to state 159


state 140

    (91) sequential -> ID EQUAL SEQUENTIAL LPAREN LBRACKET . layers sequentialp
    (90) layers -> . ID EQUAL LAYERS LPAREN UNITS EQUAL INT RPAREN

    ID              shift and go to state 160

    layers                         shift and go to state 161

state 141

    (95) fit -> ID EQUAL sequential DOT FIT . LPAREN array COMMA array COMMA EPOCHS EQUAL INT COMMA VERBOSE EQUAL fitp

    LPAREN          shift and go to state 162


state 142

    (98) predict -> ID EQUAL sequential DOT PREDICT . LPAREN LBRACKET predictp

    LPAREN          shift and go to state 163


state 143

    (55) printp -> exp COMMA printp .

    $end            reduce using rule 55 (printp -> exp COMMA printp .)
    SEMICOLON       reduce using rule 55 (printp -> exp COMMA printp .)
    FUNCTION        reduce using rule 55 (printp -> exp COMMA printp .)
    ID              reduce using rule 55 (printp -> exp COMMA printp .)
    READ            reduce using rule 55 (printp -> exp COMMA printp .)
    PRINT           reduce using rule 55 (printp -> exp COMMA printp .)
    IF              reduce using rule 55 (printp -> exp COMMA printp .)
    WHILE           reduce using rule 55 (printp -> exp COMMA printp .)
    FOR             reduce using rule 55 (printp -> exp COMMA printp .)
    MEAN            reduce using rule 55 (printp -> exp COMMA printp .)
    VAR             reduce using rule 55 (printp -> exp COMMA printp .)
    RBRACE          reduce using rule 55 (printp -> exp COMMA printp .)
    RBRACKET        reduce using rule 55 (printp -> exp COMMA printp .)


state 144

    (68) while -> WHILE LPAREN exp RPAREN statements . whilep
    (69) whilep -> . SEMICOLON
    (70) whilep -> . statements whilep
    (41) statements -> . assign
    (42) statements -> . function
    (43) statements -> . voidfunction
    (44) statements -> . call
    (45) statements -> . read
    (46) statements -> . print
    (47) statements -> . if
    (48) statements -> . while
    (49) statements -> . for
    (50) statements -> . funcesp
    (51) assign -> . var EQUAL exp
    (9) function -> . FUNCTION type ID LPAREN param RPAREN body
    (10) voidfunction -> . FUNCTION VOID ID LPAREN param RPAREN body
    (59) call -> . ID LPAREN callp RPAREN
    (52) read -> . READ var
    (53) print -> . PRINT LPAREN printp
    (62) if -> . IF LPAREN INT EQUAL EQUAL CTI RPAREN quadsIf ifp jumpsIf
    (68) while -> . WHILE LPAREN exp RPAREN statements whilep
    (71) for -> . FOR LPAREN var SEMICOLON exp SEMICOLON exp RPAREN LBRACKET statements forp
    (74) funcesp -> . array
    (75) funcesp -> . matrix
    (76) funcesp -> . mean
    (77) funcesp -> . layers
    (78) funcesp -> . sequential
    (79) funcesp -> . compile
    (80) funcesp -> . fit
    (81) funcesp -> . predict
    (82) funcesp -> . getweights
    (56) var -> . ID
    (57) var -> . ID LBRACKET exp RBRACKET
    (58) var -> . ID LBRACKET exp RBRACKET LBRACKET exp RBRACKET
    (83) array -> . ID EQUAL ARRAY LPAREN var arrayp
    (86) matrix -> . ID EQUAL MATRIX LPAREN array matrixp
    (89) mean -> . MEAN LPAREN array RPAREN
    (90) layers -> . ID EQUAL LAYERS LPAREN UNITS EQUAL INT RPAREN
    (91) sequential -> . ID EQUAL SEQUENTIAL LPAREN LBRACKET layers sequentialp
    (94) compile -> . sequential DOT COMPILE LPAREN RPAREN
    (95) fit -> . ID EQUAL sequential DOT FIT LPAREN array COMMA array COMMA EPOCHS EQUAL INT COMMA VERBOSE EQUAL fitp
    (98) predict -> . ID EQUAL sequential DOT PREDICT LPAREN LBRACKET predictp
    (101) getweights -> . layers DOT GETWEIGHTS LPAREN RPAREN

    SEMICOLON       shift and go to state 166
    FUNCTION        shift and go to state 30
    ID              shift and go to state 31
    READ            shift and go to state 32
    PRINT           shift and go to state 33
    IF              shift and go to state 6
    WHILE           shift and go to state 34
    FOR             shift and go to state 35
    MEAN            shift and go to state 45

    statements                     shift and go to state 164
    whilep                         shift and go to state 165
    assign                         shift and go to state 19
    function                       shift and go to state 20
    voidfunction                   shift and go to state 21
    call                           shift and go to state 22
    read                           shift and go to state 23
    print                          shift and go to state 24
    if                             shift and go to state 25
    while                          shift and go to state 26
    for                            shift and go to state 27
    funcesp                        shift and go to state 28
    var                            shift and go to state 29
    array                          shift and go to state 36
    matrix                         shift and go to state 37
    mean                           shift and go to state 38
    layers                         shift and go to state 39
    sequential                     shift and go to state 40
    compile                        shift and go to state 41
    fit                            shift and go to state 42
    predict                        shift and go to state 43
    getweights                     shift and go to state 44

state 145

    (71) for -> FOR LPAREN var SEMICOLON exp . SEMICOLON exp RPAREN LBRACKET statements forp

    SEMICOLON       shift and go to state 167


state 146

    (101) getweights -> layers DOT GETWEIGHTS LPAREN RPAREN .

    $end            reduce using rule 101 (getweights -> layers DOT GETWEIGHTS LPAREN RPAREN .)
    SEMICOLON       reduce using rule 101 (getweights -> layers DOT GETWEIGHTS LPAREN RPAREN .)
    FUNCTION        reduce using rule 101 (getweights -> layers DOT GETWEIGHTS LPAREN RPAREN .)
    ID              reduce using rule 101 (getweights -> layers DOT GETWEIGHTS LPAREN RPAREN .)
    READ            reduce using rule 101 (getweights -> layers DOT GETWEIGHTS LPAREN RPAREN .)
    PRINT           reduce using rule 101 (getweights -> layers DOT GETWEIGHTS LPAREN RPAREN .)
    IF              reduce using rule 101 (getweights -> layers DOT GETWEIGHTS LPAREN RPAREN .)
    WHILE           reduce using rule 101 (getweights -> layers DOT GETWEIGHTS LPAREN RPAREN .)
    FOR             reduce using rule 101 (getweights -> layers DOT GETWEIGHTS LPAREN RPAREN .)
    MEAN            reduce using rule 101 (getweights -> layers DOT GETWEIGHTS LPAREN RPAREN .)
    VAR             reduce using rule 101 (getweights -> layers DOT GETWEIGHTS LPAREN RPAREN .)
    RBRACE          reduce using rule 101 (getweights -> layers DOT GETWEIGHTS LPAREN RPAREN .)
    RBRACKET        reduce using rule 101 (getweights -> layers DOT GETWEIGHTS LPAREN RPAREN .)


state 147

    (94) compile -> sequential DOT COMPILE LPAREN RPAREN .

    $end            reduce using rule 94 (compile -> sequential DOT COMPILE LPAREN RPAREN .)
    SEMICOLON       reduce using rule 94 (compile -> sequential DOT COMPILE LPAREN RPAREN .)
    FUNCTION        reduce using rule 94 (compile -> sequential DOT COMPILE LPAREN RPAREN .)
    ID              reduce using rule 94 (compile -> sequential DOT COMPILE LPAREN RPAREN .)
    READ            reduce using rule 94 (compile -> sequential DOT COMPILE LPAREN RPAREN .)
    PRINT           reduce using rule 94 (compile -> sequential DOT COMPILE LPAREN RPAREN .)
    IF              reduce using rule 94 (compile -> sequential DOT COMPILE LPAREN RPAREN .)
    WHILE           reduce using rule 94 (compile -> sequential DOT COMPILE LPAREN RPAREN .)
    FOR             reduce using rule 94 (compile -> sequential DOT COMPILE LPAREN RPAREN .)
    MEAN            reduce using rule 94 (compile -> sequential DOT COMPILE LPAREN RPAREN .)
    VAR             reduce using rule 94 (compile -> sequential DOT COMPILE LPAREN RPAREN .)
    RBRACE          reduce using rule 94 (compile -> sequential DOT COMPILE LPAREN RPAREN .)
    RBRACKET        reduce using rule 94 (compile -> sequential DOT COMPILE LPAREN RPAREN .)


state 148

    (17) param -> type paramp .

    RPAREN          reduce using rule 17 (param -> type paramp .)


state 149

    (18) paramp -> ID .
    (19) paramp -> ID . COMMA param

    RPAREN          reduce using rule 18 (paramp -> ID .)
    COMMA           shift and go to state 168


state 150

    (9) function -> FUNCTION type ID LPAREN param RPAREN . body
    (11) body -> . LBRACE bodyp RBRACE

    LBRACE          shift and go to state 170

    body                           shift and go to state 169

state 151

    (10) voidfunction -> FUNCTION VOID ID LPAREN param RPAREN . body
    (11) body -> . LBRACE bodyp RBRACE

    LBRACE          shift and go to state 170

    body                           shift and go to state 171

state 152

    (58) var -> ID LBRACKET exp RBRACKET LBRACKET exp . RBRACKET

    RBRACKET        shift and go to state 172


state 153

    (83) array -> ID EQUAL ARRAY LPAREN var arrayp .

    $end            reduce using rule 83 (array -> ID EQUAL ARRAY LPAREN var arrayp .)
    SEMICOLON       reduce using rule 83 (array -> ID EQUAL ARRAY LPAREN var arrayp .)
    FUNCTION        reduce using rule 83 (array -> ID EQUAL ARRAY LPAREN var arrayp .)
    ID              reduce using rule 83 (array -> ID EQUAL ARRAY LPAREN var arrayp .)
    READ            reduce using rule 83 (array -> ID EQUAL ARRAY LPAREN var arrayp .)
    PRINT           reduce using rule 83 (array -> ID EQUAL ARRAY LPAREN var arrayp .)
    IF              reduce using rule 83 (array -> ID EQUAL ARRAY LPAREN var arrayp .)
    WHILE           reduce using rule 83 (array -> ID EQUAL ARRAY LPAREN var arrayp .)
    FOR             reduce using rule 83 (array -> ID EQUAL ARRAY LPAREN var arrayp .)
    MEAN            reduce using rule 83 (array -> ID EQUAL ARRAY LPAREN var arrayp .)
    VAR             reduce using rule 83 (array -> ID EQUAL ARRAY LPAREN var arrayp .)
    RBRACE          reduce using rule 83 (array -> ID EQUAL ARRAY LPAREN var arrayp .)
    RBRACKET        reduce using rule 83 (array -> ID EQUAL ARRAY LPAREN var arrayp .)
    RPAREN          reduce using rule 83 (array -> ID EQUAL ARRAY LPAREN var arrayp .)
    COMMA           reduce using rule 83 (array -> ID EQUAL ARRAY LPAREN var arrayp .)


state 154

    (84) arrayp -> RPAREN .

    $end            reduce using rule 84 (arrayp -> RPAREN .)
    SEMICOLON       reduce using rule 84 (arrayp -> RPAREN .)
    FUNCTION        reduce using rule 84 (arrayp -> RPAREN .)
    ID              reduce using rule 84 (arrayp -> RPAREN .)
    READ            reduce using rule 84 (arrayp -> RPAREN .)
    PRINT           reduce using rule 84 (arrayp -> RPAREN .)
    IF              reduce using rule 84 (arrayp -> RPAREN .)
    WHILE           reduce using rule 84 (arrayp -> RPAREN .)
    FOR             reduce using rule 84 (arrayp -> RPAREN .)
    MEAN            reduce using rule 84 (arrayp -> RPAREN .)
    VAR             reduce using rule 84 (arrayp -> RPAREN .)
    RBRACE          reduce using rule 84 (arrayp -> RPAREN .)
    RBRACKET        reduce using rule 84 (arrayp -> RPAREN .)
    RPAREN          reduce using rule 84 (arrayp -> RPAREN .)
    COMMA           reduce using rule 84 (arrayp -> RPAREN .)


state 155

    (85) arrayp -> COMMA . var RPAREN
    (56) var -> . ID
    (57) var -> . ID LBRACKET exp RBRACKET
    (58) var -> . ID LBRACKET exp RBRACKET LBRACKET exp RBRACKET

    ID              shift and go to state 55

    var                            shift and go to state 173

state 156

    (86) matrix -> ID EQUAL MATRIX LPAREN array matrixp .

    $end            reduce using rule 86 (matrix -> ID EQUAL MATRIX LPAREN array matrixp .)
    SEMICOLON       reduce using rule 86 (matrix -> ID EQUAL MATRIX LPAREN array matrixp .)
    FUNCTION        reduce using rule 86 (matrix -> ID EQUAL MATRIX LPAREN array matrixp .)
    ID              reduce using rule 86 (matrix -> ID EQUAL MATRIX LPAREN array matrixp .)
    READ            reduce using rule 86 (matrix -> ID EQUAL MATRIX LPAREN array matrixp .)
    PRINT           reduce using rule 86 (matrix -> ID EQUAL MATRIX LPAREN array matrixp .)
    IF              reduce using rule 86 (matrix -> ID EQUAL MATRIX LPAREN array matrixp .)
    WHILE           reduce using rule 86 (matrix -> ID EQUAL MATRIX LPAREN array matrixp .)
    FOR             reduce using rule 86 (matrix -> ID EQUAL MATRIX LPAREN array matrixp .)
    MEAN            reduce using rule 86 (matrix -> ID EQUAL MATRIX LPAREN array matrixp .)
    VAR             reduce using rule 86 (matrix -> ID EQUAL MATRIX LPAREN array matrixp .)
    RBRACE          reduce using rule 86 (matrix -> ID EQUAL MATRIX LPAREN array matrixp .)
    RBRACKET        reduce using rule 86 (matrix -> ID EQUAL MATRIX LPAREN array matrixp .)


state 157

    (87) matrixp -> RPAREN .

    $end            reduce using rule 87 (matrixp -> RPAREN .)
    SEMICOLON       reduce using rule 87 (matrixp -> RPAREN .)
    FUNCTION        reduce using rule 87 (matrixp -> RPAREN .)
    ID              reduce using rule 87 (matrixp -> RPAREN .)
    READ            reduce using rule 87 (matrixp -> RPAREN .)
    PRINT           reduce using rule 87 (matrixp -> RPAREN .)
    IF              reduce using rule 87 (matrixp -> RPAREN .)
    WHILE           reduce using rule 87 (matrixp -> RPAREN .)
    FOR             reduce using rule 87 (matrixp -> RPAREN .)
    MEAN            reduce using rule 87 (matrixp -> RPAREN .)
    VAR             reduce using rule 87 (matrixp -> RPAREN .)
    RBRACE          reduce using rule 87 (matrixp -> RPAREN .)
    RBRACKET        reduce using rule 87 (matrixp -> RPAREN .)


state 158

    (88) matrixp -> COMMA . array RPAREN
    (83) array -> . ID EQUAL ARRAY LPAREN var arrayp

    ID              shift and go to state 92

    array                          shift and go to state 174

state 159

    (90) layers -> ID EQUAL LAYERS LPAREN UNITS EQUAL . INT RPAREN

    INT             shift and go to state 175


state 160

    (90) layers -> ID . EQUAL LAYERS LPAREN UNITS EQUAL INT RPAREN

    EQUAL           shift and go to state 176


state 161

    (91) sequential -> ID EQUAL SEQUENTIAL LPAREN LBRACKET layers . sequentialp
    (92) sequentialp -> . RBRACKET RPAREN
    (93) sequentialp -> . COMMA layers sequentialp

    RBRACKET        shift and go to state 178
    COMMA           shift and go to state 179

    sequentialp                    shift and go to state 177

state 162

    (95) fit -> ID EQUAL sequential DOT FIT LPAREN . array COMMA array COMMA EPOCHS EQUAL INT COMMA VERBOSE EQUAL fitp
    (83) array -> . ID EQUAL ARRAY LPAREN var arrayp

    ID              shift and go to state 92

    array                          shift and go to state 180

state 163

    (98) predict -> ID EQUAL sequential DOT PREDICT LPAREN . LBRACKET predictp

    LBRACKET        shift and go to state 181


state 164

    (70) whilep -> statements . whilep
    (69) whilep -> . SEMICOLON
    (70) whilep -> . statements whilep
    (41) statements -> . assign
    (42) statements -> . function
    (43) statements -> . voidfunction
    (44) statements -> . call
    (45) statements -> . read
    (46) statements -> . print
    (47) statements -> . if
    (48) statements -> . while
    (49) statements -> . for
    (50) statements -> . funcesp
    (51) assign -> . var EQUAL exp
    (9) function -> . FUNCTION type ID LPAREN param RPAREN body
    (10) voidfunction -> . FUNCTION VOID ID LPAREN param RPAREN body
    (59) call -> . ID LPAREN callp RPAREN
    (52) read -> . READ var
    (53) print -> . PRINT LPAREN printp
    (62) if -> . IF LPAREN INT EQUAL EQUAL CTI RPAREN quadsIf ifp jumpsIf
    (68) while -> . WHILE LPAREN exp RPAREN statements whilep
    (71) for -> . FOR LPAREN var SEMICOLON exp SEMICOLON exp RPAREN LBRACKET statements forp
    (74) funcesp -> . array
    (75) funcesp -> . matrix
    (76) funcesp -> . mean
    (77) funcesp -> . layers
    (78) funcesp -> . sequential
    (79) funcesp -> . compile
    (80) funcesp -> . fit
    (81) funcesp -> . predict
    (82) funcesp -> . getweights
    (56) var -> . ID
    (57) var -> . ID LBRACKET exp RBRACKET
    (58) var -> . ID LBRACKET exp RBRACKET LBRACKET exp RBRACKET
    (83) array -> . ID EQUAL ARRAY LPAREN var arrayp
    (86) matrix -> . ID EQUAL MATRIX LPAREN array matrixp
    (89) mean -> . MEAN LPAREN array RPAREN
    (90) layers -> . ID EQUAL LAYERS LPAREN UNITS EQUAL INT RPAREN
    (91) sequential -> . ID EQUAL SEQUENTIAL LPAREN LBRACKET layers sequentialp
    (94) compile -> . sequential DOT COMPILE LPAREN RPAREN
    (95) fit -> . ID EQUAL sequential DOT FIT LPAREN array COMMA array COMMA EPOCHS EQUAL INT COMMA VERBOSE EQUAL fitp
    (98) predict -> . ID EQUAL sequential DOT PREDICT LPAREN LBRACKET predictp
    (101) getweights -> . layers DOT GETWEIGHTS LPAREN RPAREN

    SEMICOLON       shift and go to state 166
    FUNCTION        shift and go to state 30
    ID              shift and go to state 31
    READ            shift and go to state 32
    PRINT           shift and go to state 33
    IF              shift and go to state 6
    WHILE           shift and go to state 34
    FOR             shift and go to state 35
    MEAN            shift and go to state 45

    statements                     shift and go to state 164
    whilep                         shift and go to state 182
    assign                         shift and go to state 19
    function                       shift and go to state 20
    voidfunction                   shift and go to state 21
    call                           shift and go to state 22
    read                           shift and go to state 23
    print                          shift and go to state 24
    if                             shift and go to state 25
    while                          shift and go to state 26
    for                            shift and go to state 27
    funcesp                        shift and go to state 28
    var                            shift and go to state 29
    array                          shift and go to state 36
    matrix                         shift and go to state 37
    mean                           shift and go to state 38
    layers                         shift and go to state 39
    sequential                     shift and go to state 40
    compile                        shift and go to state 41
    fit                            shift and go to state 42
    predict                        shift and go to state 43
    getweights                     shift and go to state 44

state 165

    (68) while -> WHILE LPAREN exp RPAREN statements whilep .

    $end            reduce using rule 68 (while -> WHILE LPAREN exp RPAREN statements whilep .)
    SEMICOLON       reduce using rule 68 (while -> WHILE LPAREN exp RPAREN statements whilep .)
    FUNCTION        reduce using rule 68 (while -> WHILE LPAREN exp RPAREN statements whilep .)
    ID              reduce using rule 68 (while -> WHILE LPAREN exp RPAREN statements whilep .)
    READ            reduce using rule 68 (while -> WHILE LPAREN exp RPAREN statements whilep .)
    PRINT           reduce using rule 68 (while -> WHILE LPAREN exp RPAREN statements whilep .)
    IF              reduce using rule 68 (while -> WHILE LPAREN exp RPAREN statements whilep .)
    WHILE           reduce using rule 68 (while -> WHILE LPAREN exp RPAREN statements whilep .)
    FOR             reduce using rule 68 (while -> WHILE LPAREN exp RPAREN statements whilep .)
    MEAN            reduce using rule 68 (while -> WHILE LPAREN exp RPAREN statements whilep .)
    VAR             reduce using rule 68 (while -> WHILE LPAREN exp RPAREN statements whilep .)
    RBRACE          reduce using rule 68 (while -> WHILE LPAREN exp RPAREN statements whilep .)
    RBRACKET        reduce using rule 68 (while -> WHILE LPAREN exp RPAREN statements whilep .)


state 166

    (69) whilep -> SEMICOLON .

    $end            reduce using rule 69 (whilep -> SEMICOLON .)
    SEMICOLON       reduce using rule 69 (whilep -> SEMICOLON .)
    FUNCTION        reduce using rule 69 (whilep -> SEMICOLON .)
    ID              reduce using rule 69 (whilep -> SEMICOLON .)
    READ            reduce using rule 69 (whilep -> SEMICOLON .)
    PRINT           reduce using rule 69 (whilep -> SEMICOLON .)
    IF              reduce using rule 69 (whilep -> SEMICOLON .)
    WHILE           reduce using rule 69 (whilep -> SEMICOLON .)
    FOR             reduce using rule 69 (whilep -> SEMICOLON .)
    MEAN            reduce using rule 69 (whilep -> SEMICOLON .)
    VAR             reduce using rule 69 (whilep -> SEMICOLON .)
    RBRACE          reduce using rule 69 (whilep -> SEMICOLON .)
    RBRACKET        reduce using rule 69 (whilep -> SEMICOLON .)


state 167

    (71) for -> FOR LPAREN var SEMICOLON exp SEMICOLON . exp RPAREN LBRACKET statements forp
    (20) exp -> . texp
    (21) exp -> . texp OR exp
    (22) texp -> . gexp
    (23) texp -> . gexp AND texp
    (24) gexp -> . mexp
    (25) gexp -> . mexp gexpp mexp
    (30) mexp -> . t
    (31) mexp -> . t PLUS mexp
    (32) mexp -> . t MINUS mexp
    (33) t -> . f
    (34) t -> . f MULT t
    (35) t -> . f DIV t
    (36) f -> . LPAREN exp RPAREN
    (37) f -> . INT
    (38) f -> . FLOAT
    (39) f -> . var
    (40) f -> . call
    (56) var -> . ID
    (57) var -> . ID LBRACKET exp RBRACKET
    (58) var -> . ID LBRACKET exp RBRACKET LBRACKET exp RBRACKET
    (59) call -> . ID LPAREN callp RPAREN

    LPAREN          shift and go to state 69
    INT             shift and go to state 70
    FLOAT           shift and go to state 71
    ID              shift and go to state 73

    var                            shift and go to state 62
    exp                            shift and go to state 183
    texp                           shift and go to state 64
    gexp                           shift and go to state 65
    mexp                           shift and go to state 66
    t                              shift and go to state 67
    f                              shift and go to state 68
    call                           shift and go to state 72

state 168

    (19) paramp -> ID COMMA . param
    (16) param -> .
    (17) param -> . type paramp
    (7) type -> . INT
    (8) type -> . FLOAT

    RPAREN          reduce using rule 16 (param -> .)
    INT             shift and go to state 49
    FLOAT           shift and go to state 50

    param                          shift and go to state 184
    type                           shift and go to state 132

state 169

    (9) function -> FUNCTION type ID LPAREN param RPAREN body .

    $end            reduce using rule 9 (function -> FUNCTION type ID LPAREN param RPAREN body .)
    SEMICOLON       reduce using rule 9 (function -> FUNCTION type ID LPAREN param RPAREN body .)
    FUNCTION        reduce using rule 9 (function -> FUNCTION type ID LPAREN param RPAREN body .)
    ID              reduce using rule 9 (function -> FUNCTION type ID LPAREN param RPAREN body .)
    READ            reduce using rule 9 (function -> FUNCTION type ID LPAREN param RPAREN body .)
    PRINT           reduce using rule 9 (function -> FUNCTION type ID LPAREN param RPAREN body .)
    IF              reduce using rule 9 (function -> FUNCTION type ID LPAREN param RPAREN body .)
    WHILE           reduce using rule 9 (function -> FUNCTION type ID LPAREN param RPAREN body .)
    FOR             reduce using rule 9 (function -> FUNCTION type ID LPAREN param RPAREN body .)
    MEAN            reduce using rule 9 (function -> FUNCTION type ID LPAREN param RPAREN body .)
    VAR             reduce using rule 9 (function -> FUNCTION type ID LPAREN param RPAREN body .)
    RBRACE          reduce using rule 9 (function -> FUNCTION type ID LPAREN param RPAREN body .)
    RBRACKET        reduce using rule 9 (function -> FUNCTION type ID LPAREN param RPAREN body .)


state 170

    (11) body -> LBRACE . bodyp RBRACE
    (12) bodyp -> . decvar statements bodyp
    (13) bodyp -> . statements bodyp
    (14) bodyp -> . decvar
    (15) bodyp -> .
    (2) decvar -> . VAR decvarp
    (3) decvar -> . VAR decvarp decvar
    (41) statements -> . assign
    (42) statements -> . function
    (43) statements -> . voidfunction
    (44) statements -> . call
    (45) statements -> . read
    (46) statements -> . print
    (47) statements -> . if
    (48) statements -> . while
    (49) statements -> . for
    (50) statements -> . funcesp
    (51) assign -> . var EQUAL exp
    (9) function -> . FUNCTION type ID LPAREN param RPAREN body
    (10) voidfunction -> . FUNCTION VOID ID LPAREN param RPAREN body
    (59) call -> . ID LPAREN callp RPAREN
    (52) read -> . READ var
    (53) print -> . PRINT LPAREN printp
    (62) if -> . IF LPAREN INT EQUAL EQUAL CTI RPAREN quadsIf ifp jumpsIf
    (68) while -> . WHILE LPAREN exp RPAREN statements whilep
    (71) for -> . FOR LPAREN var SEMICOLON exp SEMICOLON exp RPAREN LBRACKET statements forp
    (74) funcesp -> . array
    (75) funcesp -> . matrix
    (76) funcesp -> . mean
    (77) funcesp -> . layers
    (78) funcesp -> . sequential
    (79) funcesp -> . compile
    (80) funcesp -> . fit
    (81) funcesp -> . predict
    (82) funcesp -> . getweights
    (56) var -> . ID
    (57) var -> . ID LBRACKET exp RBRACKET
    (58) var -> . ID LBRACKET exp RBRACKET LBRACKET exp RBRACKET
    (83) array -> . ID EQUAL ARRAY LPAREN var arrayp
    (86) matrix -> . ID EQUAL MATRIX LPAREN array matrixp
    (89) mean -> . MEAN LPAREN array RPAREN
    (90) layers -> . ID EQUAL LAYERS LPAREN UNITS EQUAL INT RPAREN
    (91) sequential -> . ID EQUAL SEQUENTIAL LPAREN LBRACKET layers sequentialp
    (94) compile -> . sequential DOT COMPILE LPAREN RPAREN
    (95) fit -> . ID EQUAL sequential DOT FIT LPAREN array COMMA array COMMA EPOCHS EQUAL INT COMMA VERBOSE EQUAL fitp
    (98) predict -> . ID EQUAL sequential DOT PREDICT LPAREN LBRACKET predictp
    (101) getweights -> . layers DOT GETWEIGHTS LPAREN RPAREN

    RBRACE          reduce using rule 15 (bodyp -> .)
    VAR             shift and go to state 188
    FUNCTION        shift and go to state 30
    ID              shift and go to state 31
    READ            shift and go to state 32
    PRINT           shift and go to state 33
    IF              shift and go to state 6
    WHILE           shift and go to state 34
    FOR             shift and go to state 35
    MEAN            shift and go to state 45

    bodyp                          shift and go to state 185
    decvar                         shift and go to state 186
    statements                     shift and go to state 187
    assign                         shift and go to state 19
    function                       shift and go to state 20
    voidfunction                   shift and go to state 21
    call                           shift and go to state 22
    read                           shift and go to state 23
    print                          shift and go to state 24
    if                             shift and go to state 25
    while                          shift and go to state 26
    for                            shift and go to state 27
    funcesp                        shift and go to state 28
    var                            shift and go to state 29
    array                          shift and go to state 36
    matrix                         shift and go to state 37
    mean                           shift and go to state 38
    layers                         shift and go to state 39
    sequential                     shift and go to state 40
    compile                        shift and go to state 41
    fit                            shift and go to state 42
    predict                        shift and go to state 43
    getweights                     shift and go to state 44

state 171

    (10) voidfunction -> FUNCTION VOID ID LPAREN param RPAREN body .

    $end            reduce using rule 10 (voidfunction -> FUNCTION VOID ID LPAREN param RPAREN body .)
    SEMICOLON       reduce using rule 10 (voidfunction -> FUNCTION VOID ID LPAREN param RPAREN body .)
    FUNCTION        reduce using rule 10 (voidfunction -> FUNCTION VOID ID LPAREN param RPAREN body .)
    ID              reduce using rule 10 (voidfunction -> FUNCTION VOID ID LPAREN param RPAREN body .)
    READ            reduce using rule 10 (voidfunction -> FUNCTION VOID ID LPAREN param RPAREN body .)
    PRINT           reduce using rule 10 (voidfunction -> FUNCTION VOID ID LPAREN param RPAREN body .)
    IF              reduce using rule 10 (voidfunction -> FUNCTION VOID ID LPAREN param RPAREN body .)
    WHILE           reduce using rule 10 (voidfunction -> FUNCTION VOID ID LPAREN param RPAREN body .)
    FOR             reduce using rule 10 (voidfunction -> FUNCTION VOID ID LPAREN param RPAREN body .)
    MEAN            reduce using rule 10 (voidfunction -> FUNCTION VOID ID LPAREN param RPAREN body .)
    VAR             reduce using rule 10 (voidfunction -> FUNCTION VOID ID LPAREN param RPAREN body .)
    RBRACE          reduce using rule 10 (voidfunction -> FUNCTION VOID ID LPAREN param RPAREN body .)
    RBRACKET        reduce using rule 10 (voidfunction -> FUNCTION VOID ID LPAREN param RPAREN body .)


state 172

    (58) var -> ID LBRACKET exp RBRACKET LBRACKET exp RBRACKET .

    EQUAL           reduce using rule 58 (var -> ID LBRACKET exp RBRACKET LBRACKET exp RBRACKET .)
    $end            reduce using rule 58 (var -> ID LBRACKET exp RBRACKET LBRACKET exp RBRACKET .)
    SEMICOLON       reduce using rule 58 (var -> ID LBRACKET exp RBRACKET LBRACKET exp RBRACKET .)
    FUNCTION        reduce using rule 58 (var -> ID LBRACKET exp RBRACKET LBRACKET exp RBRACKET .)
    ID              reduce using rule 58 (var -> ID LBRACKET exp RBRACKET LBRACKET exp RBRACKET .)
    READ            reduce using rule 58 (var -> ID LBRACKET exp RBRACKET LBRACKET exp RBRACKET .)
    PRINT           reduce using rule 58 (var -> ID LBRACKET exp RBRACKET LBRACKET exp RBRACKET .)
    IF              reduce using rule 58 (var -> ID LBRACKET exp RBRACKET LBRACKET exp RBRACKET .)
    WHILE           reduce using rule 58 (var -> ID LBRACKET exp RBRACKET LBRACKET exp RBRACKET .)
    FOR             reduce using rule 58 (var -> ID LBRACKET exp RBRACKET LBRACKET exp RBRACKET .)
    MEAN            reduce using rule 58 (var -> ID LBRACKET exp RBRACKET LBRACKET exp RBRACKET .)
    VAR             reduce using rule 58 (var -> ID LBRACKET exp RBRACKET LBRACKET exp RBRACKET .)
    RBRACE          reduce using rule 58 (var -> ID LBRACKET exp RBRACKET LBRACKET exp RBRACKET .)
    RBRACKET        reduce using rule 58 (var -> ID LBRACKET exp RBRACKET LBRACKET exp RBRACKET .)
    MULT            reduce using rule 58 (var -> ID LBRACKET exp RBRACKET LBRACKET exp RBRACKET .)
    DIV             reduce using rule 58 (var -> ID LBRACKET exp RBRACKET LBRACKET exp RBRACKET .)
    PLUS            reduce using rule 58 (var -> ID LBRACKET exp RBRACKET LBRACKET exp RBRACKET .)
    MINUS           reduce using rule 58 (var -> ID LBRACKET exp RBRACKET LBRACKET exp RBRACKET .)
    LT              reduce using rule 58 (var -> ID LBRACKET exp RBRACKET LBRACKET exp RBRACKET .)
    GT              reduce using rule 58 (var -> ID LBRACKET exp RBRACKET LBRACKET exp RBRACKET .)
    DIFF            reduce using rule 58 (var -> ID LBRACKET exp RBRACKET LBRACKET exp RBRACKET .)
    AND             reduce using rule 58 (var -> ID LBRACKET exp RBRACKET LBRACKET exp RBRACKET .)
    OR              reduce using rule 58 (var -> ID LBRACKET exp RBRACKET LBRACKET exp RBRACKET .)
    RPAREN          reduce using rule 58 (var -> ID LBRACKET exp RBRACKET LBRACKET exp RBRACKET .)
    COMMA           reduce using rule 58 (var -> ID LBRACKET exp RBRACKET LBRACKET exp RBRACKET .)


state 173

    (85) arrayp -> COMMA var . RPAREN

    RPAREN          shift and go to state 189


state 174

    (88) matrixp -> COMMA array . RPAREN

    RPAREN          shift and go to state 190


state 175

    (90) layers -> ID EQUAL LAYERS LPAREN UNITS EQUAL INT . RPAREN

    RPAREN          shift and go to state 191


state 176

    (90) layers -> ID EQUAL . LAYERS LPAREN UNITS EQUAL INT RPAREN

    LAYERS          shift and go to state 82


state 177

    (91) sequential -> ID EQUAL SEQUENTIAL LPAREN LBRACKET layers sequentialp .

    DOT             reduce using rule 91 (sequential -> ID EQUAL SEQUENTIAL LPAREN LBRACKET layers sequentialp .)
    $end            reduce using rule 91 (sequential -> ID EQUAL SEQUENTIAL LPAREN LBRACKET layers sequentialp .)
    SEMICOLON       reduce using rule 91 (sequential -> ID EQUAL SEQUENTIAL LPAREN LBRACKET layers sequentialp .)
    FUNCTION        reduce using rule 91 (sequential -> ID EQUAL SEQUENTIAL LPAREN LBRACKET layers sequentialp .)
    ID              reduce using rule 91 (sequential -> ID EQUAL SEQUENTIAL LPAREN LBRACKET layers sequentialp .)
    READ            reduce using rule 91 (sequential -> ID EQUAL SEQUENTIAL LPAREN LBRACKET layers sequentialp .)
    PRINT           reduce using rule 91 (sequential -> ID EQUAL SEQUENTIAL LPAREN LBRACKET layers sequentialp .)
    IF              reduce using rule 91 (sequential -> ID EQUAL SEQUENTIAL LPAREN LBRACKET layers sequentialp .)
    WHILE           reduce using rule 91 (sequential -> ID EQUAL SEQUENTIAL LPAREN LBRACKET layers sequentialp .)
    FOR             reduce using rule 91 (sequential -> ID EQUAL SEQUENTIAL LPAREN LBRACKET layers sequentialp .)
    MEAN            reduce using rule 91 (sequential -> ID EQUAL SEQUENTIAL LPAREN LBRACKET layers sequentialp .)
    VAR             reduce using rule 91 (sequential -> ID EQUAL SEQUENTIAL LPAREN LBRACKET layers sequentialp .)
    RBRACE          reduce using rule 91 (sequential -> ID EQUAL SEQUENTIAL LPAREN LBRACKET layers sequentialp .)
    RBRACKET        reduce using rule 91 (sequential -> ID EQUAL SEQUENTIAL LPAREN LBRACKET layers sequentialp .)


state 178

    (92) sequentialp -> RBRACKET . RPAREN

    RPAREN          shift and go to state 192


state 179

    (93) sequentialp -> COMMA . layers sequentialp
    (90) layers -> . ID EQUAL LAYERS LPAREN UNITS EQUAL INT RPAREN

    ID              shift and go to state 160

    layers                         shift and go to state 193

state 180

    (95) fit -> ID EQUAL sequential DOT FIT LPAREN array . COMMA array COMMA EPOCHS EQUAL INT COMMA VERBOSE EQUAL fitp

    COMMA           shift and go to state 194


state 181

    (98) predict -> ID EQUAL sequential DOT PREDICT LPAREN LBRACKET . predictp
    (99) predictp -> . INT RBRACKET RPAREN
    (100) predictp -> . FLOAT RBRACKET RPAREN

    INT             shift and go to state 196
    FLOAT           shift and go to state 197

    predictp                       shift and go to state 195

state 182

    (70) whilep -> statements whilep .

    $end            reduce using rule 70 (whilep -> statements whilep .)
    SEMICOLON       reduce using rule 70 (whilep -> statements whilep .)
    FUNCTION        reduce using rule 70 (whilep -> statements whilep .)
    ID              reduce using rule 70 (whilep -> statements whilep .)
    READ            reduce using rule 70 (whilep -> statements whilep .)
    PRINT           reduce using rule 70 (whilep -> statements whilep .)
    IF              reduce using rule 70 (whilep -> statements whilep .)
    WHILE           reduce using rule 70 (whilep -> statements whilep .)
    FOR             reduce using rule 70 (whilep -> statements whilep .)
    MEAN            reduce using rule 70 (whilep -> statements whilep .)
    VAR             reduce using rule 70 (whilep -> statements whilep .)
    RBRACE          reduce using rule 70 (whilep -> statements whilep .)
    RBRACKET        reduce using rule 70 (whilep -> statements whilep .)


state 183

    (71) for -> FOR LPAREN var SEMICOLON exp SEMICOLON exp . RPAREN LBRACKET statements forp

    RPAREN          shift and go to state 198


state 184

    (19) paramp -> ID COMMA param .

    RPAREN          reduce using rule 19 (paramp -> ID COMMA param .)


state 185

    (11) body -> LBRACE bodyp . RBRACE

    RBRACE          shift and go to state 199


state 186

    (12) bodyp -> decvar . statements bodyp
    (14) bodyp -> decvar .
    (41) statements -> . assign
    (42) statements -> . function
    (43) statements -> . voidfunction
    (44) statements -> . call
    (45) statements -> . read
    (46) statements -> . print
    (47) statements -> . if
    (48) statements -> . while
    (49) statements -> . for
    (50) statements -> . funcesp
    (51) assign -> . var EQUAL exp
    (9) function -> . FUNCTION type ID LPAREN param RPAREN body
    (10) voidfunction -> . FUNCTION VOID ID LPAREN param RPAREN body
    (59) call -> . ID LPAREN callp RPAREN
    (52) read -> . READ var
    (53) print -> . PRINT LPAREN printp
    (62) if -> . IF LPAREN INT EQUAL EQUAL CTI RPAREN quadsIf ifp jumpsIf
    (68) while -> . WHILE LPAREN exp RPAREN statements whilep
    (71) for -> . FOR LPAREN var SEMICOLON exp SEMICOLON exp RPAREN LBRACKET statements forp
    (74) funcesp -> . array
    (75) funcesp -> . matrix
    (76) funcesp -> . mean
    (77) funcesp -> . layers
    (78) funcesp -> . sequential
    (79) funcesp -> . compile
    (80) funcesp -> . fit
    (81) funcesp -> . predict
    (82) funcesp -> . getweights
    (56) var -> . ID
    (57) var -> . ID LBRACKET exp RBRACKET
    (58) var -> . ID LBRACKET exp RBRACKET LBRACKET exp RBRACKET
    (83) array -> . ID EQUAL ARRAY LPAREN var arrayp
    (86) matrix -> . ID EQUAL MATRIX LPAREN array matrixp
    (89) mean -> . MEAN LPAREN array RPAREN
    (90) layers -> . ID EQUAL LAYERS LPAREN UNITS EQUAL INT RPAREN
    (91) sequential -> . ID EQUAL SEQUENTIAL LPAREN LBRACKET layers sequentialp
    (94) compile -> . sequential DOT COMPILE LPAREN RPAREN
    (95) fit -> . ID EQUAL sequential DOT FIT LPAREN array COMMA array COMMA EPOCHS EQUAL INT COMMA VERBOSE EQUAL fitp
    (98) predict -> . ID EQUAL sequential DOT PREDICT LPAREN LBRACKET predictp
    (101) getweights -> . layers DOT GETWEIGHTS LPAREN RPAREN

    RBRACE          reduce using rule 14 (bodyp -> decvar .)
    FUNCTION        shift and go to state 30
    ID              shift and go to state 31
    READ            shift and go to state 32
    PRINT           shift and go to state 33
    IF              shift and go to state 6
    WHILE           shift and go to state 34
    FOR             shift and go to state 35
    MEAN            shift and go to state 45

    statements                     shift and go to state 200
    assign                         shift and go to state 19
    function                       shift and go to state 20
    voidfunction                   shift and go to state 21
    call                           shift and go to state 22
    read                           shift and go to state 23
    print                          shift and go to state 24
    if                             shift and go to state 25
    while                          shift and go to state 26
    for                            shift and go to state 27
    funcesp                        shift and go to state 28
    var                            shift and go to state 29
    array                          shift and go to state 36
    matrix                         shift and go to state 37
    mean                           shift and go to state 38
    layers                         shift and go to state 39
    sequential                     shift and go to state 40
    compile                        shift and go to state 41
    fit                            shift and go to state 42
    predict                        shift and go to state 43
    getweights                     shift and go to state 44

state 187

    (13) bodyp -> statements . bodyp
    (12) bodyp -> . decvar statements bodyp
    (13) bodyp -> . statements bodyp
    (14) bodyp -> . decvar
    (15) bodyp -> .
    (2) decvar -> . VAR decvarp
    (3) decvar -> . VAR decvarp decvar
    (41) statements -> . assign
    (42) statements -> . function
    (43) statements -> . voidfunction
    (44) statements -> . call
    (45) statements -> . read
    (46) statements -> . print
    (47) statements -> . if
    (48) statements -> . while
    (49) statements -> . for
    (50) statements -> . funcesp
    (51) assign -> . var EQUAL exp
    (9) function -> . FUNCTION type ID LPAREN param RPAREN body
    (10) voidfunction -> . FUNCTION VOID ID LPAREN param RPAREN body
    (59) call -> . ID LPAREN callp RPAREN
    (52) read -> . READ var
    (53) print -> . PRINT LPAREN printp
    (62) if -> . IF LPAREN INT EQUAL EQUAL CTI RPAREN quadsIf ifp jumpsIf
    (68) while -> . WHILE LPAREN exp RPAREN statements whilep
    (71) for -> . FOR LPAREN var SEMICOLON exp SEMICOLON exp RPAREN LBRACKET statements forp
    (74) funcesp -> . array
    (75) funcesp -> . matrix
    (76) funcesp -> . mean
    (77) funcesp -> . layers
    (78) funcesp -> . sequential
    (79) funcesp -> . compile
    (80) funcesp -> . fit
    (81) funcesp -> . predict
    (82) funcesp -> . getweights
    (56) var -> . ID
    (57) var -> . ID LBRACKET exp RBRACKET
    (58) var -> . ID LBRACKET exp RBRACKET LBRACKET exp RBRACKET
    (83) array -> . ID EQUAL ARRAY LPAREN var arrayp
    (86) matrix -> . ID EQUAL MATRIX LPAREN array matrixp
    (89) mean -> . MEAN LPAREN array RPAREN
    (90) layers -> . ID EQUAL LAYERS LPAREN UNITS EQUAL INT RPAREN
    (91) sequential -> . ID EQUAL SEQUENTIAL LPAREN LBRACKET layers sequentialp
    (94) compile -> . sequential DOT COMPILE LPAREN RPAREN
    (95) fit -> . ID EQUAL sequential DOT FIT LPAREN array COMMA array COMMA EPOCHS EQUAL INT COMMA VERBOSE EQUAL fitp
    (98) predict -> . ID EQUAL sequential DOT PREDICT LPAREN LBRACKET predictp
    (101) getweights -> . layers DOT GETWEIGHTS LPAREN RPAREN

    RBRACE          reduce using rule 15 (bodyp -> .)
    VAR             shift and go to state 188
    FUNCTION        shift and go to state 30
    ID              shift and go to state 31
    READ            shift and go to state 32
    PRINT           shift and go to state 33
    IF              shift and go to state 6
    WHILE           shift and go to state 34
    FOR             shift and go to state 35
    MEAN            shift and go to state 45

    statements                     shift and go to state 187
    bodyp                          shift and go to state 201
    decvar                         shift and go to state 186
    assign                         shift and go to state 19
    function                       shift and go to state 20
    voidfunction                   shift and go to state 21
    call                           shift and go to state 22
    read                           shift and go to state 23
    print                          shift and go to state 24
    if                             shift and go to state 25
    while                          shift and go to state 26
    for                            shift and go to state 27
    funcesp                        shift and go to state 28
    var                            shift and go to state 29
    array                          shift and go to state 36
    matrix                         shift and go to state 37
    mean                           shift and go to state 38
    layers                         shift and go to state 39
    sequential                     shift and go to state 40
    compile                        shift and go to state 41
    fit                            shift and go to state 42
    predict                        shift and go to state 43
    getweights                     shift and go to state 44

state 188

    (2) decvar -> VAR . decvarp
    (3) decvar -> VAR . decvarp decvar
    (4) decvarp -> . type decvarpp SEMICOLON
    (7) type -> . INT
    (8) type -> . FLOAT

    INT             shift and go to state 49
    FLOAT           shift and go to state 50

    decvarp                        shift and go to state 202
    type                           shift and go to state 203

state 189

    (85) arrayp -> COMMA var RPAREN .

    $end            reduce using rule 85 (arrayp -> COMMA var RPAREN .)
    SEMICOLON       reduce using rule 85 (arrayp -> COMMA var RPAREN .)
    FUNCTION        reduce using rule 85 (arrayp -> COMMA var RPAREN .)
    ID              reduce using rule 85 (arrayp -> COMMA var RPAREN .)
    READ            reduce using rule 85 (arrayp -> COMMA var RPAREN .)
    PRINT           reduce using rule 85 (arrayp -> COMMA var RPAREN .)
    IF              reduce using rule 85 (arrayp -> COMMA var RPAREN .)
    WHILE           reduce using rule 85 (arrayp -> COMMA var RPAREN .)
    FOR             reduce using rule 85 (arrayp -> COMMA var RPAREN .)
    MEAN            reduce using rule 85 (arrayp -> COMMA var RPAREN .)
    VAR             reduce using rule 85 (arrayp -> COMMA var RPAREN .)
    RBRACE          reduce using rule 85 (arrayp -> COMMA var RPAREN .)
    RBRACKET        reduce using rule 85 (arrayp -> COMMA var RPAREN .)
    RPAREN          reduce using rule 85 (arrayp -> COMMA var RPAREN .)
    COMMA           reduce using rule 85 (arrayp -> COMMA var RPAREN .)


state 190

    (88) matrixp -> COMMA array RPAREN .

    $end            reduce using rule 88 (matrixp -> COMMA array RPAREN .)
    SEMICOLON       reduce using rule 88 (matrixp -> COMMA array RPAREN .)
    FUNCTION        reduce using rule 88 (matrixp -> COMMA array RPAREN .)
    ID              reduce using rule 88 (matrixp -> COMMA array RPAREN .)
    READ            reduce using rule 88 (matrixp -> COMMA array RPAREN .)
    PRINT           reduce using rule 88 (matrixp -> COMMA array RPAREN .)
    IF              reduce using rule 88 (matrixp -> COMMA array RPAREN .)
    WHILE           reduce using rule 88 (matrixp -> COMMA array RPAREN .)
    FOR             reduce using rule 88 (matrixp -> COMMA array RPAREN .)
    MEAN            reduce using rule 88 (matrixp -> COMMA array RPAREN .)
    VAR             reduce using rule 88 (matrixp -> COMMA array RPAREN .)
    RBRACE          reduce using rule 88 (matrixp -> COMMA array RPAREN .)
    RBRACKET        reduce using rule 88 (matrixp -> COMMA array RPAREN .)


state 191

    (90) layers -> ID EQUAL LAYERS LPAREN UNITS EQUAL INT RPAREN .

    DOT             reduce using rule 90 (layers -> ID EQUAL LAYERS LPAREN UNITS EQUAL INT RPAREN .)
    $end            reduce using rule 90 (layers -> ID EQUAL LAYERS LPAREN UNITS EQUAL INT RPAREN .)
    SEMICOLON       reduce using rule 90 (layers -> ID EQUAL LAYERS LPAREN UNITS EQUAL INT RPAREN .)
    FUNCTION        reduce using rule 90 (layers -> ID EQUAL LAYERS LPAREN UNITS EQUAL INT RPAREN .)
    ID              reduce using rule 90 (layers -> ID EQUAL LAYERS LPAREN UNITS EQUAL INT RPAREN .)
    READ            reduce using rule 90 (layers -> ID EQUAL LAYERS LPAREN UNITS EQUAL INT RPAREN .)
    PRINT           reduce using rule 90 (layers -> ID EQUAL LAYERS LPAREN UNITS EQUAL INT RPAREN .)
    IF              reduce using rule 90 (layers -> ID EQUAL LAYERS LPAREN UNITS EQUAL INT RPAREN .)
    WHILE           reduce using rule 90 (layers -> ID EQUAL LAYERS LPAREN UNITS EQUAL INT RPAREN .)
    FOR             reduce using rule 90 (layers -> ID EQUAL LAYERS LPAREN UNITS EQUAL INT RPAREN .)
    MEAN            reduce using rule 90 (layers -> ID EQUAL LAYERS LPAREN UNITS EQUAL INT RPAREN .)
    VAR             reduce using rule 90 (layers -> ID EQUAL LAYERS LPAREN UNITS EQUAL INT RPAREN .)
    RBRACE          reduce using rule 90 (layers -> ID EQUAL LAYERS LPAREN UNITS EQUAL INT RPAREN .)
    RBRACKET        reduce using rule 90 (layers -> ID EQUAL LAYERS LPAREN UNITS EQUAL INT RPAREN .)
    COMMA           reduce using rule 90 (layers -> ID EQUAL LAYERS LPAREN UNITS EQUAL INT RPAREN .)


state 192

    (92) sequentialp -> RBRACKET RPAREN .

    DOT             reduce using rule 92 (sequentialp -> RBRACKET RPAREN .)
    $end            reduce using rule 92 (sequentialp -> RBRACKET RPAREN .)
    SEMICOLON       reduce using rule 92 (sequentialp -> RBRACKET RPAREN .)
    FUNCTION        reduce using rule 92 (sequentialp -> RBRACKET RPAREN .)
    ID              reduce using rule 92 (sequentialp -> RBRACKET RPAREN .)
    READ            reduce using rule 92 (sequentialp -> RBRACKET RPAREN .)
    PRINT           reduce using rule 92 (sequentialp -> RBRACKET RPAREN .)
    IF              reduce using rule 92 (sequentialp -> RBRACKET RPAREN .)
    WHILE           reduce using rule 92 (sequentialp -> RBRACKET RPAREN .)
    FOR             reduce using rule 92 (sequentialp -> RBRACKET RPAREN .)
    MEAN            reduce using rule 92 (sequentialp -> RBRACKET RPAREN .)
    VAR             reduce using rule 92 (sequentialp -> RBRACKET RPAREN .)
    RBRACE          reduce using rule 92 (sequentialp -> RBRACKET RPAREN .)
    RBRACKET        reduce using rule 92 (sequentialp -> RBRACKET RPAREN .)


state 193

    (93) sequentialp -> COMMA layers . sequentialp
    (92) sequentialp -> . RBRACKET RPAREN
    (93) sequentialp -> . COMMA layers sequentialp

    RBRACKET        shift and go to state 178
    COMMA           shift and go to state 179

    sequentialp                    shift and go to state 204

state 194

    (95) fit -> ID EQUAL sequential DOT FIT LPAREN array COMMA . array COMMA EPOCHS EQUAL INT COMMA VERBOSE EQUAL fitp
    (83) array -> . ID EQUAL ARRAY LPAREN var arrayp

    ID              shift and go to state 92

    array                          shift and go to state 205

state 195

    (98) predict -> ID EQUAL sequential DOT PREDICT LPAREN LBRACKET predictp .

    $end            reduce using rule 98 (predict -> ID EQUAL sequential DOT PREDICT LPAREN LBRACKET predictp .)
    SEMICOLON       reduce using rule 98 (predict -> ID EQUAL sequential DOT PREDICT LPAREN LBRACKET predictp .)
    FUNCTION        reduce using rule 98 (predict -> ID EQUAL sequential DOT PREDICT LPAREN LBRACKET predictp .)
    ID              reduce using rule 98 (predict -> ID EQUAL sequential DOT PREDICT LPAREN LBRACKET predictp .)
    READ            reduce using rule 98 (predict -> ID EQUAL sequential DOT PREDICT LPAREN LBRACKET predictp .)
    PRINT           reduce using rule 98 (predict -> ID EQUAL sequential DOT PREDICT LPAREN LBRACKET predictp .)
    IF              reduce using rule 98 (predict -> ID EQUAL sequential DOT PREDICT LPAREN LBRACKET predictp .)
    WHILE           reduce using rule 98 (predict -> ID EQUAL sequential DOT PREDICT LPAREN LBRACKET predictp .)
    FOR             reduce using rule 98 (predict -> ID EQUAL sequential DOT PREDICT LPAREN LBRACKET predictp .)
    MEAN            reduce using rule 98 (predict -> ID EQUAL sequential DOT PREDICT LPAREN LBRACKET predictp .)
    VAR             reduce using rule 98 (predict -> ID EQUAL sequential DOT PREDICT LPAREN LBRACKET predictp .)
    RBRACE          reduce using rule 98 (predict -> ID EQUAL sequential DOT PREDICT LPAREN LBRACKET predictp .)
    RBRACKET        reduce using rule 98 (predict -> ID EQUAL sequential DOT PREDICT LPAREN LBRACKET predictp .)


state 196

    (99) predictp -> INT . RBRACKET RPAREN

    RBRACKET        shift and go to state 206


state 197

    (100) predictp -> FLOAT . RBRACKET RPAREN

    RBRACKET        shift and go to state 207


state 198

    (71) for -> FOR LPAREN var SEMICOLON exp SEMICOLON exp RPAREN . LBRACKET statements forp

    LBRACKET        shift and go to state 208


state 199

    (11) body -> LBRACE bodyp RBRACE .

    $end            reduce using rule 11 (body -> LBRACE bodyp RBRACE .)
    SEMICOLON       reduce using rule 11 (body -> LBRACE bodyp RBRACE .)
    FUNCTION        reduce using rule 11 (body -> LBRACE bodyp RBRACE .)
    ID              reduce using rule 11 (body -> LBRACE bodyp RBRACE .)
    READ            reduce using rule 11 (body -> LBRACE bodyp RBRACE .)
    PRINT           reduce using rule 11 (body -> LBRACE bodyp RBRACE .)
    IF              reduce using rule 11 (body -> LBRACE bodyp RBRACE .)
    WHILE           reduce using rule 11 (body -> LBRACE bodyp RBRACE .)
    FOR             reduce using rule 11 (body -> LBRACE bodyp RBRACE .)
    MEAN            reduce using rule 11 (body -> LBRACE bodyp RBRACE .)
    VAR             reduce using rule 11 (body -> LBRACE bodyp RBRACE .)
    RBRACE          reduce using rule 11 (body -> LBRACE bodyp RBRACE .)
    RBRACKET        reduce using rule 11 (body -> LBRACE bodyp RBRACE .)


state 200

    (12) bodyp -> decvar statements . bodyp
    (12) bodyp -> . decvar statements bodyp
    (13) bodyp -> . statements bodyp
    (14) bodyp -> . decvar
    (15) bodyp -> .
    (2) decvar -> . VAR decvarp
    (3) decvar -> . VAR decvarp decvar
    (41) statements -> . assign
    (42) statements -> . function
    (43) statements -> . voidfunction
    (44) statements -> . call
    (45) statements -> . read
    (46) statements -> . print
    (47) statements -> . if
    (48) statements -> . while
    (49) statements -> . for
    (50) statements -> . funcesp
    (51) assign -> . var EQUAL exp
    (9) function -> . FUNCTION type ID LPAREN param RPAREN body
    (10) voidfunction -> . FUNCTION VOID ID LPAREN param RPAREN body
    (59) call -> . ID LPAREN callp RPAREN
    (52) read -> . READ var
    (53) print -> . PRINT LPAREN printp
    (62) if -> . IF LPAREN INT EQUAL EQUAL CTI RPAREN quadsIf ifp jumpsIf
    (68) while -> . WHILE LPAREN exp RPAREN statements whilep
    (71) for -> . FOR LPAREN var SEMICOLON exp SEMICOLON exp RPAREN LBRACKET statements forp
    (74) funcesp -> . array
    (75) funcesp -> . matrix
    (76) funcesp -> . mean
    (77) funcesp -> . layers
    (78) funcesp -> . sequential
    (79) funcesp -> . compile
    (80) funcesp -> . fit
    (81) funcesp -> . predict
    (82) funcesp -> . getweights
    (56) var -> . ID
    (57) var -> . ID LBRACKET exp RBRACKET
    (58) var -> . ID LBRACKET exp RBRACKET LBRACKET exp RBRACKET
    (83) array -> . ID EQUAL ARRAY LPAREN var arrayp
    (86) matrix -> . ID EQUAL MATRIX LPAREN array matrixp
    (89) mean -> . MEAN LPAREN array RPAREN
    (90) layers -> . ID EQUAL LAYERS LPAREN UNITS EQUAL INT RPAREN
    (91) sequential -> . ID EQUAL SEQUENTIAL LPAREN LBRACKET layers sequentialp
    (94) compile -> . sequential DOT COMPILE LPAREN RPAREN
    (95) fit -> . ID EQUAL sequential DOT FIT LPAREN array COMMA array COMMA EPOCHS EQUAL INT COMMA VERBOSE EQUAL fitp
    (98) predict -> . ID EQUAL sequential DOT PREDICT LPAREN LBRACKET predictp
    (101) getweights -> . layers DOT GETWEIGHTS LPAREN RPAREN

    RBRACE          reduce using rule 15 (bodyp -> .)
    VAR             shift and go to state 188
    FUNCTION        shift and go to state 30
    ID              shift and go to state 31
    READ            shift and go to state 32
    PRINT           shift and go to state 33
    IF              shift and go to state 6
    WHILE           shift and go to state 34
    FOR             shift and go to state 35
    MEAN            shift and go to state 45

    decvar                         shift and go to state 186
    statements                     shift and go to state 187
    bodyp                          shift and go to state 209
    assign                         shift and go to state 19
    function                       shift and go to state 20
    voidfunction                   shift and go to state 21
    call                           shift and go to state 22
    read                           shift and go to state 23
    print                          shift and go to state 24
    if                             shift and go to state 25
    while                          shift and go to state 26
    for                            shift and go to state 27
    funcesp                        shift and go to state 28
    var                            shift and go to state 29
    array                          shift and go to state 36
    matrix                         shift and go to state 37
    mean                           shift and go to state 38
    layers                         shift and go to state 39
    sequential                     shift and go to state 40
    compile                        shift and go to state 41
    fit                            shift and go to state 42
    predict                        shift and go to state 43
    getweights                     shift and go to state 44

state 201

    (13) bodyp -> statements bodyp .

    RBRACE          reduce using rule 13 (bodyp -> statements bodyp .)


state 202

    (2) decvar -> VAR decvarp .
    (3) decvar -> VAR decvarp . decvar
    (2) decvar -> . VAR decvarp
    (3) decvar -> . VAR decvarp decvar

    FUNCTION        reduce using rule 2 (decvar -> VAR decvarp .)
    ID              reduce using rule 2 (decvar -> VAR decvarp .)
    READ            reduce using rule 2 (decvar -> VAR decvarp .)
    PRINT           reduce using rule 2 (decvar -> VAR decvarp .)
    IF              reduce using rule 2 (decvar -> VAR decvarp .)
    WHILE           reduce using rule 2 (decvar -> VAR decvarp .)
    FOR             reduce using rule 2 (decvar -> VAR decvarp .)
    MEAN            reduce using rule 2 (decvar -> VAR decvarp .)
    RBRACE          reduce using rule 2 (decvar -> VAR decvarp .)
    VAR             shift and go to state 188

    decvar                         shift and go to state 210

state 203

    (4) decvarp -> type . decvarpp SEMICOLON
    (5) decvarpp -> . ID COMMA decvarpp
    (6) decvarpp -> . ID

    ID              shift and go to state 212

    decvarpp                       shift and go to state 211

state 204

    (93) sequentialp -> COMMA layers sequentialp .

    DOT             reduce using rule 93 (sequentialp -> COMMA layers sequentialp .)
    $end            reduce using rule 93 (sequentialp -> COMMA layers sequentialp .)
    SEMICOLON       reduce using rule 93 (sequentialp -> COMMA layers sequentialp .)
    FUNCTION        reduce using rule 93 (sequentialp -> COMMA layers sequentialp .)
    ID              reduce using rule 93 (sequentialp -> COMMA layers sequentialp .)
    READ            reduce using rule 93 (sequentialp -> COMMA layers sequentialp .)
    PRINT           reduce using rule 93 (sequentialp -> COMMA layers sequentialp .)
    IF              reduce using rule 93 (sequentialp -> COMMA layers sequentialp .)
    WHILE           reduce using rule 93 (sequentialp -> COMMA layers sequentialp .)
    FOR             reduce using rule 93 (sequentialp -> COMMA layers sequentialp .)
    MEAN            reduce using rule 93 (sequentialp -> COMMA layers sequentialp .)
    VAR             reduce using rule 93 (sequentialp -> COMMA layers sequentialp .)
    RBRACE          reduce using rule 93 (sequentialp -> COMMA layers sequentialp .)
    RBRACKET        reduce using rule 93 (sequentialp -> COMMA layers sequentialp .)


state 205

    (95) fit -> ID EQUAL sequential DOT FIT LPAREN array COMMA array . COMMA EPOCHS EQUAL INT COMMA VERBOSE EQUAL fitp

    COMMA           shift and go to state 213


state 206

    (99) predictp -> INT RBRACKET . RPAREN

    RPAREN          shift and go to state 214


state 207

    (100) predictp -> FLOAT RBRACKET . RPAREN

    RPAREN          shift and go to state 215


state 208

    (71) for -> FOR LPAREN var SEMICOLON exp SEMICOLON exp RPAREN LBRACKET . statements forp
    (41) statements -> . assign
    (42) statements -> . function
    (43) statements -> . voidfunction
    (44) statements -> . call
    (45) statements -> . read
    (46) statements -> . print
    (47) statements -> . if
    (48) statements -> . while
    (49) statements -> . for
    (50) statements -> . funcesp
    (51) assign -> . var EQUAL exp
    (9) function -> . FUNCTION type ID LPAREN param RPAREN body
    (10) voidfunction -> . FUNCTION VOID ID LPAREN param RPAREN body
    (59) call -> . ID LPAREN callp RPAREN
    (52) read -> . READ var
    (53) print -> . PRINT LPAREN printp
    (62) if -> . IF LPAREN INT EQUAL EQUAL CTI RPAREN quadsIf ifp jumpsIf
    (68) while -> . WHILE LPAREN exp RPAREN statements whilep
    (71) for -> . FOR LPAREN var SEMICOLON exp SEMICOLON exp RPAREN LBRACKET statements forp
    (74) funcesp -> . array
    (75) funcesp -> . matrix
    (76) funcesp -> . mean
    (77) funcesp -> . layers
    (78) funcesp -> . sequential
    (79) funcesp -> . compile
    (80) funcesp -> . fit
    (81) funcesp -> . predict
    (82) funcesp -> . getweights
    (56) var -> . ID
    (57) var -> . ID LBRACKET exp RBRACKET
    (58) var -> . ID LBRACKET exp RBRACKET LBRACKET exp RBRACKET
    (83) array -> . ID EQUAL ARRAY LPAREN var arrayp
    (86) matrix -> . ID EQUAL MATRIX LPAREN array matrixp
    (89) mean -> . MEAN LPAREN array RPAREN
    (90) layers -> . ID EQUAL LAYERS LPAREN UNITS EQUAL INT RPAREN
    (91) sequential -> . ID EQUAL SEQUENTIAL LPAREN LBRACKET layers sequentialp
    (94) compile -> . sequential DOT COMPILE LPAREN RPAREN
    (95) fit -> . ID EQUAL sequential DOT FIT LPAREN array COMMA array COMMA EPOCHS EQUAL INT COMMA VERBOSE EQUAL fitp
    (98) predict -> . ID EQUAL sequential DOT PREDICT LPAREN LBRACKET predictp
    (101) getweights -> . layers DOT GETWEIGHTS LPAREN RPAREN

    FUNCTION        shift and go to state 30
    ID              shift and go to state 31
    READ            shift and go to state 32
    PRINT           shift and go to state 33
    IF              shift and go to state 6
    WHILE           shift and go to state 34
    FOR             shift and go to state 35
    MEAN            shift and go to state 45

    var                            shift and go to state 29
    statements                     shift and go to state 216
    assign                         shift and go to state 19
    function                       shift and go to state 20
    voidfunction                   shift and go to state 21
    call                           shift and go to state 22
    read                           shift and go to state 23
    print                          shift and go to state 24
    if                             shift and go to state 25
    while                          shift and go to state 26
    for                            shift and go to state 27
    funcesp                        shift and go to state 28
    array                          shift and go to state 36
    matrix                         shift and go to state 37
    mean                           shift and go to state 38
    layers                         shift and go to state 39
    sequential                     shift and go to state 40
    compile                        shift and go to state 41
    fit                            shift and go to state 42
    predict                        shift and go to state 43
    getweights                     shift and go to state 44

state 209

    (12) bodyp -> decvar statements bodyp .

    RBRACE          reduce using rule 12 (bodyp -> decvar statements bodyp .)


state 210

    (3) decvar -> VAR decvarp decvar .

    FUNCTION        reduce using rule 3 (decvar -> VAR decvarp decvar .)
    ID              reduce using rule 3 (decvar -> VAR decvarp decvar .)
    READ            reduce using rule 3 (decvar -> VAR decvarp decvar .)
    PRINT           reduce using rule 3 (decvar -> VAR decvarp decvar .)
    IF              reduce using rule 3 (decvar -> VAR decvarp decvar .)
    WHILE           reduce using rule 3 (decvar -> VAR decvarp decvar .)
    FOR             reduce using rule 3 (decvar -> VAR decvarp decvar .)
    MEAN            reduce using rule 3 (decvar -> VAR decvarp decvar .)
    RBRACE          reduce using rule 3 (decvar -> VAR decvarp decvar .)


state 211

    (4) decvarp -> type decvarpp . SEMICOLON

    SEMICOLON       shift and go to state 217


state 212

    (5) decvarpp -> ID . COMMA decvarpp
    (6) decvarpp -> ID .

    COMMA           shift and go to state 218
    SEMICOLON       reduce using rule 6 (decvarpp -> ID .)


state 213

    (95) fit -> ID EQUAL sequential DOT FIT LPAREN array COMMA array COMMA . EPOCHS EQUAL INT COMMA VERBOSE EQUAL fitp

    EPOCHS          shift and go to state 219


state 214

    (99) predictp -> INT RBRACKET RPAREN .

    $end            reduce using rule 99 (predictp -> INT RBRACKET RPAREN .)
    SEMICOLON       reduce using rule 99 (predictp -> INT RBRACKET RPAREN .)
    FUNCTION        reduce using rule 99 (predictp -> INT RBRACKET RPAREN .)
    ID              reduce using rule 99 (predictp -> INT RBRACKET RPAREN .)
    READ            reduce using rule 99 (predictp -> INT RBRACKET RPAREN .)
    PRINT           reduce using rule 99 (predictp -> INT RBRACKET RPAREN .)
    IF              reduce using rule 99 (predictp -> INT RBRACKET RPAREN .)
    WHILE           reduce using rule 99 (predictp -> INT RBRACKET RPAREN .)
    FOR             reduce using rule 99 (predictp -> INT RBRACKET RPAREN .)
    MEAN            reduce using rule 99 (predictp -> INT RBRACKET RPAREN .)
    VAR             reduce using rule 99 (predictp -> INT RBRACKET RPAREN .)
    RBRACE          reduce using rule 99 (predictp -> INT RBRACKET RPAREN .)
    RBRACKET        reduce using rule 99 (predictp -> INT RBRACKET RPAREN .)


state 215

    (100) predictp -> FLOAT RBRACKET RPAREN .

    $end            reduce using rule 100 (predictp -> FLOAT RBRACKET RPAREN .)
    SEMICOLON       reduce using rule 100 (predictp -> FLOAT RBRACKET RPAREN .)
    FUNCTION        reduce using rule 100 (predictp -> FLOAT RBRACKET RPAREN .)
    ID              reduce using rule 100 (predictp -> FLOAT RBRACKET RPAREN .)
    READ            reduce using rule 100 (predictp -> FLOAT RBRACKET RPAREN .)
    PRINT           reduce using rule 100 (predictp -> FLOAT RBRACKET RPAREN .)
    IF              reduce using rule 100 (predictp -> FLOAT RBRACKET RPAREN .)
    WHILE           reduce using rule 100 (predictp -> FLOAT RBRACKET RPAREN .)
    FOR             reduce using rule 100 (predictp -> FLOAT RBRACKET RPAREN .)
    MEAN            reduce using rule 100 (predictp -> FLOAT RBRACKET RPAREN .)
    VAR             reduce using rule 100 (predictp -> FLOAT RBRACKET RPAREN .)
    RBRACE          reduce using rule 100 (predictp -> FLOAT RBRACKET RPAREN .)
    RBRACKET        reduce using rule 100 (predictp -> FLOAT RBRACKET RPAREN .)


state 216

    (71) for -> FOR LPAREN var SEMICOLON exp SEMICOLON exp RPAREN LBRACKET statements . forp
    (72) forp -> . RBRACKET
    (73) forp -> . statements forp
    (41) statements -> . assign
    (42) statements -> . function
    (43) statements -> . voidfunction
    (44) statements -> . call
    (45) statements -> . read
    (46) statements -> . print
    (47) statements -> . if
    (48) statements -> . while
    (49) statements -> . for
    (50) statements -> . funcesp
    (51) assign -> . var EQUAL exp
    (9) function -> . FUNCTION type ID LPAREN param RPAREN body
    (10) voidfunction -> . FUNCTION VOID ID LPAREN param RPAREN body
    (59) call -> . ID LPAREN callp RPAREN
    (52) read -> . READ var
    (53) print -> . PRINT LPAREN printp
    (62) if -> . IF LPAREN INT EQUAL EQUAL CTI RPAREN quadsIf ifp jumpsIf
    (68) while -> . WHILE LPAREN exp RPAREN statements whilep
    (71) for -> . FOR LPAREN var SEMICOLON exp SEMICOLON exp RPAREN LBRACKET statements forp
    (74) funcesp -> . array
    (75) funcesp -> . matrix
    (76) funcesp -> . mean
    (77) funcesp -> . layers
    (78) funcesp -> . sequential
    (79) funcesp -> . compile
    (80) funcesp -> . fit
    (81) funcesp -> . predict
    (82) funcesp -> . getweights
    (56) var -> . ID
    (57) var -> . ID LBRACKET exp RBRACKET
    (58) var -> . ID LBRACKET exp RBRACKET LBRACKET exp RBRACKET
    (83) array -> . ID EQUAL ARRAY LPAREN var arrayp
    (86) matrix -> . ID EQUAL MATRIX LPAREN array matrixp
    (89) mean -> . MEAN LPAREN array RPAREN
    (90) layers -> . ID EQUAL LAYERS LPAREN UNITS EQUAL INT RPAREN
    (91) sequential -> . ID EQUAL SEQUENTIAL LPAREN LBRACKET layers sequentialp
    (94) compile -> . sequential DOT COMPILE LPAREN RPAREN
    (95) fit -> . ID EQUAL sequential DOT FIT LPAREN array COMMA array COMMA EPOCHS EQUAL INT COMMA VERBOSE EQUAL fitp
    (98) predict -> . ID EQUAL sequential DOT PREDICT LPAREN LBRACKET predictp
    (101) getweights -> . layers DOT GETWEIGHTS LPAREN RPAREN

    RBRACKET        shift and go to state 222
    FUNCTION        shift and go to state 30
    ID              shift and go to state 31
    READ            shift and go to state 32
    PRINT           shift and go to state 33
    IF              shift and go to state 6
    WHILE           shift and go to state 34
    FOR             shift and go to state 35
    MEAN            shift and go to state 45

    var                            shift and go to state 29
    statements                     shift and go to state 220
    forp                           shift and go to state 221
    assign                         shift and go to state 19
    function                       shift and go to state 20
    voidfunction                   shift and go to state 21
    call                           shift and go to state 22
    read                           shift and go to state 23
    print                          shift and go to state 24
    if                             shift and go to state 25
    while                          shift and go to state 26
    for                            shift and go to state 27
    funcesp                        shift and go to state 28
    array                          shift and go to state 36
    matrix                         shift and go to state 37
    mean                           shift and go to state 38
    layers                         shift and go to state 39
    sequential                     shift and go to state 40
    compile                        shift and go to state 41
    fit                            shift and go to state 42
    predict                        shift and go to state 43
    getweights                     shift and go to state 44

state 217

    (4) decvarp -> type decvarpp SEMICOLON .

    VAR             reduce using rule 4 (decvarp -> type decvarpp SEMICOLON .)
    FUNCTION        reduce using rule 4 (decvarp -> type decvarpp SEMICOLON .)
    ID              reduce using rule 4 (decvarp -> type decvarpp SEMICOLON .)
    READ            reduce using rule 4 (decvarp -> type decvarpp SEMICOLON .)
    PRINT           reduce using rule 4 (decvarp -> type decvarpp SEMICOLON .)
    IF              reduce using rule 4 (decvarp -> type decvarpp SEMICOLON .)
    WHILE           reduce using rule 4 (decvarp -> type decvarpp SEMICOLON .)
    FOR             reduce using rule 4 (decvarp -> type decvarpp SEMICOLON .)
    MEAN            reduce using rule 4 (decvarp -> type decvarpp SEMICOLON .)
    RBRACE          reduce using rule 4 (decvarp -> type decvarpp SEMICOLON .)


state 218

    (5) decvarpp -> ID COMMA . decvarpp
    (5) decvarpp -> . ID COMMA decvarpp
    (6) decvarpp -> . ID

    ID              shift and go to state 212

    decvarpp                       shift and go to state 223

state 219

    (95) fit -> ID EQUAL sequential DOT FIT LPAREN array COMMA array COMMA EPOCHS . EQUAL INT COMMA VERBOSE EQUAL fitp

    EQUAL           shift and go to state 224


state 220

    (73) forp -> statements . forp
    (72) forp -> . RBRACKET
    (73) forp -> . statements forp
    (41) statements -> . assign
    (42) statements -> . function
    (43) statements -> . voidfunction
    (44) statements -> . call
    (45) statements -> . read
    (46) statements -> . print
    (47) statements -> . if
    (48) statements -> . while
    (49) statements -> . for
    (50) statements -> . funcesp
    (51) assign -> . var EQUAL exp
    (9) function -> . FUNCTION type ID LPAREN param RPAREN body
    (10) voidfunction -> . FUNCTION VOID ID LPAREN param RPAREN body
    (59) call -> . ID LPAREN callp RPAREN
    (52) read -> . READ var
    (53) print -> . PRINT LPAREN printp
    (62) if -> . IF LPAREN INT EQUAL EQUAL CTI RPAREN quadsIf ifp jumpsIf
    (68) while -> . WHILE LPAREN exp RPAREN statements whilep
    (71) for -> . FOR LPAREN var SEMICOLON exp SEMICOLON exp RPAREN LBRACKET statements forp
    (74) funcesp -> . array
    (75) funcesp -> . matrix
    (76) funcesp -> . mean
    (77) funcesp -> . layers
    (78) funcesp -> . sequential
    (79) funcesp -> . compile
    (80) funcesp -> . fit
    (81) funcesp -> . predict
    (82) funcesp -> . getweights
    (56) var -> . ID
    (57) var -> . ID LBRACKET exp RBRACKET
    (58) var -> . ID LBRACKET exp RBRACKET LBRACKET exp RBRACKET
    (83) array -> . ID EQUAL ARRAY LPAREN var arrayp
    (86) matrix -> . ID EQUAL MATRIX LPAREN array matrixp
    (89) mean -> . MEAN LPAREN array RPAREN
    (90) layers -> . ID EQUAL LAYERS LPAREN UNITS EQUAL INT RPAREN
    (91) sequential -> . ID EQUAL SEQUENTIAL LPAREN LBRACKET layers sequentialp
    (94) compile -> . sequential DOT COMPILE LPAREN RPAREN
    (95) fit -> . ID EQUAL sequential DOT FIT LPAREN array COMMA array COMMA EPOCHS EQUAL INT COMMA VERBOSE EQUAL fitp
    (98) predict -> . ID EQUAL sequential DOT PREDICT LPAREN LBRACKET predictp
    (101) getweights -> . layers DOT GETWEIGHTS LPAREN RPAREN

    RBRACKET        shift and go to state 222
    FUNCTION        shift and go to state 30
    ID              shift and go to state 31
    READ            shift and go to state 32
    PRINT           shift and go to state 33
    IF              shift and go to state 6
    WHILE           shift and go to state 34
    FOR             shift and go to state 35
    MEAN            shift and go to state 45

    statements                     shift and go to state 220
    forp                           shift and go to state 225
    assign                         shift and go to state 19
    function                       shift and go to state 20
    voidfunction                   shift and go to state 21
    call                           shift and go to state 22
    read                           shift and go to state 23
    print                          shift and go to state 24
    if                             shift and go to state 25
    while                          shift and go to state 26
    for                            shift and go to state 27
    funcesp                        shift and go to state 28
    var                            shift and go to state 29
    array                          shift and go to state 36
    matrix                         shift and go to state 37
    mean                           shift and go to state 38
    layers                         shift and go to state 39
    sequential                     shift and go to state 40
    compile                        shift and go to state 41
    fit                            shift and go to state 42
    predict                        shift and go to state 43
    getweights                     shift and go to state 44

state 221

    (71) for -> FOR LPAREN var SEMICOLON exp SEMICOLON exp RPAREN LBRACKET statements forp .

    $end            reduce using rule 71 (for -> FOR LPAREN var SEMICOLON exp SEMICOLON exp RPAREN LBRACKET statements forp .)
    SEMICOLON       reduce using rule 71 (for -> FOR LPAREN var SEMICOLON exp SEMICOLON exp RPAREN LBRACKET statements forp .)
    FUNCTION        reduce using rule 71 (for -> FOR LPAREN var SEMICOLON exp SEMICOLON exp RPAREN LBRACKET statements forp .)
    ID              reduce using rule 71 (for -> FOR LPAREN var SEMICOLON exp SEMICOLON exp RPAREN LBRACKET statements forp .)
    READ            reduce using rule 71 (for -> FOR LPAREN var SEMICOLON exp SEMICOLON exp RPAREN LBRACKET statements forp .)
    PRINT           reduce using rule 71 (for -> FOR LPAREN var SEMICOLON exp SEMICOLON exp RPAREN LBRACKET statements forp .)
    IF              reduce using rule 71 (for -> FOR LPAREN var SEMICOLON exp SEMICOLON exp RPAREN LBRACKET statements forp .)
    WHILE           reduce using rule 71 (for -> FOR LPAREN var SEMICOLON exp SEMICOLON exp RPAREN LBRACKET statements forp .)
    FOR             reduce using rule 71 (for -> FOR LPAREN var SEMICOLON exp SEMICOLON exp RPAREN LBRACKET statements forp .)
    MEAN            reduce using rule 71 (for -> FOR LPAREN var SEMICOLON exp SEMICOLON exp RPAREN LBRACKET statements forp .)
    VAR             reduce using rule 71 (for -> FOR LPAREN var SEMICOLON exp SEMICOLON exp RPAREN LBRACKET statements forp .)
    RBRACE          reduce using rule 71 (for -> FOR LPAREN var SEMICOLON exp SEMICOLON exp RPAREN LBRACKET statements forp .)
    RBRACKET        reduce using rule 71 (for -> FOR LPAREN var SEMICOLON exp SEMICOLON exp RPAREN LBRACKET statements forp .)


state 222

    (72) forp -> RBRACKET .

    $end            reduce using rule 72 (forp -> RBRACKET .)
    SEMICOLON       reduce using rule 72 (forp -> RBRACKET .)
    FUNCTION        reduce using rule 72 (forp -> RBRACKET .)
    ID              reduce using rule 72 (forp -> RBRACKET .)
    READ            reduce using rule 72 (forp -> RBRACKET .)
    PRINT           reduce using rule 72 (forp -> RBRACKET .)
    IF              reduce using rule 72 (forp -> RBRACKET .)
    WHILE           reduce using rule 72 (forp -> RBRACKET .)
    FOR             reduce using rule 72 (forp -> RBRACKET .)
    MEAN            reduce using rule 72 (forp -> RBRACKET .)
    VAR             reduce using rule 72 (forp -> RBRACKET .)
    RBRACE          reduce using rule 72 (forp -> RBRACKET .)
    RBRACKET        reduce using rule 72 (forp -> RBRACKET .)


state 223

    (5) decvarpp -> ID COMMA decvarpp .

    SEMICOLON       reduce using rule 5 (decvarpp -> ID COMMA decvarpp .)


state 224

    (95) fit -> ID EQUAL sequential DOT FIT LPAREN array COMMA array COMMA EPOCHS EQUAL . INT COMMA VERBOSE EQUAL fitp

    INT             shift and go to state 226


state 225

    (73) forp -> statements forp .

    $end            reduce using rule 73 (forp -> statements forp .)
    SEMICOLON       reduce using rule 73 (forp -> statements forp .)
    FUNCTION        reduce using rule 73 (forp -> statements forp .)
    ID              reduce using rule 73 (forp -> statements forp .)
    READ            reduce using rule 73 (forp -> statements forp .)
    PRINT           reduce using rule 73 (forp -> statements forp .)
    IF              reduce using rule 73 (forp -> statements forp .)
    WHILE           reduce using rule 73 (forp -> statements forp .)
    FOR             reduce using rule 73 (forp -> statements forp .)
    MEAN            reduce using rule 73 (forp -> statements forp .)
    VAR             reduce using rule 73 (forp -> statements forp .)
    RBRACE          reduce using rule 73 (forp -> statements forp .)
    RBRACKET        reduce using rule 73 (forp -> statements forp .)


state 226

    (95) fit -> ID EQUAL sequential DOT FIT LPAREN array COMMA array COMMA EPOCHS EQUAL INT . COMMA VERBOSE EQUAL fitp

    COMMA           shift and go to state 227


state 227

    (95) fit -> ID EQUAL sequential DOT FIT LPAREN array COMMA array COMMA EPOCHS EQUAL INT COMMA . VERBOSE EQUAL fitp

    VERBOSE         shift and go to state 228


state 228

    (95) fit -> ID EQUAL sequential DOT FIT LPAREN array COMMA array COMMA EPOCHS EQUAL INT COMMA VERBOSE . EQUAL fitp

    EQUAL           shift and go to state 229


state 229

    (95) fit -> ID EQUAL sequential DOT FIT LPAREN array COMMA array COMMA EPOCHS EQUAL INT COMMA VERBOSE EQUAL . fitp
    (96) fitp -> . TRUE RPAREN
    (97) fitp -> . FALSE RPAREN

    TRUE            shift and go to state 231
    FALSE           shift and go to state 232

    fitp                           shift and go to state 230

state 230

    (95) fit -> ID EQUAL sequential DOT FIT LPAREN array COMMA array COMMA EPOCHS EQUAL INT COMMA VERBOSE EQUAL fitp .

    $end            reduce using rule 95 (fit -> ID EQUAL sequential DOT FIT LPAREN array COMMA array COMMA EPOCHS EQUAL INT COMMA VERBOSE EQUAL fitp .)
    SEMICOLON       reduce using rule 95 (fit -> ID EQUAL sequential DOT FIT LPAREN array COMMA array COMMA EPOCHS EQUAL INT COMMA VERBOSE EQUAL fitp .)
    FUNCTION        reduce using rule 95 (fit -> ID EQUAL sequential DOT FIT LPAREN array COMMA array COMMA EPOCHS EQUAL INT COMMA VERBOSE EQUAL fitp .)
    ID              reduce using rule 95 (fit -> ID EQUAL sequential DOT FIT LPAREN array COMMA array COMMA EPOCHS EQUAL INT COMMA VERBOSE EQUAL fitp .)
    READ            reduce using rule 95 (fit -> ID EQUAL sequential DOT FIT LPAREN array COMMA array COMMA EPOCHS EQUAL INT COMMA VERBOSE EQUAL fitp .)
    PRINT           reduce using rule 95 (fit -> ID EQUAL sequential DOT FIT LPAREN array COMMA array COMMA EPOCHS EQUAL INT COMMA VERBOSE EQUAL fitp .)
    IF              reduce using rule 95 (fit -> ID EQUAL sequential DOT FIT LPAREN array COMMA array COMMA EPOCHS EQUAL INT COMMA VERBOSE EQUAL fitp .)
    WHILE           reduce using rule 95 (fit -> ID EQUAL sequential DOT FIT LPAREN array COMMA array COMMA EPOCHS EQUAL INT COMMA VERBOSE EQUAL fitp .)
    FOR             reduce using rule 95 (fit -> ID EQUAL sequential DOT FIT LPAREN array COMMA array COMMA EPOCHS EQUAL INT COMMA VERBOSE EQUAL fitp .)
    MEAN            reduce using rule 95 (fit -> ID EQUAL sequential DOT FIT LPAREN array COMMA array COMMA EPOCHS EQUAL INT COMMA VERBOSE EQUAL fitp .)
    VAR             reduce using rule 95 (fit -> ID EQUAL sequential DOT FIT LPAREN array COMMA array COMMA EPOCHS EQUAL INT COMMA VERBOSE EQUAL fitp .)
    RBRACE          reduce using rule 95 (fit -> ID EQUAL sequential DOT FIT LPAREN array COMMA array COMMA EPOCHS EQUAL INT COMMA VERBOSE EQUAL fitp .)
    RBRACKET        reduce using rule 95 (fit -> ID EQUAL sequential DOT FIT LPAREN array COMMA array COMMA EPOCHS EQUAL INT COMMA VERBOSE EQUAL fitp .)


state 231

    (96) fitp -> TRUE . RPAREN

    RPAREN          shift and go to state 233


state 232

    (97) fitp -> FALSE . RPAREN

    RPAREN          shift and go to state 234


state 233

    (96) fitp -> TRUE RPAREN .

    $end            reduce using rule 96 (fitp -> TRUE RPAREN .)
    SEMICOLON       reduce using rule 96 (fitp -> TRUE RPAREN .)
    FUNCTION        reduce using rule 96 (fitp -> TRUE RPAREN .)
    ID              reduce using rule 96 (fitp -> TRUE RPAREN .)
    READ            reduce using rule 96 (fitp -> TRUE RPAREN .)
    PRINT           reduce using rule 96 (fitp -> TRUE RPAREN .)
    IF              reduce using rule 96 (fitp -> TRUE RPAREN .)
    WHILE           reduce using rule 96 (fitp -> TRUE RPAREN .)
    FOR             reduce using rule 96 (fitp -> TRUE RPAREN .)
    MEAN            reduce using rule 96 (fitp -> TRUE RPAREN .)
    VAR             reduce using rule 96 (fitp -> TRUE RPAREN .)
    RBRACE          reduce using rule 96 (fitp -> TRUE RPAREN .)
    RBRACKET        reduce using rule 96 (fitp -> TRUE RPAREN .)


state 234

    (97) fitp -> FALSE RPAREN .

    $end            reduce using rule 97 (fitp -> FALSE RPAREN .)
    SEMICOLON       reduce using rule 97 (fitp -> FALSE RPAREN .)
    FUNCTION        reduce using rule 97 (fitp -> FALSE RPAREN .)
    ID              reduce using rule 97 (fitp -> FALSE RPAREN .)
    READ            reduce using rule 97 (fitp -> FALSE RPAREN .)
    PRINT           reduce using rule 97 (fitp -> FALSE RPAREN .)
    IF              reduce using rule 97 (fitp -> FALSE RPAREN .)
    WHILE           reduce using rule 97 (fitp -> FALSE RPAREN .)
    FOR             reduce using rule 97 (fitp -> FALSE RPAREN .)
    MEAN            reduce using rule 97 (fitp -> FALSE RPAREN .)
    VAR             reduce using rule 97 (fitp -> FALSE RPAREN .)
    RBRACE          reduce using rule 97 (fitp -> FALSE RPAREN .)
    RBRACKET        reduce using rule 97 (fitp -> FALSE RPAREN .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for EQUAL in state 31 resolved as shift
