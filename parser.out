Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    ASSIGN
    COLON
    FUNCESP
    GTE
    LTE
    NUMPY
    QUOTE

Grammar

Rule 0     S' -> program
Rule 1     program -> PROGRAM ID SEMICOLON
Rule 2     decvar -> VAR type ID decvarp
Rule 3     decvarp -> SEMICOLON
Rule 4     decvarp -> LBRACKET INT RBRACKET decvarpp
Rule 5     decvarpp -> SEMICOLON
Rule 6     decvarpp -> LBRACKET INT RBRACKET
Rule 7     type -> INT
Rule 8     type -> FLOAT
Rule 9     type -> CHAR
Rule 10    type -> STRING
Rule 11    function -> FUNCTION type ID LPAREN param RPAREN body
Rule 12    voidfunction -> FUNCTION VOID ID LPAREN param RPAREN body
Rule 13    body -> LBRACE bodyp RBRACE
Rule 14    bodyp -> decvar statements bodyp
Rule 15    bodyp -> statements bodyp
Rule 16    bodyp -> decvar
Rule 17    bodyp -> <empty>
Rule 18    param -> <empty>
Rule 19    param -> type paramp
Rule 20    paramp -> ID
Rule 21    paramp -> ID COMMA param
Rule 22    exp -> texp
Rule 23    exp -> texp OR exp
Rule 24    texp -> gexp
Rule 25    texp -> gexp AND texp
Rule 26    gexp -> mexp
Rule 27    gexp -> mexp gexpp mexp
Rule 28    gexpp -> LT
Rule 29    gexpp -> GT
Rule 30    gexpp -> EQUAL
Rule 31    gexpp -> DIFF
Rule 32    mexp -> t
Rule 33    mexp -> t PLUS mexp
Rule 34    mexp -> t MINUS mexp
Rule 35    t -> f
Rule 36    t -> f MULT t
Rule 37    t -> f DIV t
Rule 38    f -> LPAREN exp RPAREN
Rule 39    f -> INT
Rule 40    f -> FLOAT
Rule 41    f -> var
Rule 42    f -> call
Rule 43    statements -> assign
Rule 44    statements -> call
Rule 45    statements -> read
Rule 46    statements -> print
Rule 47    statements -> if
Rule 48    statements -> while
Rule 49    statements -> for
Rule 50    statements -> funcesp
Rule 51    assign -> var EQUAL exp
Rule 52    read -> READ var
Rule 53    print -> PRINT LPAREN printp
Rule 54    printp -> exp RPAREN
Rule 55    printp -> exp COMMA printp
Rule 56    var -> ID
Rule 57    var -> ID LBRACKET exp RBRACKET
Rule 58    var -> ID LBRACKET exp RBRACKET LBRACKET exp RBRACKET
Rule 59    call -> ID LPAREN callp RPAREN
Rule 60    callp -> exp SEMICOLON callp
Rule 61    callp -> exp
Rule 62    if -> IF LPAREN exp RPAREN statements ifp
Rule 63    ifp -> <empty>
Rule 64    ifp -> ELSE statements
Rule 65    while -> WHILE LPAREN exp RPAREN statements whilep
Rule 66    whilep -> SEMICOLON
Rule 67    whilep -> statements whilep
Rule 68    for -> FOR LPAREN var SEMICOLON exp SEMICOLON exp RPAREN LBRACKET statements forp
Rule 69    forp -> RBRACKET
Rule 70    forp -> statements forp
Rule 71    funcesp -> array
Rule 72    funcesp -> matrix
Rule 73    funcesp -> mean
Rule 74    funcesp -> layers
Rule 75    funcesp -> sequential
Rule 76    funcesp -> compile
Rule 77    funcesp -> fit
Rule 78    funcesp -> predict
Rule 79    funcesp -> getweights
Rule 80    array -> ID EQUAL ARRAY LPAREN var arrayp
Rule 81    arrayp -> RPAREN
Rule 82    arrayp -> COMMA var RPAREN
Rule 83    matrix -> ID EQUAL MATRIX LPAREN array matrixp
Rule 84    matrixp -> RPAREN
Rule 85    matrixp -> COMMA array RPAREN
Rule 86    mean -> MEAN LPAREN array RPAREN
Rule 87    layers -> ID EQUAL LAYERS LPAREN UNITS EQUAL INT RPAREN
Rule 88    sequential -> ID EQUAL SEQUENTIAL LPAREN LBRACKET layers sequentialp
Rule 89    sequentialp -> RBRACKET RPAREN
Rule 90    sequentialp -> COMMA layers sequentialp
Rule 91    compile -> sequential DOT COMPILE LPAREN RPAREN
Rule 92    fit -> ID EQUAL sequential DOT FIT LPAREN array COMMA array COMMA EPOCHS EQUAL INT COMMA VERBOSE EQUAL fitp
Rule 93    fitp -> TRUE RPAREN
Rule 94    fitp -> FALSE RPAREN
Rule 95    predict -> ID EQUAL sequential DOT PREDICT LPAREN LBRACKET predictp
Rule 96    predictp -> INT RBRACKET RPAREN
Rule 97    predictp -> FLOAT RBRACKET RPAREN
Rule 98    getweights -> layers DOT GETWEIGHTS LPAREN RPAREN
Rule 99    empty -> <empty>

Terminals, with rules where they appear

AND                  : 25
ARRAY                : 80
ASSIGN               : 
CHAR                 : 9
COLON                : 
COMMA                : 21 55 82 85 90 92 92 92
COMPILE              : 91
DIFF                 : 31
DIV                  : 37
DOT                  : 91 92 95 98
ELSE                 : 64
EPOCHS               : 92
EQUAL                : 30 51 80 83 87 87 88 92 92 92 95
FALSE                : 94
FIT                  : 92
FLOAT                : 8 40 97
FOR                  : 68
FUNCESP              : 
FUNCTION             : 11 12
GETWEIGHTS           : 98
GT                   : 29
GTE                  : 
ID                   : 1 2 11 12 20 21 56 57 58 59 80 83 87 88 92 95
IF                   : 62
INT                  : 4 6 7 39 87 92 96
LAYERS               : 87
LBRACE               : 13
LBRACKET             : 4 6 57 58 58 68 88 95
LPAREN               : 11 12 38 53 59 62 65 68 80 83 86 87 88 91 92 95 98
LT                   : 28
LTE                  : 
MATRIX               : 83
MEAN                 : 86
MINUS                : 34
MULT                 : 36
NUMPY                : 
OR                   : 23
PLUS                 : 33
PREDICT              : 95
PRINT                : 53
PROGRAM              : 1
QUOTE                : 
RBRACE               : 13
RBRACKET             : 4 6 57 58 58 69 89 96 97
READ                 : 52
RPAREN               : 11 12 38 54 59 62 65 68 81 82 84 85 86 87 89 91 93 94 96 97 98
SEMICOLON            : 1 3 5 60 66 68 68
SEQUENTIAL           : 88
STRING               : 10
TRUE                 : 93
UNITS                : 87
VAR                  : 2
VERBOSE              : 92
VOID                 : 12
WHILE                : 65
error                : 

Nonterminals, with rules where they appear

array                : 71 83 85 86 92 92
arrayp               : 80
assign               : 43
body                 : 11 12
bodyp                : 13 14 15
call                 : 42 44
callp                : 59 60
compile              : 76
decvar               : 14 16
decvarp              : 2
decvarpp             : 4
empty                : 
exp                  : 23 38 51 54 55 57 58 58 60 61 62 65 68 68
f                    : 35 36 37
fit                  : 77
fitp                 : 92
for                  : 49
forp                 : 68 70
funcesp              : 50
function             : 
getweights           : 79
gexp                 : 24 25
gexpp                : 27
if                   : 47
ifp                  : 62
layers               : 74 88 90 98
matrix               : 72
matrixp              : 83
mean                 : 73
mexp                 : 26 27 27 33 34
param                : 11 12 21
paramp               : 19
predict              : 78
predictp             : 95
print                : 46
printp               : 53 55
program              : 0
read                 : 45
sequential           : 75 91 92 95
sequentialp          : 88 90
statements           : 14 15 62 64 65 67 68 70
t                    : 32 33 34 36 37
texp                 : 22 23 25
type                 : 2 11 19
var                  : 41 51 52 68 80 82
voidfunction         : 
while                : 48
whilep               : 65 67

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . PROGRAM ID SEMICOLON

    PROGRAM         shift and go to state 2

    program                        shift and go to state 1

state 1

    (0) S' -> program .



state 2

    (1) program -> PROGRAM . ID SEMICOLON

    ID              shift and go to state 3


state 3

    (1) program -> PROGRAM ID . SEMICOLON

    SEMICOLON       shift and go to state 4


state 4

    (1) program -> PROGRAM ID SEMICOLON .

    $end            reduce using rule 1 (program -> PROGRAM ID SEMICOLON .)

